function aW(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const a in r)if(a!=="default"&&!(a in e)){const s=Object.getOwnPropertyDescriptor(r,a);s&&Object.defineProperty(e,a,s.get?s:{enumerable:!0,get:()=>r[a]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))r(a);new MutationObserver(a=>{for(const s of a)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(a){const s={};return a.integrity&&(s.integrity=a.integrity),a.referrerPolicy&&(s.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?s.credentials="include":a.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(a){if(a.ep)return;a.ep=!0;const s=n(a);fetch(a.href,s)}})();function sW(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var w_={exports:{}},Zy={},k_={exports:{}},Ye={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var cf=Symbol.for("react.element"),iW=Symbol.for("react.portal"),oW=Symbol.for("react.fragment"),lW=Symbol.for("react.strict_mode"),uW=Symbol.for("react.profiler"),dW=Symbol.for("react.provider"),cW=Symbol.for("react.context"),pW=Symbol.for("react.forward_ref"),hW=Symbol.for("react.suspense"),fW=Symbol.for("react.memo"),mW=Symbol.for("react.lazy"),QN=Symbol.iterator;function gW(e){return e===null||typeof e!="object"?null:(e=QN&&e[QN]||e["@@iterator"],typeof e=="function"?e:null)}var S_={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},I_=Object.assign,N_={};function rc(e,t,n){this.props=e,this.context=t,this.refs=N_,this.updater=n||S_}rc.prototype.isReactComponent={};rc.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};rc.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function C_(){}C_.prototype=rc.prototype;function f1(e,t,n){this.props=e,this.context=t,this.refs=N_,this.updater=n||S_}var m1=f1.prototype=new C_;m1.constructor=f1;I_(m1,rc.prototype);m1.isPureReactComponent=!0;var JN=Array.isArray,T_=Object.prototype.hasOwnProperty,g1={current:null},E_={key:!0,ref:!0,__self:!0,__source:!0};function __(e,t,n){var r,a={},s=null,i=null;if(t!=null)for(r in t.ref!==void 0&&(i=t.ref),t.key!==void 0&&(s=""+t.key),t)T_.call(t,r)&&!E_.hasOwnProperty(r)&&(a[r]=t[r]);var o=arguments.length-2;if(o===1)a.children=n;else if(1<o){for(var l=Array(o),d=0;d<o;d++)l[d]=arguments[d+2];a.children=l}if(e&&e.defaultProps)for(r in o=e.defaultProps,o)a[r]===void 0&&(a[r]=o[r]);return{$$typeof:cf,type:e,key:s,ref:i,props:a,_owner:g1.current}}function yW(e,t){return{$$typeof:cf,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function y1(e){return typeof e=="object"&&e!==null&&e.$$typeof===cf}function bW(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var ZN=/\/+/g;function ax(e,t){return typeof e=="object"&&e!==null&&e.key!=null?bW(""+e.key):t.toString(36)}function Sg(e,t,n,r,a){var s=typeof e;(s==="undefined"||s==="boolean")&&(e=null);var i=!1;if(e===null)i=!0;else switch(s){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case cf:case iW:i=!0}}if(i)return i=e,a=a(i),e=r===""?"."+ax(i,0):r,JN(a)?(n="",e!=null&&(n=e.replace(ZN,"$&/")+"/"),Sg(a,t,n,"",function(d){return d})):a!=null&&(y1(a)&&(a=yW(a,n+(!a.key||i&&i.key===a.key?"":(""+a.key).replace(ZN,"$&/")+"/")+e)),t.push(a)),1;if(i=0,r=r===""?".":r+":",JN(e))for(var o=0;o<e.length;o++){s=e[o];var l=r+ax(s,o);i+=Sg(s,t,n,l,a)}else if(l=gW(e),typeof l=="function")for(e=l.call(e),o=0;!(s=e.next()).done;)s=s.value,l=r+ax(s,o++),i+=Sg(s,t,n,l,a);else if(s==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return i}function Wm(e,t,n){if(e==null)return e;var r=[],a=0;return Sg(e,r,"","",function(s){return t.call(n,s,a++)}),r}function vW(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var yr={current:null},Ig={transition:null},xW={ReactCurrentDispatcher:yr,ReactCurrentBatchConfig:Ig,ReactCurrentOwner:g1};function $_(){throw Error("act(...) is not supported in production builds of React.")}Ye.Children={map:Wm,forEach:function(e,t,n){Wm(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return Wm(e,function(){t++}),t},toArray:function(e){return Wm(e,function(t){return t})||[]},only:function(e){if(!y1(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};Ye.Component=rc;Ye.Fragment=oW;Ye.Profiler=uW;Ye.PureComponent=f1;Ye.StrictMode=lW;Ye.Suspense=hW;Ye.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=xW;Ye.act=$_;Ye.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=I_({},e.props),a=e.key,s=e.ref,i=e._owner;if(t!=null){if(t.ref!==void 0&&(s=t.ref,i=g1.current),t.key!==void 0&&(a=""+t.key),e.type&&e.type.defaultProps)var o=e.type.defaultProps;for(l in t)T_.call(t,l)&&!E_.hasOwnProperty(l)&&(r[l]=t[l]===void 0&&o!==void 0?o[l]:t[l])}var l=arguments.length-2;if(l===1)r.children=n;else if(1<l){o=Array(l);for(var d=0;d<l;d++)o[d]=arguments[d+2];r.children=o}return{$$typeof:cf,type:e.type,key:a,ref:s,props:r,_owner:i}};Ye.createContext=function(e){return e={$$typeof:cW,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:dW,_context:e},e.Consumer=e};Ye.createElement=__;Ye.createFactory=function(e){var t=__.bind(null,e);return t.type=e,t};Ye.createRef=function(){return{current:null}};Ye.forwardRef=function(e){return{$$typeof:pW,render:e}};Ye.isValidElement=y1;Ye.lazy=function(e){return{$$typeof:mW,_payload:{_status:-1,_result:e},_init:vW}};Ye.memo=function(e,t){return{$$typeof:fW,type:e,compare:t===void 0?null:t}};Ye.startTransition=function(e){var t=Ig.transition;Ig.transition={};try{e()}finally{Ig.transition=t}};Ye.unstable_act=$_;Ye.useCallback=function(e,t){return yr.current.useCallback(e,t)};Ye.useContext=function(e){return yr.current.useContext(e)};Ye.useDebugValue=function(){};Ye.useDeferredValue=function(e){return yr.current.useDeferredValue(e)};Ye.useEffect=function(e,t){return yr.current.useEffect(e,t)};Ye.useId=function(){return yr.current.useId()};Ye.useImperativeHandle=function(e,t,n){return yr.current.useImperativeHandle(e,t,n)};Ye.useInsertionEffect=function(e,t){return yr.current.useInsertionEffect(e,t)};Ye.useLayoutEffect=function(e,t){return yr.current.useLayoutEffect(e,t)};Ye.useMemo=function(e,t){return yr.current.useMemo(e,t)};Ye.useReducer=function(e,t,n){return yr.current.useReducer(e,t,n)};Ye.useRef=function(e){return yr.current.useRef(e)};Ye.useState=function(e){return yr.current.useState(e)};Ye.useSyncExternalStore=function(e,t,n){return yr.current.useSyncExternalStore(e,t,n)};Ye.useTransition=function(){return yr.current.useTransition()};Ye.version="18.3.1";k_.exports=Ye;var Y=k_.exports;const Kt=sW(Y),wW=aW({__proto__:null,default:Kt},[Y]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var kW=Y,SW=Symbol.for("react.element"),IW=Symbol.for("react.fragment"),NW=Object.prototype.hasOwnProperty,CW=kW.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,TW={key:!0,ref:!0,__self:!0,__source:!0};function A_(e,t,n){var r,a={},s=null,i=null;n!==void 0&&(s=""+n),t.key!==void 0&&(s=""+t.key),t.ref!==void 0&&(i=t.ref);for(r in t)NW.call(t,r)&&!TW.hasOwnProperty(r)&&(a[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps,t)a[r]===void 0&&(a[r]=t[r]);return{$$typeof:SW,type:e,key:s,ref:i,props:a,_owner:CW.current}}Zy.Fragment=IW;Zy.jsx=A_;Zy.jsxs=A_;w_.exports=Zy;var $=w_.exports,r0={},R_={exports:{}},ra={},F_={exports:{}},D_={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(P,q){var Q=P.length;P.push(q);e:for(;0<Q;){var J=Q-1>>>1,re=P[J];if(0<a(re,q))P[J]=q,P[Q]=re,Q=J;else break e}}function n(P){return P.length===0?null:P[0]}function r(P){if(P.length===0)return null;var q=P[0],Q=P.pop();if(Q!==q){P[0]=Q;e:for(var J=0,re=P.length,ae=re>>>1;J<ae;){var ie=2*(J+1)-1,le=P[ie],xe=ie+1,we=P[xe];if(0>a(le,Q))xe<re&&0>a(we,le)?(P[J]=we,P[xe]=Q,J=xe):(P[J]=le,P[ie]=Q,J=ie);else if(xe<re&&0>a(we,Q))P[J]=we,P[xe]=Q,J=xe;else break e}}return q}function a(P,q){var Q=P.sortIndex-q.sortIndex;return Q!==0?Q:P.id-q.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;e.unstable_now=function(){return s.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var l=[],d=[],u=1,c=null,p=3,h=!1,f=!1,m=!1,g=typeof setTimeout=="function"?setTimeout:null,y=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function v(P){for(var q=n(d);q!==null;){if(q.callback===null)r(d);else if(q.startTime<=P)r(d),q.sortIndex=q.expirationTime,t(l,q);else break;q=n(d)}}function x(P){if(m=!1,v(P),!f)if(n(l)!==null)f=!0,G(w);else{var q=n(d);q!==null&&X(x,q.startTime-P)}}function w(P,q){f=!1,m&&(m=!1,y(T),T=-1),h=!0;var Q=p;try{for(v(q),c=n(l);c!==null&&(!(c.expirationTime>q)||P&&!F());){var J=c.callback;if(typeof J=="function"){c.callback=null,p=c.priorityLevel;var re=J(c.expirationTime<=q);q=e.unstable_now(),typeof re=="function"?c.callback=re:c===n(l)&&r(l),v(q)}else r(l);c=n(l)}if(c!==null)var ae=!0;else{var ie=n(d);ie!==null&&X(x,ie.startTime-q),ae=!1}return ae}finally{c=null,p=Q,h=!1}}var I=!1,N=null,T=-1,A=5,R=-1;function F(){return!(e.unstable_now()-R<A)}function C(){if(N!==null){var P=e.unstable_now();R=P;var q=!0;try{q=N(!0,P)}finally{q?M():(I=!1,N=null)}}else I=!1}var M;if(typeof b=="function")M=function(){b(C)};else if(typeof MessageChannel<"u"){var B=new MessageChannel,U=B.port2;B.port1.onmessage=C,M=function(){U.postMessage(null)}}else M=function(){g(C,0)};function G(P){N=P,I||(I=!0,M())}function X(P,q){T=g(function(){P(e.unstable_now())},q)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(P){P.callback=null},e.unstable_continueExecution=function(){f||h||(f=!0,G(w))},e.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):A=0<P?Math.floor(1e3/P):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return n(l)},e.unstable_next=function(P){switch(p){case 1:case 2:case 3:var q=3;break;default:q=p}var Q=p;p=q;try{return P()}finally{p=Q}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(P,q){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var Q=p;p=P;try{return q()}finally{p=Q}},e.unstable_scheduleCallback=function(P,q,Q){var J=e.unstable_now();switch(typeof Q=="object"&&Q!==null?(Q=Q.delay,Q=typeof Q=="number"&&0<Q?J+Q:J):Q=J,P){case 1:var re=-1;break;case 2:re=250;break;case 5:re=1073741823;break;case 4:re=1e4;break;default:re=5e3}return re=Q+re,P={id:u++,callback:q,priorityLevel:P,startTime:Q,expirationTime:re,sortIndex:-1},Q>J?(P.sortIndex=Q,t(d,P),n(l)===null&&P===n(d)&&(m?(y(T),T=-1):m=!0,X(x,Q-J))):(P.sortIndex=re,t(l,P),f||h||(f=!0,G(w))),P},e.unstable_shouldYield=F,e.unstable_wrapCallback=function(P){var q=p;return function(){var Q=p;p=q;try{return P.apply(this,arguments)}finally{p=Q}}}})(D_);F_.exports=D_;var EW=F_.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _W=Y,Yr=EW;function de(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var M_=new Set,Th={};function yl(e,t){Ad(e,t),Ad(e+"Capture",t)}function Ad(e,t){for(Th[e]=t,e=0;e<t.length;e++)M_.add(t[e])}var Ds=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),a0=Object.prototype.hasOwnProperty,$W=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,YN={},eC={};function AW(e){return a0.call(eC,e)?!0:a0.call(YN,e)?!1:$W.test(e)?eC[e]=!0:(YN[e]=!0,!1)}function RW(e,t,n,r){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function FW(e,t,n,r){if(t===null||typeof t>"u"||RW(e,t,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function br(e,t,n,r,a,s,i){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=i}var Mn={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){Mn[e]=new br(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];Mn[t]=new br(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){Mn[e]=new br(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){Mn[e]=new br(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){Mn[e]=new br(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){Mn[e]=new br(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){Mn[e]=new br(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){Mn[e]=new br(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){Mn[e]=new br(e,5,!1,e.toLowerCase(),null,!1,!1)});var b1=/[\-:]([a-z])/g;function v1(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(b1,v1);Mn[t]=new br(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(b1,v1);Mn[t]=new br(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(b1,v1);Mn[t]=new br(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){Mn[e]=new br(e,1,!1,e.toLowerCase(),null,!1,!1)});Mn.xlinkHref=new br("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){Mn[e]=new br(e,1,!1,e.toLowerCase(),null,!0,!0)});function x1(e,t,n,r){var a=Mn.hasOwnProperty(t)?Mn[t]:null;(a!==null?a.type!==0:r||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(FW(t,n,a,r)&&(n=null),r||a===null?AW(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=n===null?a.type===3?!1:"":n:(t=a.attributeName,r=a.attributeNamespace,n===null?e.removeAttribute(t):(a=a.type,n=a===3||a===4&&n===!0?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}var Bs=_W.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Um=Symbol.for("react.element"),id=Symbol.for("react.portal"),od=Symbol.for("react.fragment"),w1=Symbol.for("react.strict_mode"),s0=Symbol.for("react.profiler"),O_=Symbol.for("react.provider"),P_=Symbol.for("react.context"),k1=Symbol.for("react.forward_ref"),i0=Symbol.for("react.suspense"),o0=Symbol.for("react.suspense_list"),S1=Symbol.for("react.memo"),ai=Symbol.for("react.lazy"),L_=Symbol.for("react.offscreen"),tC=Symbol.iterator;function zp(e){return e===null||typeof e!="object"?null:(e=tC&&e[tC]||e["@@iterator"],typeof e=="function"?e:null)}var Bt=Object.assign,sx;function Yp(e){if(sx===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);sx=t&&t[1]||""}return`
`+sx+e}var ix=!1;function ox(e,t){if(!e||ix)return"";ix=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(d){var r=d}Reflect.construct(e,[],t)}else{try{t.call()}catch(d){r=d}e.call(t.prototype)}else{try{throw Error()}catch(d){r=d}e()}}catch(d){if(d&&r&&typeof d.stack=="string"){for(var a=d.stack.split(`
`),s=r.stack.split(`
`),i=a.length-1,o=s.length-1;1<=i&&0<=o&&a[i]!==s[o];)o--;for(;1<=i&&0<=o;i--,o--)if(a[i]!==s[o]){if(i!==1||o!==1)do if(i--,o--,0>o||a[i]!==s[o]){var l=`
`+a[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}while(1<=i&&0<=o);break}}}finally{ix=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?Yp(e):""}function DW(e){switch(e.tag){case 5:return Yp(e.type);case 16:return Yp("Lazy");case 13:return Yp("Suspense");case 19:return Yp("SuspenseList");case 0:case 2:case 15:return e=ox(e.type,!1),e;case 11:return e=ox(e.type.render,!1),e;case 1:return e=ox(e.type,!0),e;default:return""}}function l0(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case od:return"Fragment";case id:return"Portal";case s0:return"Profiler";case w1:return"StrictMode";case i0:return"Suspense";case o0:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case P_:return(e.displayName||"Context")+".Consumer";case O_:return(e._context.displayName||"Context")+".Provider";case k1:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case S1:return t=e.displayName||null,t!==null?t:l0(e.type)||"Memo";case ai:t=e._payload,e=e._init;try{return l0(e(t))}catch{}}return null}function MW(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return l0(t);case 8:return t===w1?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function $i(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function z_(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function OW(e){var t=z_(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var a=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(i){r=""+i,s.call(this,i)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(i){r=""+i},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function Vm(e){e._valueTracker||(e._valueTracker=OW(e))}function B_(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=z_(e)?e.checked?"true":"false":e.value),e=r,e!==n?(t.setValue(e),!0):!1}function qg(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function u0(e,t){var n=t.checked;return Bt({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function nC(e,t){var n=t.defaultValue==null?"":t.defaultValue,r=t.checked!=null?t.checked:t.defaultChecked;n=$i(t.value!=null?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function W_(e,t){t=t.checked,t!=null&&x1(e,"checked",t,!1)}function d0(e,t){W_(e,t);var n=$i(t.value),r=t.type;if(n!=null)r==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(r==="submit"||r==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?c0(e,t.type,n):t.hasOwnProperty("defaultValue")&&c0(e,t.type,$i(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function rC(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!(r!=="submit"&&r!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function c0(e,t,n){(t!=="number"||qg(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var eh=Array.isArray;function xd(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+$i(n),t=null,a=0;a<e.length;a++){if(e[a].value===n){e[a].selected=!0,r&&(e[a].defaultSelected=!0);return}t!==null||e[a].disabled||(t=e[a])}t!==null&&(t.selected=!0)}}function p0(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(de(91));return Bt({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function aC(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(de(92));if(eh(n)){if(1<n.length)throw Error(de(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:$i(n)}}function U_(e,t){var n=$i(t.value),r=$i(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),r!=null&&(e.defaultValue=""+r)}function sC(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function V_(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function h0(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?V_(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var jm,j_=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,r,a){MSApp.execUnsafeLocalFunction(function(){return e(t,n,r,a)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(jm=jm||document.createElement("div"),jm.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=jm.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function Eh(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var hh={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},PW=["Webkit","ms","Moz","O"];Object.keys(hh).forEach(function(e){PW.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),hh[t]=hh[e]})});function H_(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||hh.hasOwnProperty(e)&&hh[e]?(""+t).trim():t+"px"}function G_(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var r=n.indexOf("--")===0,a=H_(n,t[n],r);n==="float"&&(n="cssFloat"),r?e.setProperty(n,a):e[n]=a}}var LW=Bt({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function f0(e,t){if(t){if(LW[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(de(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(de(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(de(61))}if(t.style!=null&&typeof t.style!="object")throw Error(de(62))}}function m0(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var g0=null;function I1(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var y0=null,wd=null,kd=null;function iC(e){if(e=ff(e)){if(typeof y0!="function")throw Error(de(280));var t=e.stateNode;t&&(t=rb(t),y0(e.stateNode,e.type,t))}}function q_(e){wd?kd?kd.push(e):kd=[e]:wd=e}function K_(){if(wd){var e=wd,t=kd;if(kd=wd=null,iC(e),t)for(e=0;e<t.length;e++)iC(t[e])}}function X_(e,t){return e(t)}function Q_(){}var lx=!1;function J_(e,t,n){if(lx)return e(t,n);lx=!0;try{return X_(e,t,n)}finally{lx=!1,(wd!==null||kd!==null)&&(Q_(),K_())}}function _h(e,t){var n=e.stateNode;if(n===null)return null;var r=rb(n);if(r===null)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(e=e.type,r=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!r;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(de(231,t,typeof n));return n}var b0=!1;if(Ds)try{var Bp={};Object.defineProperty(Bp,"passive",{get:function(){b0=!0}}),window.addEventListener("test",Bp,Bp),window.removeEventListener("test",Bp,Bp)}catch{b0=!1}function zW(e,t,n,r,a,s,i,o,l){var d=Array.prototype.slice.call(arguments,3);try{t.apply(n,d)}catch(u){this.onError(u)}}var fh=!1,Kg=null,Xg=!1,v0=null,BW={onError:function(e){fh=!0,Kg=e}};function WW(e,t,n,r,a,s,i,o,l){fh=!1,Kg=null,zW.apply(BW,arguments)}function UW(e,t,n,r,a,s,i,o,l){if(WW.apply(this,arguments),fh){if(fh){var d=Kg;fh=!1,Kg=null}else throw Error(de(198));Xg||(Xg=!0,v0=d)}}function bl(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function Z_(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function oC(e){if(bl(e)!==e)throw Error(de(188))}function VW(e){var t=e.alternate;if(!t){if(t=bl(e),t===null)throw Error(de(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(a===null)break;var s=a.alternate;if(s===null){if(r=a.return,r!==null){n=r;continue}break}if(a.child===s.child){for(s=a.child;s;){if(s===n)return oC(a),e;if(s===r)return oC(a),t;s=s.sibling}throw Error(de(188))}if(n.return!==r.return)n=a,r=s;else{for(var i=!1,o=a.child;o;){if(o===n){i=!0,n=a,r=s;break}if(o===r){i=!0,r=a,n=s;break}o=o.sibling}if(!i){for(o=s.child;o;){if(o===n){i=!0,n=s,r=a;break}if(o===r){i=!0,r=s,n=a;break}o=o.sibling}if(!i)throw Error(de(189))}}if(n.alternate!==r)throw Error(de(190))}if(n.tag!==3)throw Error(de(188));return n.stateNode.current===n?e:t}function Y_(e){return e=VW(e),e!==null?e$(e):null}function e$(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=e$(e);if(t!==null)return t;e=e.sibling}return null}var t$=Yr.unstable_scheduleCallback,lC=Yr.unstable_cancelCallback,jW=Yr.unstable_shouldYield,HW=Yr.unstable_requestPaint,Qt=Yr.unstable_now,GW=Yr.unstable_getCurrentPriorityLevel,N1=Yr.unstable_ImmediatePriority,n$=Yr.unstable_UserBlockingPriority,Qg=Yr.unstable_NormalPriority,qW=Yr.unstable_LowPriority,r$=Yr.unstable_IdlePriority,Yy=null,as=null;function KW(e){if(as&&typeof as.onCommitFiberRoot=="function")try{as.onCommitFiberRoot(Yy,e,void 0,(e.current.flags&128)===128)}catch{}}var $a=Math.clz32?Math.clz32:JW,XW=Math.log,QW=Math.LN2;function JW(e){return e>>>=0,e===0?32:31-(XW(e)/QW|0)|0}var Hm=64,Gm=4194304;function th(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function Jg(e,t){var n=e.pendingLanes;if(n===0)return 0;var r=0,a=e.suspendedLanes,s=e.pingedLanes,i=n&268435455;if(i!==0){var o=i&~a;o!==0?r=th(o):(s&=i,s!==0&&(r=th(s)))}else i=n&~a,i!==0?r=th(i):s!==0&&(r=th(s));if(r===0)return 0;if(t!==0&&t!==r&&!(t&a)&&(a=r&-r,s=t&-t,a>=s||a===16&&(s&4194240)!==0))return t;if(r&4&&(r|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=r;0<t;)n=31-$a(t),a=1<<n,r|=e[n],t&=~a;return r}function ZW(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function YW(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,s=e.pendingLanes;0<s;){var i=31-$a(s),o=1<<i,l=a[i];l===-1?(!(o&n)||o&r)&&(a[i]=ZW(o,t)):l<=t&&(e.expiredLanes|=o),s&=~o}}function x0(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function a$(){var e=Hm;return Hm<<=1,!(Hm&4194240)&&(Hm=64),e}function ux(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function pf(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-$a(t),e[t]=n}function eU(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-$a(n),s=1<<a;t[a]=0,r[a]=-1,e[a]=-1,n&=~s}}function C1(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-$a(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}var mt=0;function s$(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var i$,T1,o$,l$,u$,w0=!1,qm=[],bi=null,vi=null,xi=null,$h=new Map,Ah=new Map,li=[],tU="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function uC(e,t){switch(e){case"focusin":case"focusout":bi=null;break;case"dragenter":case"dragleave":vi=null;break;case"mouseover":case"mouseout":xi=null;break;case"pointerover":case"pointerout":$h.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ah.delete(t.pointerId)}}function Wp(e,t,n,r,a,s){return e===null||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[a]},t!==null&&(t=ff(t),t!==null&&T1(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,a!==null&&t.indexOf(a)===-1&&t.push(a),e)}function nU(e,t,n,r,a){switch(t){case"focusin":return bi=Wp(bi,e,t,n,r,a),!0;case"dragenter":return vi=Wp(vi,e,t,n,r,a),!0;case"mouseover":return xi=Wp(xi,e,t,n,r,a),!0;case"pointerover":var s=a.pointerId;return $h.set(s,Wp($h.get(s)||null,e,t,n,r,a)),!0;case"gotpointercapture":return s=a.pointerId,Ah.set(s,Wp(Ah.get(s)||null,e,t,n,r,a)),!0}return!1}function d$(e){var t=Ao(e.target);if(t!==null){var n=bl(t);if(n!==null){if(t=n.tag,t===13){if(t=Z_(n),t!==null){e.blockedOn=t,u$(e.priority,function(){o$(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Ng(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=k0(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var r=new n.constructor(n.type,n);g0=r,n.target.dispatchEvent(r),g0=null}else return t=ff(n),t!==null&&T1(t),e.blockedOn=n,!1;t.shift()}return!0}function dC(e,t,n){Ng(e)&&n.delete(t)}function rU(){w0=!1,bi!==null&&Ng(bi)&&(bi=null),vi!==null&&Ng(vi)&&(vi=null),xi!==null&&Ng(xi)&&(xi=null),$h.forEach(dC),Ah.forEach(dC)}function Up(e,t){e.blockedOn===t&&(e.blockedOn=null,w0||(w0=!0,Yr.unstable_scheduleCallback(Yr.unstable_NormalPriority,rU)))}function Rh(e){function t(a){return Up(a,e)}if(0<qm.length){Up(qm[0],e);for(var n=1;n<qm.length;n++){var r=qm[n];r.blockedOn===e&&(r.blockedOn=null)}}for(bi!==null&&Up(bi,e),vi!==null&&Up(vi,e),xi!==null&&Up(xi,e),$h.forEach(t),Ah.forEach(t),n=0;n<li.length;n++)r=li[n],r.blockedOn===e&&(r.blockedOn=null);for(;0<li.length&&(n=li[0],n.blockedOn===null);)d$(n),n.blockedOn===null&&li.shift()}var Sd=Bs.ReactCurrentBatchConfig,Zg=!0;function aU(e,t,n,r){var a=mt,s=Sd.transition;Sd.transition=null;try{mt=1,E1(e,t,n,r)}finally{mt=a,Sd.transition=s}}function sU(e,t,n,r){var a=mt,s=Sd.transition;Sd.transition=null;try{mt=4,E1(e,t,n,r)}finally{mt=a,Sd.transition=s}}function E1(e,t,n,r){if(Zg){var a=k0(e,t,n,r);if(a===null)vx(e,t,r,Yg,n),uC(e,r);else if(nU(a,e,t,n,r))r.stopPropagation();else if(uC(e,r),t&4&&-1<tU.indexOf(e)){for(;a!==null;){var s=ff(a);if(s!==null&&i$(s),s=k0(e,t,n,r),s===null&&vx(e,t,r,Yg,n),s===a)break;a=s}a!==null&&r.stopPropagation()}else vx(e,t,r,null,n)}}var Yg=null;function k0(e,t,n,r){if(Yg=null,e=I1(r),e=Ao(e),e!==null)if(t=bl(e),t===null)e=null;else if(n=t.tag,n===13){if(e=Z_(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Yg=e,null}function c$(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(GW()){case N1:return 1;case n$:return 4;case Qg:case qW:return 16;case r$:return 536870912;default:return 16}default:return 16}}var ci=null,_1=null,Cg=null;function p$(){if(Cg)return Cg;var e,t=_1,n=t.length,r,a="value"in ci?ci.value:ci.textContent,s=a.length;for(e=0;e<n&&t[e]===a[e];e++);var i=n-e;for(r=1;r<=i&&t[n-r]===a[s-r];r++);return Cg=a.slice(e,1<r?1-r:void 0)}function Tg(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function Km(){return!0}function cC(){return!1}function aa(e){function t(n,r,a,s,i){this._reactName=n,this._targetInst=a,this.type=r,this.nativeEvent=s,this.target=i,this.currentTarget=null;for(var o in e)e.hasOwnProperty(o)&&(n=e[o],this[o]=n?n(s):s[o]);return this.isDefaultPrevented=(s.defaultPrevented!=null?s.defaultPrevented:s.returnValue===!1)?Km:cC,this.isPropagationStopped=cC,this}return Bt(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=Km)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=Km)},persist:function(){},isPersistent:Km}),t}var ac={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},$1=aa(ac),hf=Bt({},ac,{view:0,detail:0}),iU=aa(hf),dx,cx,Vp,eb=Bt({},hf,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:A1,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Vp&&(Vp&&e.type==="mousemove"?(dx=e.screenX-Vp.screenX,cx=e.screenY-Vp.screenY):cx=dx=0,Vp=e),dx)},movementY:function(e){return"movementY"in e?e.movementY:cx}}),pC=aa(eb),oU=Bt({},eb,{dataTransfer:0}),lU=aa(oU),uU=Bt({},hf,{relatedTarget:0}),px=aa(uU),dU=Bt({},ac,{animationName:0,elapsedTime:0,pseudoElement:0}),cU=aa(dU),pU=Bt({},ac,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),hU=aa(pU),fU=Bt({},ac,{data:0}),hC=aa(fU),mU={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},gU={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},yU={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function bU(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=yU[e])?!!t[e]:!1}function A1(){return bU}var vU=Bt({},hf,{key:function(e){if(e.key){var t=mU[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=Tg(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?gU[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:A1,charCode:function(e){return e.type==="keypress"?Tg(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?Tg(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),xU=aa(vU),wU=Bt({},eb,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),fC=aa(wU),kU=Bt({},hf,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:A1}),SU=aa(kU),IU=Bt({},ac,{propertyName:0,elapsedTime:0,pseudoElement:0}),NU=aa(IU),CU=Bt({},eb,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),TU=aa(CU),EU=[9,13,27,32],R1=Ds&&"CompositionEvent"in window,mh=null;Ds&&"documentMode"in document&&(mh=document.documentMode);var _U=Ds&&"TextEvent"in window&&!mh,h$=Ds&&(!R1||mh&&8<mh&&11>=mh),mC=" ",gC=!1;function f$(e,t){switch(e){case"keyup":return EU.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function m$(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var ld=!1;function $U(e,t){switch(e){case"compositionend":return m$(t);case"keypress":return t.which!==32?null:(gC=!0,mC);case"textInput":return e=t.data,e===mC&&gC?null:e;default:return null}}function AU(e,t){if(ld)return e==="compositionend"||!R1&&f$(e,t)?(e=p$(),Cg=_1=ci=null,ld=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return h$&&t.locale!=="ko"?null:t.data;default:return null}}var RU={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function yC(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!RU[e.type]:t==="textarea"}function g$(e,t,n,r){q_(r),t=ey(t,"onChange"),0<t.length&&(n=new $1("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var gh=null,Fh=null;function FU(e){T$(e,0)}function tb(e){var t=cd(e);if(B_(t))return e}function DU(e,t){if(e==="change")return t}var y$=!1;if(Ds){var hx;if(Ds){var fx="oninput"in document;if(!fx){var bC=document.createElement("div");bC.setAttribute("oninput","return;"),fx=typeof bC.oninput=="function"}hx=fx}else hx=!1;y$=hx&&(!document.documentMode||9<document.documentMode)}function vC(){gh&&(gh.detachEvent("onpropertychange",b$),Fh=gh=null)}function b$(e){if(e.propertyName==="value"&&tb(Fh)){var t=[];g$(t,Fh,e,I1(e)),J_(FU,t)}}function MU(e,t,n){e==="focusin"?(vC(),gh=t,Fh=n,gh.attachEvent("onpropertychange",b$)):e==="focusout"&&vC()}function OU(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return tb(Fh)}function PU(e,t){if(e==="click")return tb(t)}function LU(e,t){if(e==="input"||e==="change")return tb(t)}function zU(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Ma=typeof Object.is=="function"?Object.is:zU;function Dh(e,t){if(Ma(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!a0.call(t,a)||!Ma(e[a],t[a]))return!1}return!0}function xC(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function wC(e,t){var n=xC(e);e=0;for(var r;n;){if(n.nodeType===3){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=xC(n)}}function v$(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?v$(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function x$(){for(var e=window,t=qg();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=qg(e.document)}return t}function F1(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function BU(e){var t=x$(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&v$(n.ownerDocument.documentElement,n)){if(r!==null&&F1(n)){if(t=r.start,e=r.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var a=n.textContent.length,s=Math.min(r.start,a);r=r.end===void 0?s:Math.min(r.end,a),!e.extend&&s>r&&(a=r,r=s,s=a),a=wC(n,s);var i=wC(n,r);a&&i&&(e.rangeCount!==1||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&(t=t.createRange(),t.setStart(a.node,a.offset),e.removeAllRanges(),s>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var WU=Ds&&"documentMode"in document&&11>=document.documentMode,ud=null,S0=null,yh=null,I0=!1;function kC(e,t,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;I0||ud==null||ud!==qg(r)||(r=ud,"selectionStart"in r&&F1(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),yh&&Dh(yh,r)||(yh=r,r=ey(S0,"onSelect"),0<r.length&&(t=new $1("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=ud)))}function Xm(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var dd={animationend:Xm("Animation","AnimationEnd"),animationiteration:Xm("Animation","AnimationIteration"),animationstart:Xm("Animation","AnimationStart"),transitionend:Xm("Transition","TransitionEnd")},mx={},w$={};Ds&&(w$=document.createElement("div").style,"AnimationEvent"in window||(delete dd.animationend.animation,delete dd.animationiteration.animation,delete dd.animationstart.animation),"TransitionEvent"in window||delete dd.transitionend.transition);function nb(e){if(mx[e])return mx[e];if(!dd[e])return e;var t=dd[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in w$)return mx[e]=t[n];return e}var k$=nb("animationend"),S$=nb("animationiteration"),I$=nb("animationstart"),N$=nb("transitionend"),C$=new Map,SC="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function qi(e,t){C$.set(e,t),yl(t,[e])}for(var gx=0;gx<SC.length;gx++){var yx=SC[gx],UU=yx.toLowerCase(),VU=yx[0].toUpperCase()+yx.slice(1);qi(UU,"on"+VU)}qi(k$,"onAnimationEnd");qi(S$,"onAnimationIteration");qi(I$,"onAnimationStart");qi("dblclick","onDoubleClick");qi("focusin","onFocus");qi("focusout","onBlur");qi(N$,"onTransitionEnd");Ad("onMouseEnter",["mouseout","mouseover"]);Ad("onMouseLeave",["mouseout","mouseover"]);Ad("onPointerEnter",["pointerout","pointerover"]);Ad("onPointerLeave",["pointerout","pointerover"]);yl("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));yl("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));yl("onBeforeInput",["compositionend","keypress","textInput","paste"]);yl("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));yl("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));yl("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var nh="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),jU=new Set("cancel close invalid load scroll toggle".split(" ").concat(nh));function IC(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,UW(r,t,void 0,e),e.currentTarget=null}function T$(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var s=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,d=o.currentTarget;if(o=o.listener,l!==s&&a.isPropagationStopped())break e;IC(a,o,d),s=l}else for(i=0;i<r.length;i++){if(o=r[i],l=o.instance,d=o.currentTarget,o=o.listener,l!==s&&a.isPropagationStopped())break e;IC(a,o,d),s=l}}}if(Xg)throw e=v0,Xg=!1,v0=null,e}function Tt(e,t){var n=t[_0];n===void 0&&(n=t[_0]=new Set);var r=e+"__bubble";n.has(r)||(E$(t,e,2,!1),n.add(r))}function bx(e,t,n){var r=0;t&&(r|=4),E$(n,e,r,t)}var Qm="_reactListening"+Math.random().toString(36).slice(2);function Mh(e){if(!e[Qm]){e[Qm]=!0,M_.forEach(function(n){n!=="selectionchange"&&(jU.has(n)||bx(n,!1,e),bx(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[Qm]||(t[Qm]=!0,bx("selectionchange",!1,t))}}function E$(e,t,n,r){switch(c$(t)){case 1:var a=aU;break;case 4:a=sU;break;default:a=E1}n=a.bind(null,t,n,e),a=void 0,!b0||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(a=!0),r?a!==void 0?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):a!==void 0?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function vx(e,t,n,r,a){var s=r;if(!(t&1)&&!(t&2)&&r!==null)e:for(;;){if(r===null)return;var i=r.tag;if(i===3||i===4){var o=r.stateNode.containerInfo;if(o===a||o.nodeType===8&&o.parentNode===a)break;if(i===4)for(i=r.return;i!==null;){var l=i.tag;if((l===3||l===4)&&(l=i.stateNode.containerInfo,l===a||l.nodeType===8&&l.parentNode===a))return;i=i.return}for(;o!==null;){if(i=Ao(o),i===null)return;if(l=i.tag,l===5||l===6){r=s=i;continue e}o=o.parentNode}}r=r.return}J_(function(){var d=s,u=I1(n),c=[];e:{var p=C$.get(e);if(p!==void 0){var h=$1,f=e;switch(e){case"keypress":if(Tg(n)===0)break e;case"keydown":case"keyup":h=xU;break;case"focusin":f="focus",h=px;break;case"focusout":f="blur",h=px;break;case"beforeblur":case"afterblur":h=px;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":h=pC;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":h=lU;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":h=SU;break;case k$:case S$:case I$:h=cU;break;case N$:h=NU;break;case"scroll":h=iU;break;case"wheel":h=TU;break;case"copy":case"cut":case"paste":h=hU;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":h=fC}var m=(t&4)!==0,g=!m&&e==="scroll",y=m?p!==null?p+"Capture":null:p;m=[];for(var b=d,v;b!==null;){v=b;var x=v.stateNode;if(v.tag===5&&x!==null&&(v=x,y!==null&&(x=_h(b,y),x!=null&&m.push(Oh(b,x,v)))),g)break;b=b.return}0<m.length&&(p=new h(p,f,null,n,u),c.push({event:p,listeners:m}))}}if(!(t&7)){e:{if(p=e==="mouseover"||e==="pointerover",h=e==="mouseout"||e==="pointerout",p&&n!==g0&&(f=n.relatedTarget||n.fromElement)&&(Ao(f)||f[Ms]))break e;if((h||p)&&(p=u.window===u?u:(p=u.ownerDocument)?p.defaultView||p.parentWindow:window,h?(f=n.relatedTarget||n.toElement,h=d,f=f?Ao(f):null,f!==null&&(g=bl(f),f!==g||f.tag!==5&&f.tag!==6)&&(f=null)):(h=null,f=d),h!==f)){if(m=pC,x="onMouseLeave",y="onMouseEnter",b="mouse",(e==="pointerout"||e==="pointerover")&&(m=fC,x="onPointerLeave",y="onPointerEnter",b="pointer"),g=h==null?p:cd(h),v=f==null?p:cd(f),p=new m(x,b+"leave",h,n,u),p.target=g,p.relatedTarget=v,x=null,Ao(u)===d&&(m=new m(y,b+"enter",f,n,u),m.target=v,m.relatedTarget=g,x=m),g=x,h&&f)t:{for(m=h,y=f,b=0,v=m;v;v=Yu(v))b++;for(v=0,x=y;x;x=Yu(x))v++;for(;0<b-v;)m=Yu(m),b--;for(;0<v-b;)y=Yu(y),v--;for(;b--;){if(m===y||y!==null&&m===y.alternate)break t;m=Yu(m),y=Yu(y)}m=null}else m=null;h!==null&&NC(c,p,h,m,!1),f!==null&&g!==null&&NC(c,g,f,m,!0)}}e:{if(p=d?cd(d):window,h=p.nodeName&&p.nodeName.toLowerCase(),h==="select"||h==="input"&&p.type==="file")var w=DU;else if(yC(p))if(y$)w=LU;else{w=OU;var I=MU}else(h=p.nodeName)&&h.toLowerCase()==="input"&&(p.type==="checkbox"||p.type==="radio")&&(w=PU);if(w&&(w=w(e,d))){g$(c,w,n,u);break e}I&&I(e,p,d),e==="focusout"&&(I=p._wrapperState)&&I.controlled&&p.type==="number"&&c0(p,"number",p.value)}switch(I=d?cd(d):window,e){case"focusin":(yC(I)||I.contentEditable==="true")&&(ud=I,S0=d,yh=null);break;case"focusout":yh=S0=ud=null;break;case"mousedown":I0=!0;break;case"contextmenu":case"mouseup":case"dragend":I0=!1,kC(c,n,u);break;case"selectionchange":if(WU)break;case"keydown":case"keyup":kC(c,n,u)}var N;if(R1)e:{switch(e){case"compositionstart":var T="onCompositionStart";break e;case"compositionend":T="onCompositionEnd";break e;case"compositionupdate":T="onCompositionUpdate";break e}T=void 0}else ld?f$(e,n)&&(T="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(T="onCompositionStart");T&&(h$&&n.locale!=="ko"&&(ld||T!=="onCompositionStart"?T==="onCompositionEnd"&&ld&&(N=p$()):(ci=u,_1="value"in ci?ci.value:ci.textContent,ld=!0)),I=ey(d,T),0<I.length&&(T=new hC(T,e,null,n,u),c.push({event:T,listeners:I}),N?T.data=N:(N=m$(n),N!==null&&(T.data=N)))),(N=_U?$U(e,n):AU(e,n))&&(d=ey(d,"onBeforeInput"),0<d.length&&(u=new hC("onBeforeInput","beforeinput",null,n,u),c.push({event:u,listeners:d}),u.data=N))}T$(c,t)})}function Oh(e,t,n){return{instance:e,listener:t,currentTarget:n}}function ey(e,t){for(var n=t+"Capture",r=[];e!==null;){var a=e,s=a.stateNode;a.tag===5&&s!==null&&(a=s,s=_h(e,n),s!=null&&r.unshift(Oh(e,s,a)),s=_h(e,t),s!=null&&r.push(Oh(e,s,a))),e=e.return}return r}function Yu(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function NC(e,t,n,r,a){for(var s=t._reactName,i=[];n!==null&&n!==r;){var o=n,l=o.alternate,d=o.stateNode;if(l!==null&&l===r)break;o.tag===5&&d!==null&&(o=d,a?(l=_h(n,s),l!=null&&i.unshift(Oh(n,l,o))):a||(l=_h(n,s),l!=null&&i.push(Oh(n,l,o)))),n=n.return}i.length!==0&&e.push({event:t,listeners:i})}var HU=/\r\n?/g,GU=/\u0000|\uFFFD/g;function CC(e){return(typeof e=="string"?e:""+e).replace(HU,`
`).replace(GU,"")}function Jm(e,t,n){if(t=CC(t),CC(e)!==t&&n)throw Error(de(425))}function ty(){}var N0=null,C0=null;function T0(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var E0=typeof setTimeout=="function"?setTimeout:void 0,qU=typeof clearTimeout=="function"?clearTimeout:void 0,TC=typeof Promise=="function"?Promise:void 0,KU=typeof queueMicrotask=="function"?queueMicrotask:typeof TC<"u"?function(e){return TC.resolve(null).then(e).catch(XU)}:E0;function XU(e){setTimeout(function(){throw e})}function xx(e,t){var n=t,r=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&a.nodeType===8)if(n=a.data,n==="/$"){if(r===0){e.removeChild(a),Rh(t);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=a}while(n);Rh(t)}function wi(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function EC(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var sc=Math.random().toString(36).slice(2),ts="__reactFiber$"+sc,Ph="__reactProps$"+sc,Ms="__reactContainer$"+sc,_0="__reactEvents$"+sc,QU="__reactListeners$"+sc,JU="__reactHandles$"+sc;function Ao(e){var t=e[ts];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Ms]||n[ts]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=EC(e);e!==null;){if(n=e[ts])return n;e=EC(e)}return t}e=n,n=e.parentNode}return null}function ff(e){return e=e[ts]||e[Ms],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function cd(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(de(33))}function rb(e){return e[Ph]||null}var $0=[],pd=-1;function Ki(e){return{current:e}}function Et(e){0>pd||(e.current=$0[pd],$0[pd]=null,pd--)}function Nt(e,t){pd++,$0[pd]=e.current,e.current=t}var Ai={},Qn=Ki(Ai),_r=Ki(!1),jo=Ai;function Rd(e,t){var n=e.type.contextTypes;if(!n)return Ai;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var a={},s;for(s in n)a[s]=t[s];return r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function $r(e){return e=e.childContextTypes,e!=null}function ny(){Et(_r),Et(Qn)}function _C(e,t,n){if(Qn.current!==Ai)throw Error(de(168));Nt(Qn,t),Nt(_r,n)}function _$(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var a in r)if(!(a in t))throw Error(de(108,MW(e)||"Unknown",a));return Bt({},n,r)}function ry(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Ai,jo=Qn.current,Nt(Qn,e),Nt(_r,_r.current),!0}function $C(e,t,n){var r=e.stateNode;if(!r)throw Error(de(169));n?(e=_$(e,t,jo),r.__reactInternalMemoizedMergedChildContext=e,Et(_r),Et(Qn),Nt(Qn,e)):Et(_r),Nt(_r,n)}var Ss=null,ab=!1,wx=!1;function $$(e){Ss===null?Ss=[e]:Ss.push(e)}function ZU(e){ab=!0,$$(e)}function Xi(){if(!wx&&Ss!==null){wx=!0;var e=0,t=mt;try{var n=Ss;for(mt=1;e<n.length;e++){var r=n[e];do r=r(!0);while(r!==null)}Ss=null,ab=!1}catch(a){throw Ss!==null&&(Ss=Ss.slice(e+1)),t$(N1,Xi),a}finally{mt=t,wx=!1}}return null}var hd=[],fd=0,ay=null,sy=0,ca=[],pa=0,Ho=null,Es=1,_s="";function xo(e,t){hd[fd++]=sy,hd[fd++]=ay,ay=e,sy=t}function A$(e,t,n){ca[pa++]=Es,ca[pa++]=_s,ca[pa++]=Ho,Ho=e;var r=Es;e=_s;var a=32-$a(r)-1;r&=~(1<<a),n+=1;var s=32-$a(t)+a;if(30<s){var i=a-a%5;s=(r&(1<<i)-1).toString(32),r>>=i,a-=i,Es=1<<32-$a(t)+a|n<<a|r,_s=s+e}else Es=1<<s|n<<a|r,_s=e}function D1(e){e.return!==null&&(xo(e,1),A$(e,1,0))}function M1(e){for(;e===ay;)ay=hd[--fd],hd[fd]=null,sy=hd[--fd],hd[fd]=null;for(;e===Ho;)Ho=ca[--pa],ca[pa]=null,_s=ca[--pa],ca[pa]=null,Es=ca[--pa],ca[pa]=null}var Jr=null,Gr=null,Rt=!1,Ea=null;function R$(e,t){var n=ha(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function AC(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,Jr=e,Gr=wi(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,Jr=e,Gr=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=Ho!==null?{id:Es,overflow:_s}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=ha(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,Jr=e,Gr=null,!0):!1;default:return!1}}function A0(e){return(e.mode&1)!==0&&(e.flags&128)===0}function R0(e){if(Rt){var t=Gr;if(t){var n=t;if(!AC(e,t)){if(A0(e))throw Error(de(418));t=wi(n.nextSibling);var r=Jr;t&&AC(e,t)?R$(r,n):(e.flags=e.flags&-4097|2,Rt=!1,Jr=e)}}else{if(A0(e))throw Error(de(418));e.flags=e.flags&-4097|2,Rt=!1,Jr=e}}}function RC(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;Jr=e}function Zm(e){if(e!==Jr)return!1;if(!Rt)return RC(e),Rt=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!T0(e.type,e.memoizedProps)),t&&(t=Gr)){if(A0(e))throw F$(),Error(de(418));for(;t;)R$(e,t),t=wi(t.nextSibling)}if(RC(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(de(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){Gr=wi(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}Gr=null}}else Gr=Jr?wi(e.stateNode.nextSibling):null;return!0}function F$(){for(var e=Gr;e;)e=wi(e.nextSibling)}function Fd(){Gr=Jr=null,Rt=!1}function O1(e){Ea===null?Ea=[e]:Ea.push(e)}var YU=Bs.ReactCurrentBatchConfig;function jp(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(de(309));var r=n.stateNode}if(!r)throw Error(de(147,e));var a=r,s=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===s?t.ref:(t=function(i){var o=a.refs;i===null?delete o[s]:o[s]=i},t._stringRef=s,t)}if(typeof e!="string")throw Error(de(284));if(!n._owner)throw Error(de(290,e))}return e}function Ym(e,t){throw e=Object.prototype.toString.call(t),Error(de(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function FC(e){var t=e._init;return t(e._payload)}function D$(e){function t(y,b){if(e){var v=y.deletions;v===null?(y.deletions=[b],y.flags|=16):v.push(b)}}function n(y,b){if(!e)return null;for(;b!==null;)t(y,b),b=b.sibling;return null}function r(y,b){for(y=new Map;b!==null;)b.key!==null?y.set(b.key,b):y.set(b.index,b),b=b.sibling;return y}function a(y,b){return y=Ni(y,b),y.index=0,y.sibling=null,y}function s(y,b,v){return y.index=v,e?(v=y.alternate,v!==null?(v=v.index,v<b?(y.flags|=2,b):v):(y.flags|=2,b)):(y.flags|=1048576,b)}function i(y){return e&&y.alternate===null&&(y.flags|=2),y}function o(y,b,v,x){return b===null||b.tag!==6?(b=Ex(v,y.mode,x),b.return=y,b):(b=a(b,v),b.return=y,b)}function l(y,b,v,x){var w=v.type;return w===od?u(y,b,v.props.children,x,v.key):b!==null&&(b.elementType===w||typeof w=="object"&&w!==null&&w.$$typeof===ai&&FC(w)===b.type)?(x=a(b,v.props),x.ref=jp(y,b,v),x.return=y,x):(x=Dg(v.type,v.key,v.props,null,y.mode,x),x.ref=jp(y,b,v),x.return=y,x)}function d(y,b,v,x){return b===null||b.tag!==4||b.stateNode.containerInfo!==v.containerInfo||b.stateNode.implementation!==v.implementation?(b=_x(v,y.mode,x),b.return=y,b):(b=a(b,v.children||[]),b.return=y,b)}function u(y,b,v,x,w){return b===null||b.tag!==7?(b=Lo(v,y.mode,x,w),b.return=y,b):(b=a(b,v),b.return=y,b)}function c(y,b,v){if(typeof b=="string"&&b!==""||typeof b=="number")return b=Ex(""+b,y.mode,v),b.return=y,b;if(typeof b=="object"&&b!==null){switch(b.$$typeof){case Um:return v=Dg(b.type,b.key,b.props,null,y.mode,v),v.ref=jp(y,null,b),v.return=y,v;case id:return b=_x(b,y.mode,v),b.return=y,b;case ai:var x=b._init;return c(y,x(b._payload),v)}if(eh(b)||zp(b))return b=Lo(b,y.mode,v,null),b.return=y,b;Ym(y,b)}return null}function p(y,b,v,x){var w=b!==null?b.key:null;if(typeof v=="string"&&v!==""||typeof v=="number")return w!==null?null:o(y,b,""+v,x);if(typeof v=="object"&&v!==null){switch(v.$$typeof){case Um:return v.key===w?l(y,b,v,x):null;case id:return v.key===w?d(y,b,v,x):null;case ai:return w=v._init,p(y,b,w(v._payload),x)}if(eh(v)||zp(v))return w!==null?null:u(y,b,v,x,null);Ym(y,v)}return null}function h(y,b,v,x,w){if(typeof x=="string"&&x!==""||typeof x=="number")return y=y.get(v)||null,o(b,y,""+x,w);if(typeof x=="object"&&x!==null){switch(x.$$typeof){case Um:return y=y.get(x.key===null?v:x.key)||null,l(b,y,x,w);case id:return y=y.get(x.key===null?v:x.key)||null,d(b,y,x,w);case ai:var I=x._init;return h(y,b,v,I(x._payload),w)}if(eh(x)||zp(x))return y=y.get(v)||null,u(b,y,x,w,null);Ym(b,x)}return null}function f(y,b,v,x){for(var w=null,I=null,N=b,T=b=0,A=null;N!==null&&T<v.length;T++){N.index>T?(A=N,N=null):A=N.sibling;var R=p(y,N,v[T],x);if(R===null){N===null&&(N=A);break}e&&N&&R.alternate===null&&t(y,N),b=s(R,b,T),I===null?w=R:I.sibling=R,I=R,N=A}if(T===v.length)return n(y,N),Rt&&xo(y,T),w;if(N===null){for(;T<v.length;T++)N=c(y,v[T],x),N!==null&&(b=s(N,b,T),I===null?w=N:I.sibling=N,I=N);return Rt&&xo(y,T),w}for(N=r(y,N);T<v.length;T++)A=h(N,y,T,v[T],x),A!==null&&(e&&A.alternate!==null&&N.delete(A.key===null?T:A.key),b=s(A,b,T),I===null?w=A:I.sibling=A,I=A);return e&&N.forEach(function(F){return t(y,F)}),Rt&&xo(y,T),w}function m(y,b,v,x){var w=zp(v);if(typeof w!="function")throw Error(de(150));if(v=w.call(v),v==null)throw Error(de(151));for(var I=w=null,N=b,T=b=0,A=null,R=v.next();N!==null&&!R.done;T++,R=v.next()){N.index>T?(A=N,N=null):A=N.sibling;var F=p(y,N,R.value,x);if(F===null){N===null&&(N=A);break}e&&N&&F.alternate===null&&t(y,N),b=s(F,b,T),I===null?w=F:I.sibling=F,I=F,N=A}if(R.done)return n(y,N),Rt&&xo(y,T),w;if(N===null){for(;!R.done;T++,R=v.next())R=c(y,R.value,x),R!==null&&(b=s(R,b,T),I===null?w=R:I.sibling=R,I=R);return Rt&&xo(y,T),w}for(N=r(y,N);!R.done;T++,R=v.next())R=h(N,y,T,R.value,x),R!==null&&(e&&R.alternate!==null&&N.delete(R.key===null?T:R.key),b=s(R,b,T),I===null?w=R:I.sibling=R,I=R);return e&&N.forEach(function(C){return t(y,C)}),Rt&&xo(y,T),w}function g(y,b,v,x){if(typeof v=="object"&&v!==null&&v.type===od&&v.key===null&&(v=v.props.children),typeof v=="object"&&v!==null){switch(v.$$typeof){case Um:e:{for(var w=v.key,I=b;I!==null;){if(I.key===w){if(w=v.type,w===od){if(I.tag===7){n(y,I.sibling),b=a(I,v.props.children),b.return=y,y=b;break e}}else if(I.elementType===w||typeof w=="object"&&w!==null&&w.$$typeof===ai&&FC(w)===I.type){n(y,I.sibling),b=a(I,v.props),b.ref=jp(y,I,v),b.return=y,y=b;break e}n(y,I);break}else t(y,I);I=I.sibling}v.type===od?(b=Lo(v.props.children,y.mode,x,v.key),b.return=y,y=b):(x=Dg(v.type,v.key,v.props,null,y.mode,x),x.ref=jp(y,b,v),x.return=y,y=x)}return i(y);case id:e:{for(I=v.key;b!==null;){if(b.key===I)if(b.tag===4&&b.stateNode.containerInfo===v.containerInfo&&b.stateNode.implementation===v.implementation){n(y,b.sibling),b=a(b,v.children||[]),b.return=y,y=b;break e}else{n(y,b);break}else t(y,b);b=b.sibling}b=_x(v,y.mode,x),b.return=y,y=b}return i(y);case ai:return I=v._init,g(y,b,I(v._payload),x)}if(eh(v))return f(y,b,v,x);if(zp(v))return m(y,b,v,x);Ym(y,v)}return typeof v=="string"&&v!==""||typeof v=="number"?(v=""+v,b!==null&&b.tag===6?(n(y,b.sibling),b=a(b,v),b.return=y,y=b):(n(y,b),b=Ex(v,y.mode,x),b.return=y,y=b),i(y)):n(y,b)}return g}var Dd=D$(!0),M$=D$(!1),iy=Ki(null),oy=null,md=null,P1=null;function L1(){P1=md=oy=null}function z1(e){var t=iy.current;Et(iy),e._currentValue=t}function F0(e,t,n){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,r!==null&&(r.childLanes|=t)):r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Id(e,t){oy=e,P1=md=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(Tr=!0),e.firstContext=null)}function ga(e){var t=e._currentValue;if(P1!==e)if(e={context:e,memoizedValue:t,next:null},md===null){if(oy===null)throw Error(de(308));md=e,oy.dependencies={lanes:0,firstContext:e}}else md=md.next=e;return t}var Ro=null;function B1(e){Ro===null?Ro=[e]:Ro.push(e)}function O$(e,t,n,r){var a=t.interleaved;return a===null?(n.next=n,B1(t)):(n.next=a.next,a.next=n),t.interleaved=n,Os(e,r)}function Os(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var si=!1;function W1(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function P$(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function $s(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function ki(e,t,n){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,st&2){var a=r.pending;return a===null?t.next=t:(t.next=a.next,a.next=t),r.pending=t,Os(e,n)}return a=r.interleaved,a===null?(t.next=t,B1(r)):(t.next=a.next,a.next=t),r.interleaved=t,Os(e,n)}function Eg(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,C1(e,n)}}function DC(e,t){var n=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var a=null,s=null;if(n=n.firstBaseUpdate,n!==null){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};s===null?a=s=i:s=s.next=i,n=n.next}while(n!==null);s===null?a=s=t:s=s.next=t}else a=s=t;n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:s,shared:r.shared,effects:r.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function ly(e,t,n,r){var a=e.updateQueue;si=!1;var s=a.firstBaseUpdate,i=a.lastBaseUpdate,o=a.shared.pending;if(o!==null){a.shared.pending=null;var l=o,d=l.next;l.next=null,i===null?s=d:i.next=d,i=l;var u=e.alternate;u!==null&&(u=u.updateQueue,o=u.lastBaseUpdate,o!==i&&(o===null?u.firstBaseUpdate=d:o.next=d,u.lastBaseUpdate=l))}if(s!==null){var c=a.baseState;i=0,u=d=l=null,o=s;do{var p=o.lane,h=o.eventTime;if((r&p)===p){u!==null&&(u=u.next={eventTime:h,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(p=t,h=n,m.tag){case 1:if(f=m.payload,typeof f=="function"){c=f.call(h,c,p);break e}c=f;break e;case 3:f.flags=f.flags&-65537|128;case 0:if(f=m.payload,p=typeof f=="function"?f.call(h,c,p):f,p==null)break e;c=Bt({},c,p);break e;case 2:si=!0}}o.callback!==null&&o.lane!==0&&(e.flags|=64,p=a.effects,p===null?a.effects=[o]:p.push(o))}else h={eventTime:h,lane:p,tag:o.tag,payload:o.payload,callback:o.callback,next:null},u===null?(d=u=h,l=c):u=u.next=h,i|=p;if(o=o.next,o===null){if(o=a.shared.pending,o===null)break;p=o,o=p.next,p.next=null,a.lastBaseUpdate=p,a.shared.pending=null}}while(!0);if(u===null&&(l=c),a.baseState=l,a.firstBaseUpdate=d,a.lastBaseUpdate=u,t=a.shared.interleaved,t!==null){a=t;do i|=a.lane,a=a.next;while(a!==t)}else s===null&&(a.shared.lanes=0);qo|=i,e.lanes=i,e.memoizedState=c}}function MC(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var r=e[t],a=r.callback;if(a!==null){if(r.callback=null,r=n,typeof a!="function")throw Error(de(191,a));a.call(r)}}}var mf={},ss=Ki(mf),Lh=Ki(mf),zh=Ki(mf);function Fo(e){if(e===mf)throw Error(de(174));return e}function U1(e,t){switch(Nt(zh,t),Nt(Lh,e),Nt(ss,mf),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:h0(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=h0(t,e)}Et(ss),Nt(ss,t)}function Md(){Et(ss),Et(Lh),Et(zh)}function L$(e){Fo(zh.current);var t=Fo(ss.current),n=h0(t,e.type);t!==n&&(Nt(Lh,e),Nt(ss,n))}function V1(e){Lh.current===e&&(Et(ss),Et(Lh))}var Lt=Ki(0);function uy(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var kx=[];function j1(){for(var e=0;e<kx.length;e++)kx[e]._workInProgressVersionPrimary=null;kx.length=0}var _g=Bs.ReactCurrentDispatcher,Sx=Bs.ReactCurrentBatchConfig,Go=0,zt=null,fn=null,Tn=null,dy=!1,bh=!1,Bh=0,eV=0;function Wn(){throw Error(de(321))}function H1(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Ma(e[n],t[n]))return!1;return!0}function G1(e,t,n,r,a,s){if(Go=s,zt=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,_g.current=e===null||e.memoizedState===null?aV:sV,e=n(r,a),bh){s=0;do{if(bh=!1,Bh=0,25<=s)throw Error(de(301));s+=1,Tn=fn=null,t.updateQueue=null,_g.current=iV,e=n(r,a)}while(bh)}if(_g.current=cy,t=fn!==null&&fn.next!==null,Go=0,Tn=fn=zt=null,dy=!1,t)throw Error(de(300));return e}function q1(){var e=Bh!==0;return Bh=0,e}function Qa(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Tn===null?zt.memoizedState=Tn=e:Tn=Tn.next=e,Tn}function ya(){if(fn===null){var e=zt.alternate;e=e!==null?e.memoizedState:null}else e=fn.next;var t=Tn===null?zt.memoizedState:Tn.next;if(t!==null)Tn=t,fn=e;else{if(e===null)throw Error(de(310));fn=e,e={memoizedState:fn.memoizedState,baseState:fn.baseState,baseQueue:fn.baseQueue,queue:fn.queue,next:null},Tn===null?zt.memoizedState=Tn=e:Tn=Tn.next=e}return Tn}function Wh(e,t){return typeof t=="function"?t(e):t}function Ix(e){var t=ya(),n=t.queue;if(n===null)throw Error(de(311));n.lastRenderedReducer=e;var r=fn,a=r.baseQueue,s=n.pending;if(s!==null){if(a!==null){var i=a.next;a.next=s.next,s.next=i}r.baseQueue=a=s,n.pending=null}if(a!==null){s=a.next,r=r.baseState;var o=i=null,l=null,d=s;do{var u=d.lane;if((Go&u)===u)l!==null&&(l=l.next={lane:0,action:d.action,hasEagerState:d.hasEagerState,eagerState:d.eagerState,next:null}),r=d.hasEagerState?d.eagerState:e(r,d.action);else{var c={lane:u,action:d.action,hasEagerState:d.hasEagerState,eagerState:d.eagerState,next:null};l===null?(o=l=c,i=r):l=l.next=c,zt.lanes|=u,qo|=u}d=d.next}while(d!==null&&d!==s);l===null?i=r:l.next=o,Ma(r,t.memoizedState)||(Tr=!0),t.memoizedState=r,t.baseState=i,t.baseQueue=l,n.lastRenderedState=r}if(e=n.interleaved,e!==null){a=e;do s=a.lane,zt.lanes|=s,qo|=s,a=a.next;while(a!==e)}else a===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function Nx(e){var t=ya(),n=t.queue;if(n===null)throw Error(de(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,s=t.memoizedState;if(a!==null){n.pending=null;var i=a=a.next;do s=e(s,i.action),i=i.next;while(i!==a);Ma(s,t.memoizedState)||(Tr=!0),t.memoizedState=s,t.baseQueue===null&&(t.baseState=s),n.lastRenderedState=s}return[s,r]}function z$(){}function B$(e,t){var n=zt,r=ya(),a=t(),s=!Ma(r.memoizedState,a);if(s&&(r.memoizedState=a,Tr=!0),r=r.queue,K1(V$.bind(null,n,r,e),[e]),r.getSnapshot!==t||s||Tn!==null&&Tn.memoizedState.tag&1){if(n.flags|=2048,Uh(9,U$.bind(null,n,r,a,t),void 0,null),An===null)throw Error(de(349));Go&30||W$(n,t,a)}return a}function W$(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=zt.updateQueue,t===null?(t={lastEffect:null,stores:null},zt.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function U$(e,t,n,r){t.value=n,t.getSnapshot=r,j$(t)&&H$(e)}function V$(e,t,n){return n(function(){j$(t)&&H$(e)})}function j$(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Ma(e,n)}catch{return!0}}function H$(e){var t=Os(e,1);t!==null&&Aa(t,e,1,-1)}function OC(e){var t=Qa();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Wh,lastRenderedState:e},t.queue=e,e=e.dispatch=rV.bind(null,zt,e),[t.memoizedState,e]}function Uh(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},t=zt.updateQueue,t===null?(t={lastEffect:null,stores:null},zt.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e)),e}function G$(){return ya().memoizedState}function $g(e,t,n,r){var a=Qa();zt.flags|=e,a.memoizedState=Uh(1|t,n,void 0,r===void 0?null:r)}function sb(e,t,n,r){var a=ya();r=r===void 0?null:r;var s=void 0;if(fn!==null){var i=fn.memoizedState;if(s=i.destroy,r!==null&&H1(r,i.deps)){a.memoizedState=Uh(t,n,s,r);return}}zt.flags|=e,a.memoizedState=Uh(1|t,n,s,r)}function PC(e,t){return $g(8390656,8,e,t)}function K1(e,t){return sb(2048,8,e,t)}function q$(e,t){return sb(4,2,e,t)}function K$(e,t){return sb(4,4,e,t)}function X$(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function Q$(e,t,n){return n=n!=null?n.concat([e]):null,sb(4,4,X$.bind(null,t,e),n)}function X1(){}function J$(e,t){var n=ya();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&H1(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Z$(e,t){var n=ya();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&H1(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Y$(e,t,n){return Go&21?(Ma(n,t)||(n=a$(),zt.lanes|=n,qo|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,Tr=!0),e.memoizedState=n)}function tV(e,t){var n=mt;mt=n!==0&&4>n?n:4,e(!0);var r=Sx.transition;Sx.transition={};try{e(!1),t()}finally{mt=n,Sx.transition=r}}function eA(){return ya().memoizedState}function nV(e,t,n){var r=Ii(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},tA(e))nA(t,n);else if(n=O$(e,t,n,r),n!==null){var a=dr();Aa(n,e,r,a),rA(n,t,r)}}function rV(e,t,n){var r=Ii(e),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(tA(e))nA(t,a);else{var s=e.alternate;if(e.lanes===0&&(s===null||s.lanes===0)&&(s=t.lastRenderedReducer,s!==null))try{var i=t.lastRenderedState,o=s(i,n);if(a.hasEagerState=!0,a.eagerState=o,Ma(o,i)){var l=t.interleaved;l===null?(a.next=a,B1(t)):(a.next=l.next,l.next=a),t.interleaved=a;return}}catch{}finally{}n=O$(e,t,a,r),n!==null&&(a=dr(),Aa(n,e,r,a),rA(n,t,r))}}function tA(e){var t=e.alternate;return e===zt||t!==null&&t===zt}function nA(e,t){bh=dy=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function rA(e,t,n){if(n&4194240){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,C1(e,n)}}var cy={readContext:ga,useCallback:Wn,useContext:Wn,useEffect:Wn,useImperativeHandle:Wn,useInsertionEffect:Wn,useLayoutEffect:Wn,useMemo:Wn,useReducer:Wn,useRef:Wn,useState:Wn,useDebugValue:Wn,useDeferredValue:Wn,useTransition:Wn,useMutableSource:Wn,useSyncExternalStore:Wn,useId:Wn,unstable_isNewReconciler:!1},aV={readContext:ga,useCallback:function(e,t){return Qa().memoizedState=[e,t===void 0?null:t],e},useContext:ga,useEffect:PC,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,$g(4194308,4,X$.bind(null,t,e),n)},useLayoutEffect:function(e,t){return $g(4194308,4,e,t)},useInsertionEffect:function(e,t){return $g(4,2,e,t)},useMemo:function(e,t){var n=Qa();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=Qa();return t=n!==void 0?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=nV.bind(null,zt,e),[r.memoizedState,e]},useRef:function(e){var t=Qa();return e={current:e},t.memoizedState=e},useState:OC,useDebugValue:X1,useDeferredValue:function(e){return Qa().memoizedState=e},useTransition:function(){var e=OC(!1),t=e[0];return e=tV.bind(null,e[1]),Qa().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=zt,a=Qa();if(Rt){if(n===void 0)throw Error(de(407));n=n()}else{if(n=t(),An===null)throw Error(de(349));Go&30||W$(r,t,n)}a.memoizedState=n;var s={value:n,getSnapshot:t};return a.queue=s,PC(V$.bind(null,r,s,e),[e]),r.flags|=2048,Uh(9,U$.bind(null,r,s,n,t),void 0,null),n},useId:function(){var e=Qa(),t=An.identifierPrefix;if(Rt){var n=_s,r=Es;n=(r&~(1<<32-$a(r)-1)).toString(32)+n,t=":"+t+"R"+n,n=Bh++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=eV++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},sV={readContext:ga,useCallback:J$,useContext:ga,useEffect:K1,useImperativeHandle:Q$,useInsertionEffect:q$,useLayoutEffect:K$,useMemo:Z$,useReducer:Ix,useRef:G$,useState:function(){return Ix(Wh)},useDebugValue:X1,useDeferredValue:function(e){var t=ya();return Y$(t,fn.memoizedState,e)},useTransition:function(){var e=Ix(Wh)[0],t=ya().memoizedState;return[e,t]},useMutableSource:z$,useSyncExternalStore:B$,useId:eA,unstable_isNewReconciler:!1},iV={readContext:ga,useCallback:J$,useContext:ga,useEffect:K1,useImperativeHandle:Q$,useInsertionEffect:q$,useLayoutEffect:K$,useMemo:Z$,useReducer:Nx,useRef:G$,useState:function(){return Nx(Wh)},useDebugValue:X1,useDeferredValue:function(e){var t=ya();return fn===null?t.memoizedState=e:Y$(t,fn.memoizedState,e)},useTransition:function(){var e=Nx(Wh)[0],t=ya().memoizedState;return[e,t]},useMutableSource:z$,useSyncExternalStore:B$,useId:eA,unstable_isNewReconciler:!1};function Ca(e,t){if(e&&e.defaultProps){t=Bt({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}function D0(e,t,n,r){t=e.memoizedState,n=n(r,t),n=n==null?t:Bt({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var ib={isMounted:function(e){return(e=e._reactInternals)?bl(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=dr(),a=Ii(e),s=$s(r,a);s.payload=t,n!=null&&(s.callback=n),t=ki(e,s,a),t!==null&&(Aa(t,e,a,r),Eg(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=dr(),a=Ii(e),s=$s(r,a);s.tag=1,s.payload=t,n!=null&&(s.callback=n),t=ki(e,s,a),t!==null&&(Aa(t,e,a,r),Eg(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=dr(),r=Ii(e),a=$s(n,r);a.tag=2,t!=null&&(a.callback=t),t=ki(e,a,r),t!==null&&(Aa(t,e,r,n),Eg(t,e,r))}};function LC(e,t,n,r,a,s,i){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(r,s,i):t.prototype&&t.prototype.isPureReactComponent?!Dh(n,r)||!Dh(a,s):!0}function aA(e,t,n){var r=!1,a=Ai,s=t.contextType;return typeof s=="object"&&s!==null?s=ga(s):(a=$r(t)?jo:Qn.current,r=t.contextTypes,s=(r=r!=null)?Rd(e,a):Ai),t=new t(n,s),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=ib,e.stateNode=t,t._reactInternals=e,r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=s),t}function zC(e,t,n,r){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,r),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&ib.enqueueReplaceState(t,t.state,null)}function M0(e,t,n,r){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs={},W1(e);var s=t.contextType;typeof s=="object"&&s!==null?a.context=ga(s):(s=$r(t)?jo:Qn.current,a.context=Rd(e,s)),a.state=e.memoizedState,s=t.getDerivedStateFromProps,typeof s=="function"&&(D0(e,t,s,n),a.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof a.getSnapshotBeforeUpdate=="function"||typeof a.UNSAFE_componentWillMount!="function"&&typeof a.componentWillMount!="function"||(t=a.state,typeof a.componentWillMount=="function"&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount=="function"&&a.UNSAFE_componentWillMount(),t!==a.state&&ib.enqueueReplaceState(a,a.state,null),ly(e,n,a,r),a.state=e.memoizedState),typeof a.componentDidMount=="function"&&(e.flags|=4194308)}function Od(e,t){try{var n="",r=t;do n+=DW(r),r=r.return;while(r);var a=n}catch(s){a=`
Error generating stack: `+s.message+`
`+s.stack}return{value:e,source:t,stack:a,digest:null}}function Cx(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function O0(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var oV=typeof WeakMap=="function"?WeakMap:Map;function sA(e,t,n){n=$s(-1,n),n.tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){hy||(hy=!0,G0=r),O0(e,t)},n}function iA(e,t,n){n=$s(-1,n),n.tag=3;var r=e.type.getDerivedStateFromError;if(typeof r=="function"){var a=t.value;n.payload=function(){return r(a)},n.callback=function(){O0(e,t)}}var s=e.stateNode;return s!==null&&typeof s.componentDidCatch=="function"&&(n.callback=function(){O0(e,t),typeof r!="function"&&(Si===null?Si=new Set([this]):Si.add(this));var i=t.stack;this.componentDidCatch(t.value,{componentStack:i!==null?i:""})}),n}function BC(e,t,n){var r=e.pingCache;if(r===null){r=e.pingCache=new oV;var a=new Set;r.set(t,a)}else a=r.get(t),a===void 0&&(a=new Set,r.set(t,a));a.has(n)||(a.add(n),e=wV.bind(null,e,t,n),t.then(e,e))}function WC(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function UC(e,t,n,r,a){return e.mode&1?(e.flags|=65536,e.lanes=a,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=$s(-1,1),t.tag=2,ki(n,t,1))),n.lanes|=1),e)}var lV=Bs.ReactCurrentOwner,Tr=!1;function or(e,t,n,r){t.child=e===null?M$(t,null,n,r):Dd(t,e.child,n,r)}function VC(e,t,n,r,a){n=n.render;var s=t.ref;return Id(t,a),r=G1(e,t,n,r,s,a),n=q1(),e!==null&&!Tr?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Ps(e,t,a)):(Rt&&n&&D1(t),t.flags|=1,or(e,t,r,a),t.child)}function jC(e,t,n,r,a){if(e===null){var s=n.type;return typeof s=="function"&&!rk(s)&&s.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=s,oA(e,t,s,r,a)):(e=Dg(n.type,null,r,t,t.mode,a),e.ref=t.ref,e.return=t,t.child=e)}if(s=e.child,!(e.lanes&a)){var i=s.memoizedProps;if(n=n.compare,n=n!==null?n:Dh,n(i,r)&&e.ref===t.ref)return Ps(e,t,a)}return t.flags|=1,e=Ni(s,r),e.ref=t.ref,e.return=t,t.child=e}function oA(e,t,n,r,a){if(e!==null){var s=e.memoizedProps;if(Dh(s,r)&&e.ref===t.ref)if(Tr=!1,t.pendingProps=r=s,(e.lanes&a)!==0)e.flags&131072&&(Tr=!0);else return t.lanes=e.lanes,Ps(e,t,a)}return P0(e,t,n,r,a)}function lA(e,t,n){var r=t.pendingProps,a=r.children,s=e!==null?e.memoizedState:null;if(r.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Nt(yd,Hr),Hr|=n;else{if(!(n&1073741824))return e=s!==null?s.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Nt(yd,Hr),Hr|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=s!==null?s.baseLanes:n,Nt(yd,Hr),Hr|=r}else s!==null?(r=s.baseLanes|n,t.memoizedState=null):r=n,Nt(yd,Hr),Hr|=r;return or(e,t,a,n),t.child}function uA(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function P0(e,t,n,r,a){var s=$r(n)?jo:Qn.current;return s=Rd(t,s),Id(t,a),n=G1(e,t,n,r,s,a),r=q1(),e!==null&&!Tr?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Ps(e,t,a)):(Rt&&r&&D1(t),t.flags|=1,or(e,t,n,a),t.child)}function HC(e,t,n,r,a){if($r(n)){var s=!0;ry(t)}else s=!1;if(Id(t,a),t.stateNode===null)Ag(e,t),aA(t,n,r),M0(t,n,r,a),r=!0;else if(e===null){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,d=n.contextType;typeof d=="object"&&d!==null?d=ga(d):(d=$r(n)?jo:Qn.current,d=Rd(t,d));var u=n.getDerivedStateFromProps,c=typeof u=="function"||typeof i.getSnapshotBeforeUpdate=="function";c||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==r||l!==d)&&zC(t,i,r,d),si=!1;var p=t.memoizedState;i.state=p,ly(t,r,i,a),l=t.memoizedState,o!==r||p!==l||_r.current||si?(typeof u=="function"&&(D0(t,n,u,r),l=t.memoizedState),(o=si||LC(t,n,o,r,p,l,d))?(c||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(t.flags|=4194308)):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=d,r=o):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,P$(e,t),o=t.memoizedProps,d=t.type===t.elementType?o:Ca(t.type,o),i.props=d,c=t.pendingProps,p=i.context,l=n.contextType,typeof l=="object"&&l!==null?l=ga(l):(l=$r(n)?jo:Qn.current,l=Rd(t,l));var h=n.getDerivedStateFromProps;(u=typeof h=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==c||p!==l)&&zC(t,i,r,l),si=!1,p=t.memoizedState,i.state=p,ly(t,r,i,a);var f=t.memoizedState;o!==c||p!==f||_r.current||si?(typeof h=="function"&&(D0(t,n,h,r),f=t.memoizedState),(d=si||LC(t,n,d,r,p,f,l)||!1)?(u||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(r,f,l),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(r,f,l)),typeof i.componentDidUpdate=="function"&&(t.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof i.componentDidUpdate!="function"||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=d):(typeof i.componentDidUpdate!="function"||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),r=!1)}return L0(e,t,n,r,s,a)}function L0(e,t,n,r,a,s){uA(e,t);var i=(t.flags&128)!==0;if(!r&&!i)return a&&$C(t,n,!1),Ps(e,t,s);r=t.stateNode,lV.current=t;var o=i&&typeof n.getDerivedStateFromError!="function"?null:r.render();return t.flags|=1,e!==null&&i?(t.child=Dd(t,e.child,null,s),t.child=Dd(t,null,o,s)):or(e,t,o,s),t.memoizedState=r.state,a&&$C(t,n,!0),t.child}function dA(e){var t=e.stateNode;t.pendingContext?_C(e,t.pendingContext,t.pendingContext!==t.context):t.context&&_C(e,t.context,!1),U1(e,t.containerInfo)}function GC(e,t,n,r,a){return Fd(),O1(a),t.flags|=256,or(e,t,n,r),t.child}var z0={dehydrated:null,treeContext:null,retryLane:0};function B0(e){return{baseLanes:e,cachePool:null,transitions:null}}function cA(e,t,n){var r=t.pendingProps,a=Lt.current,s=!1,i=(t.flags&128)!==0,o;if((o=i)||(o=e!==null&&e.memoizedState===null?!1:(a&2)!==0),o?(s=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(a|=1),Nt(Lt,a&1),e===null)return R0(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(i=r.children,e=r.fallback,s?(r=t.mode,s=t.child,i={mode:"hidden",children:i},!(r&1)&&s!==null?(s.childLanes=0,s.pendingProps=i):s=ub(i,r,0,null),e=Lo(e,r,n,null),s.return=t,e.return=t,s.sibling=e,t.child=s,t.child.memoizedState=B0(n),t.memoizedState=z0,e):Q1(t,i));if(a=e.memoizedState,a!==null&&(o=a.dehydrated,o!==null))return uV(e,t,i,r,o,a,n);if(s){s=r.fallback,i=t.mode,a=e.child,o=a.sibling;var l={mode:"hidden",children:r.children};return!(i&1)&&t.child!==a?(r=t.child,r.childLanes=0,r.pendingProps=l,t.deletions=null):(r=Ni(a,l),r.subtreeFlags=a.subtreeFlags&14680064),o!==null?s=Ni(o,s):(s=Lo(s,i,n,null),s.flags|=2),s.return=t,r.return=t,r.sibling=s,t.child=r,r=s,s=t.child,i=e.child.memoizedState,i=i===null?B0(n):{baseLanes:i.baseLanes|n,cachePool:null,transitions:i.transitions},s.memoizedState=i,s.childLanes=e.childLanes&~n,t.memoizedState=z0,r}return s=e.child,e=s.sibling,r=Ni(s,{mode:"visible",children:r.children}),!(t.mode&1)&&(r.lanes=n),r.return=t,r.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function Q1(e,t){return t=ub({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function eg(e,t,n,r){return r!==null&&O1(r),Dd(t,e.child,null,n),e=Q1(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function uV(e,t,n,r,a,s,i){if(n)return t.flags&256?(t.flags&=-257,r=Cx(Error(de(422))),eg(e,t,i,r)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(s=r.fallback,a=t.mode,r=ub({mode:"visible",children:r.children},a,0,null),s=Lo(s,a,i,null),s.flags|=2,r.return=t,s.return=t,r.sibling=s,t.child=r,t.mode&1&&Dd(t,e.child,null,i),t.child.memoizedState=B0(i),t.memoizedState=z0,s);if(!(t.mode&1))return eg(e,t,i,null);if(a.data==="$!"){if(r=a.nextSibling&&a.nextSibling.dataset,r)var o=r.dgst;return r=o,s=Error(de(419)),r=Cx(s,r,void 0),eg(e,t,i,r)}if(o=(i&e.childLanes)!==0,Tr||o){if(r=An,r!==null){switch(i&-i){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}a=a&(r.suspendedLanes|i)?0:a,a!==0&&a!==s.retryLane&&(s.retryLane=a,Os(e,a),Aa(r,e,a,-1))}return nk(),r=Cx(Error(de(421))),eg(e,t,i,r)}return a.data==="$?"?(t.flags|=128,t.child=e.child,t=kV.bind(null,e),a._reactRetry=t,null):(e=s.treeContext,Gr=wi(a.nextSibling),Jr=t,Rt=!0,Ea=null,e!==null&&(ca[pa++]=Es,ca[pa++]=_s,ca[pa++]=Ho,Es=e.id,_s=e.overflow,Ho=t),t=Q1(t,r.children),t.flags|=4096,t)}function qC(e,t,n){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),F0(e.return,t,n)}function Tx(e,t,n,r,a){var s=e.memoizedState;s===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(s.isBackwards=t,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=a)}function pA(e,t,n){var r=t.pendingProps,a=r.revealOrder,s=r.tail;if(or(e,t,r.children,n),r=Lt.current,r&2)r=r&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&qC(e,n,t);else if(e.tag===19)qC(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Nt(Lt,r),!(t.mode&1))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;n!==null;)e=n.alternate,e!==null&&uy(e)===null&&(a=n),n=n.sibling;n=a,n===null?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),Tx(t,!1,a,n,s);break;case"backwards":for(n=null,a=t.child,t.child=null;a!==null;){if(e=a.alternate,e!==null&&uy(e)===null){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}Tx(t,!0,n,null,s);break;case"together":Tx(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Ag(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Ps(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),qo|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(de(153));if(t.child!==null){for(e=t.child,n=Ni(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=Ni(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function dV(e,t,n){switch(t.tag){case 3:dA(t),Fd();break;case 5:L$(t);break;case 1:$r(t.type)&&ry(t);break;case 4:U1(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,a=t.memoizedProps.value;Nt(iy,r._currentValue),r._currentValue=a;break;case 13:if(r=t.memoizedState,r!==null)return r.dehydrated!==null?(Nt(Lt,Lt.current&1),t.flags|=128,null):n&t.child.childLanes?cA(e,t,n):(Nt(Lt,Lt.current&1),e=Ps(e,t,n),e!==null?e.sibling:null);Nt(Lt,Lt.current&1);break;case 19:if(r=(n&t.childLanes)!==0,e.flags&128){if(r)return pA(e,t,n);t.flags|=128}if(a=t.memoizedState,a!==null&&(a.rendering=null,a.tail=null,a.lastEffect=null),Nt(Lt,Lt.current),r)break;return null;case 22:case 23:return t.lanes=0,lA(e,t,n)}return Ps(e,t,n)}var hA,W0,fA,mA;hA=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};W0=function(){};fA=function(e,t,n,r){var a=e.memoizedProps;if(a!==r){e=t.stateNode,Fo(ss.current);var s=null;switch(n){case"input":a=u0(e,a),r=u0(e,r),s=[];break;case"select":a=Bt({},a,{value:void 0}),r=Bt({},r,{value:void 0}),s=[];break;case"textarea":a=p0(e,a),r=p0(e,r),s=[];break;default:typeof a.onClick!="function"&&typeof r.onClick=="function"&&(e.onclick=ty)}f0(n,r);var i;n=null;for(d in a)if(!r.hasOwnProperty(d)&&a.hasOwnProperty(d)&&a[d]!=null)if(d==="style"){var o=a[d];for(i in o)o.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else d!=="dangerouslySetInnerHTML"&&d!=="children"&&d!=="suppressContentEditableWarning"&&d!=="suppressHydrationWarning"&&d!=="autoFocus"&&(Th.hasOwnProperty(d)?s||(s=[]):(s=s||[]).push(d,null));for(d in r){var l=r[d];if(o=a!=null?a[d]:void 0,r.hasOwnProperty(d)&&l!==o&&(l!=null||o!=null))if(d==="style")if(o){for(i in o)!o.hasOwnProperty(i)||l&&l.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in l)l.hasOwnProperty(i)&&o[i]!==l[i]&&(n||(n={}),n[i]=l[i])}else n||(s||(s=[]),s.push(d,n)),n=l;else d==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,o=o?o.__html:void 0,l!=null&&o!==l&&(s=s||[]).push(d,l)):d==="children"?typeof l!="string"&&typeof l!="number"||(s=s||[]).push(d,""+l):d!=="suppressContentEditableWarning"&&d!=="suppressHydrationWarning"&&(Th.hasOwnProperty(d)?(l!=null&&d==="onScroll"&&Tt("scroll",e),s||o===l||(s=[])):(s=s||[]).push(d,l))}n&&(s=s||[]).push("style",n);var d=s;(t.updateQueue=d)&&(t.flags|=4)}};mA=function(e,t,n,r){n!==r&&(t.flags|=4)};function Hp(e,t){if(!Rt)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Un(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;a!==null;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags&14680064,r|=a.flags&14680064,a.return=e,a=a.sibling;else for(a=e.child;a!==null;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function cV(e,t,n){var r=t.pendingProps;switch(M1(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Un(t),null;case 1:return $r(t.type)&&ny(),Un(t),null;case 3:return r=t.stateNode,Md(),Et(_r),Et(Qn),j1(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(e===null||e.child===null)&&(Zm(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,Ea!==null&&(X0(Ea),Ea=null))),W0(e,t),Un(t),null;case 5:V1(t);var a=Fo(zh.current);if(n=t.type,e!==null&&t.stateNode!=null)fA(e,t,n,r,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(t.stateNode===null)throw Error(de(166));return Un(t),null}if(e=Fo(ss.current),Zm(t)){r=t.stateNode,n=t.type;var s=t.memoizedProps;switch(r[ts]=t,r[Ph]=s,e=(t.mode&1)!==0,n){case"dialog":Tt("cancel",r),Tt("close",r);break;case"iframe":case"object":case"embed":Tt("load",r);break;case"video":case"audio":for(a=0;a<nh.length;a++)Tt(nh[a],r);break;case"source":Tt("error",r);break;case"img":case"image":case"link":Tt("error",r),Tt("load",r);break;case"details":Tt("toggle",r);break;case"input":nC(r,s),Tt("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!s.multiple},Tt("invalid",r);break;case"textarea":aC(r,s),Tt("invalid",r)}f0(n,s),a=null;for(var i in s)if(s.hasOwnProperty(i)){var o=s[i];i==="children"?typeof o=="string"?r.textContent!==o&&(s.suppressHydrationWarning!==!0&&Jm(r.textContent,o,e),a=["children",o]):typeof o=="number"&&r.textContent!==""+o&&(s.suppressHydrationWarning!==!0&&Jm(r.textContent,o,e),a=["children",""+o]):Th.hasOwnProperty(i)&&o!=null&&i==="onScroll"&&Tt("scroll",r)}switch(n){case"input":Vm(r),rC(r,s,!0);break;case"textarea":Vm(r),sC(r);break;case"select":case"option":break;default:typeof s.onClick=="function"&&(r.onclick=ty)}r=a,t.updateQueue=r,r!==null&&(t.flags|=4)}else{i=a.nodeType===9?a:a.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=V_(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=i.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof r.is=="string"?e=i.createElement(n,{is:r.is}):(e=i.createElement(n),n==="select"&&(i=e,r.multiple?i.multiple=!0:r.size&&(i.size=r.size))):e=i.createElementNS(e,n),e[ts]=t,e[Ph]=r,hA(e,t,!1,!1),t.stateNode=e;e:{switch(i=m0(n,r),n){case"dialog":Tt("cancel",e),Tt("close",e),a=r;break;case"iframe":case"object":case"embed":Tt("load",e),a=r;break;case"video":case"audio":for(a=0;a<nh.length;a++)Tt(nh[a],e);a=r;break;case"source":Tt("error",e),a=r;break;case"img":case"image":case"link":Tt("error",e),Tt("load",e),a=r;break;case"details":Tt("toggle",e),a=r;break;case"input":nC(e,r),a=u0(e,r),Tt("invalid",e);break;case"option":a=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},a=Bt({},r,{value:void 0}),Tt("invalid",e);break;case"textarea":aC(e,r),a=p0(e,r),Tt("invalid",e);break;default:a=r}f0(n,a),o=a;for(s in o)if(o.hasOwnProperty(s)){var l=o[s];s==="style"?G_(e,l):s==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&j_(e,l)):s==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&Eh(e,l):typeof l=="number"&&Eh(e,""+l):s!=="suppressContentEditableWarning"&&s!=="suppressHydrationWarning"&&s!=="autoFocus"&&(Th.hasOwnProperty(s)?l!=null&&s==="onScroll"&&Tt("scroll",e):l!=null&&x1(e,s,l,i))}switch(n){case"input":Vm(e),rC(e,r,!1);break;case"textarea":Vm(e),sC(e);break;case"option":r.value!=null&&e.setAttribute("value",""+$i(r.value));break;case"select":e.multiple=!!r.multiple,s=r.value,s!=null?xd(e,!!r.multiple,s,!1):r.defaultValue!=null&&xd(e,!!r.multiple,r.defaultValue,!0);break;default:typeof a.onClick=="function"&&(e.onclick=ty)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return Un(t),null;case 6:if(e&&t.stateNode!=null)mA(e,t,e.memoizedProps,r);else{if(typeof r!="string"&&t.stateNode===null)throw Error(de(166));if(n=Fo(zh.current),Fo(ss.current),Zm(t)){if(r=t.stateNode,n=t.memoizedProps,r[ts]=t,(s=r.nodeValue!==n)&&(e=Jr,e!==null))switch(e.tag){case 3:Jm(r.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&Jm(r.nodeValue,n,(e.mode&1)!==0)}s&&(t.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[ts]=t,t.stateNode=r}return Un(t),null;case 13:if(Et(Lt),r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(Rt&&Gr!==null&&t.mode&1&&!(t.flags&128))F$(),Fd(),t.flags|=98560,s=!1;else if(s=Zm(t),r!==null&&r.dehydrated!==null){if(e===null){if(!s)throw Error(de(318));if(s=t.memoizedState,s=s!==null?s.dehydrated:null,!s)throw Error(de(317));s[ts]=t}else Fd(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;Un(t),s=!1}else Ea!==null&&(X0(Ea),Ea=null),s=!0;if(!s)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(r=r!==null,r!==(e!==null&&e.memoizedState!==null)&&r&&(t.child.flags|=8192,t.mode&1&&(e===null||Lt.current&1?bn===0&&(bn=3):nk())),t.updateQueue!==null&&(t.flags|=4),Un(t),null);case 4:return Md(),W0(e,t),e===null&&Mh(t.stateNode.containerInfo),Un(t),null;case 10:return z1(t.type._context),Un(t),null;case 17:return $r(t.type)&&ny(),Un(t),null;case 19:if(Et(Lt),s=t.memoizedState,s===null)return Un(t),null;if(r=(t.flags&128)!==0,i=s.rendering,i===null)if(r)Hp(s,!1);else{if(bn!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(i=uy(e),i!==null){for(t.flags|=128,Hp(s,!1),r=i.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;n!==null;)s=n,e=r,s.flags&=14680066,i=s.alternate,i===null?(s.childLanes=0,s.lanes=e,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=i.childLanes,s.lanes=i.lanes,s.child=i.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=i.memoizedProps,s.memoizedState=i.memoizedState,s.updateQueue=i.updateQueue,s.type=i.type,e=i.dependencies,s.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Nt(Lt,Lt.current&1|2),t.child}e=e.sibling}s.tail!==null&&Qt()>Pd&&(t.flags|=128,r=!0,Hp(s,!1),t.lanes=4194304)}else{if(!r)if(e=uy(i),e!==null){if(t.flags|=128,r=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),Hp(s,!0),s.tail===null&&s.tailMode==="hidden"&&!i.alternate&&!Rt)return Un(t),null}else 2*Qt()-s.renderingStartTime>Pd&&n!==1073741824&&(t.flags|=128,r=!0,Hp(s,!1),t.lanes=4194304);s.isBackwards?(i.sibling=t.child,t.child=i):(n=s.last,n!==null?n.sibling=i:t.child=i,s.last=i)}return s.tail!==null?(t=s.tail,s.rendering=t,s.tail=t.sibling,s.renderingStartTime=Qt(),t.sibling=null,n=Lt.current,Nt(Lt,r?n&1|2:n&1),t):(Un(t),null);case 22:case 23:return tk(),r=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==r&&(t.flags|=8192),r&&t.mode&1?Hr&1073741824&&(Un(t),t.subtreeFlags&6&&(t.flags|=8192)):Un(t),null;case 24:return null;case 25:return null}throw Error(de(156,t.tag))}function pV(e,t){switch(M1(t),t.tag){case 1:return $r(t.type)&&ny(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return Md(),Et(_r),Et(Qn),j1(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return V1(t),null;case 13:if(Et(Lt),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(de(340));Fd()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return Et(Lt),null;case 4:return Md(),null;case 10:return z1(t.type._context),null;case 22:case 23:return tk(),null;case 24:return null;default:return null}}var tg=!1,Vn=!1,hV=typeof WeakSet=="function"?WeakSet:Set,Se=null;function gd(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){jt(e,t,r)}else n.current=null}function U0(e,t,n){try{n()}catch(r){jt(e,t,r)}}var KC=!1;function fV(e,t){if(N0=Zg,e=x$(),F1(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var a=r.anchorOffset,s=r.focusNode;r=r.focusOffset;try{n.nodeType,s.nodeType}catch{n=null;break e}var i=0,o=-1,l=-1,d=0,u=0,c=e,p=null;t:for(;;){for(var h;c!==n||a!==0&&c.nodeType!==3||(o=i+a),c!==s||r!==0&&c.nodeType!==3||(l=i+r),c.nodeType===3&&(i+=c.nodeValue.length),(h=c.firstChild)!==null;)p=c,c=h;for(;;){if(c===e)break t;if(p===n&&++d===a&&(o=i),p===s&&++u===r&&(l=i),(h=c.nextSibling)!==null)break;c=p,p=c.parentNode}c=h}n=o===-1||l===-1?null:{start:o,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(C0={focusedElem:e,selectionRange:n},Zg=!1,Se=t;Se!==null;)if(t=Se,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,Se=e;else for(;Se!==null;){t=Se;try{var f=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(f!==null){var m=f.memoizedProps,g=f.memoizedState,y=t.stateNode,b=y.getSnapshotBeforeUpdate(t.elementType===t.type?m:Ca(t.type,m),g);y.__reactInternalSnapshotBeforeUpdate=b}break;case 3:var v=t.stateNode.containerInfo;v.nodeType===1?v.textContent="":v.nodeType===9&&v.documentElement&&v.removeChild(v.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(de(163))}}catch(x){jt(t,t.return,x)}if(e=t.sibling,e!==null){e.return=t.return,Se=e;break}Se=t.return}return f=KC,KC=!1,f}function vh(e,t,n){var r=t.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var a=r=r.next;do{if((a.tag&e)===e){var s=a.destroy;a.destroy=void 0,s!==void 0&&U0(t,n,s)}a=a.next}while(a!==r)}}function ob(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function V0(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function gA(e){var t=e.alternate;t!==null&&(e.alternate=null,gA(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[ts],delete t[Ph],delete t[_0],delete t[QU],delete t[JU])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function yA(e){return e.tag===5||e.tag===3||e.tag===4}function XC(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||yA(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function j0(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=ty));else if(r!==4&&(e=e.child,e!==null))for(j0(e,t,n),e=e.sibling;e!==null;)j0(e,t,n),e=e.sibling}function H0(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(r!==4&&(e=e.child,e!==null))for(H0(e,t,n),e=e.sibling;e!==null;)H0(e,t,n),e=e.sibling}var Fn=null,Ta=!1;function Zs(e,t,n){for(n=n.child;n!==null;)bA(e,t,n),n=n.sibling}function bA(e,t,n){if(as&&typeof as.onCommitFiberUnmount=="function")try{as.onCommitFiberUnmount(Yy,n)}catch{}switch(n.tag){case 5:Vn||gd(n,t);case 6:var r=Fn,a=Ta;Fn=null,Zs(e,t,n),Fn=r,Ta=a,Fn!==null&&(Ta?(e=Fn,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):Fn.removeChild(n.stateNode));break;case 18:Fn!==null&&(Ta?(e=Fn,n=n.stateNode,e.nodeType===8?xx(e.parentNode,n):e.nodeType===1&&xx(e,n),Rh(e)):xx(Fn,n.stateNode));break;case 4:r=Fn,a=Ta,Fn=n.stateNode.containerInfo,Ta=!0,Zs(e,t,n),Fn=r,Ta=a;break;case 0:case 11:case 14:case 15:if(!Vn&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){a=r=r.next;do{var s=a,i=s.destroy;s=s.tag,i!==void 0&&(s&2||s&4)&&U0(n,t,i),a=a.next}while(a!==r)}Zs(e,t,n);break;case 1:if(!Vn&&(gd(n,t),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){jt(n,t,o)}Zs(e,t,n);break;case 21:Zs(e,t,n);break;case 22:n.mode&1?(Vn=(r=Vn)||n.memoizedState!==null,Zs(e,t,n),Vn=r):Zs(e,t,n);break;default:Zs(e,t,n)}}function QC(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new hV),t.forEach(function(r){var a=SV.bind(null,e,r);n.has(r)||(n.add(r),r.then(a,a))})}}function ka(e,t){var n=t.deletions;if(n!==null)for(var r=0;r<n.length;r++){var a=n[r];try{var s=e,i=t,o=i;e:for(;o!==null;){switch(o.tag){case 5:Fn=o.stateNode,Ta=!1;break e;case 3:Fn=o.stateNode.containerInfo,Ta=!0;break e;case 4:Fn=o.stateNode.containerInfo,Ta=!0;break e}o=o.return}if(Fn===null)throw Error(de(160));bA(s,i,a),Fn=null,Ta=!1;var l=a.alternate;l!==null&&(l.return=null),a.return=null}catch(d){jt(a,t,d)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)vA(t,e),t=t.sibling}function vA(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ka(t,e),Ha(e),r&4){try{vh(3,e,e.return),ob(3,e)}catch(m){jt(e,e.return,m)}try{vh(5,e,e.return)}catch(m){jt(e,e.return,m)}}break;case 1:ka(t,e),Ha(e),r&512&&n!==null&&gd(n,n.return);break;case 5:if(ka(t,e),Ha(e),r&512&&n!==null&&gd(n,n.return),e.flags&32){var a=e.stateNode;try{Eh(a,"")}catch(m){jt(e,e.return,m)}}if(r&4&&(a=e.stateNode,a!=null)){var s=e.memoizedProps,i=n!==null?n.memoizedProps:s,o=e.type,l=e.updateQueue;if(e.updateQueue=null,l!==null)try{o==="input"&&s.type==="radio"&&s.name!=null&&W_(a,s),m0(o,i);var d=m0(o,s);for(i=0;i<l.length;i+=2){var u=l[i],c=l[i+1];u==="style"?G_(a,c):u==="dangerouslySetInnerHTML"?j_(a,c):u==="children"?Eh(a,c):x1(a,u,c,d)}switch(o){case"input":d0(a,s);break;case"textarea":U_(a,s);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!s.multiple;var h=s.value;h!=null?xd(a,!!s.multiple,h,!1):p!==!!s.multiple&&(s.defaultValue!=null?xd(a,!!s.multiple,s.defaultValue,!0):xd(a,!!s.multiple,s.multiple?[]:"",!1))}a[Ph]=s}catch(m){jt(e,e.return,m)}}break;case 6:if(ka(t,e),Ha(e),r&4){if(e.stateNode===null)throw Error(de(162));a=e.stateNode,s=e.memoizedProps;try{a.nodeValue=s}catch(m){jt(e,e.return,m)}}break;case 3:if(ka(t,e),Ha(e),r&4&&n!==null&&n.memoizedState.isDehydrated)try{Rh(t.containerInfo)}catch(m){jt(e,e.return,m)}break;case 4:ka(t,e),Ha(e);break;case 13:ka(t,e),Ha(e),a=e.child,a.flags&8192&&(s=a.memoizedState!==null,a.stateNode.isHidden=s,!s||a.alternate!==null&&a.alternate.memoizedState!==null||(Y1=Qt())),r&4&&QC(e);break;case 22:if(u=n!==null&&n.memoizedState!==null,e.mode&1?(Vn=(d=Vn)||u,ka(t,e),Vn=d):ka(t,e),Ha(e),r&8192){if(d=e.memoizedState!==null,(e.stateNode.isHidden=d)&&!u&&e.mode&1)for(Se=e,u=e.child;u!==null;){for(c=Se=u;Se!==null;){switch(p=Se,h=p.child,p.tag){case 0:case 11:case 14:case 15:vh(4,p,p.return);break;case 1:gd(p,p.return);var f=p.stateNode;if(typeof f.componentWillUnmount=="function"){r=p,n=p.return;try{t=r,f.props=t.memoizedProps,f.state=t.memoizedState,f.componentWillUnmount()}catch(m){jt(r,n,m)}}break;case 5:gd(p,p.return);break;case 22:if(p.memoizedState!==null){ZC(c);continue}}h!==null?(h.return=p,Se=h):ZC(c)}u=u.sibling}e:for(u=null,c=e;;){if(c.tag===5){if(u===null){u=c;try{a=c.stateNode,d?(s=a.style,typeof s.setProperty=="function"?s.setProperty("display","none","important"):s.display="none"):(o=c.stateNode,l=c.memoizedProps.style,i=l!=null&&l.hasOwnProperty("display")?l.display:null,o.style.display=H_("display",i))}catch(m){jt(e,e.return,m)}}}else if(c.tag===6){if(u===null)try{c.stateNode.nodeValue=d?"":c.memoizedProps}catch(m){jt(e,e.return,m)}}else if((c.tag!==22&&c.tag!==23||c.memoizedState===null||c===e)&&c.child!==null){c.child.return=c,c=c.child;continue}if(c===e)break e;for(;c.sibling===null;){if(c.return===null||c.return===e)break e;u===c&&(u=null),c=c.return}u===c&&(u=null),c.sibling.return=c.return,c=c.sibling}}break;case 19:ka(t,e),Ha(e),r&4&&QC(e);break;case 21:break;default:ka(t,e),Ha(e)}}function Ha(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if(yA(n)){var r=n;break e}n=n.return}throw Error(de(160))}switch(r.tag){case 5:var a=r.stateNode;r.flags&32&&(Eh(a,""),r.flags&=-33);var s=XC(e);H0(e,s,a);break;case 3:case 4:var i=r.stateNode.containerInfo,o=XC(e);j0(e,o,i);break;default:throw Error(de(161))}}catch(l){jt(e,e.return,l)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function mV(e,t,n){Se=e,xA(e)}function xA(e,t,n){for(var r=(e.mode&1)!==0;Se!==null;){var a=Se,s=a.child;if(a.tag===22&&r){var i=a.memoizedState!==null||tg;if(!i){var o=a.alternate,l=o!==null&&o.memoizedState!==null||Vn;o=tg;var d=Vn;if(tg=i,(Vn=l)&&!d)for(Se=a;Se!==null;)i=Se,l=i.child,i.tag===22&&i.memoizedState!==null?YC(a):l!==null?(l.return=i,Se=l):YC(a);for(;s!==null;)Se=s,xA(s),s=s.sibling;Se=a,tg=o,Vn=d}JC(e)}else a.subtreeFlags&8772&&s!==null?(s.return=a,Se=s):JC(e)}}function JC(e){for(;Se!==null;){var t=Se;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:Vn||ob(5,t);break;case 1:var r=t.stateNode;if(t.flags&4&&!Vn)if(n===null)r.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:Ca(t.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var s=t.updateQueue;s!==null&&MC(t,s,r);break;case 3:var i=t.updateQueue;if(i!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}MC(t,i,n)}break;case 5:var o=t.stateNode;if(n===null&&t.flags&4){n=o;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var d=t.alternate;if(d!==null){var u=d.memoizedState;if(u!==null){var c=u.dehydrated;c!==null&&Rh(c)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(de(163))}Vn||t.flags&512&&V0(t)}catch(p){jt(t,t.return,p)}}if(t===e){Se=null;break}if(n=t.sibling,n!==null){n.return=t.return,Se=n;break}Se=t.return}}function ZC(e){for(;Se!==null;){var t=Se;if(t===e){Se=null;break}var n=t.sibling;if(n!==null){n.return=t.return,Se=n;break}Se=t.return}}function YC(e){for(;Se!==null;){var t=Se;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{ob(4,t)}catch(l){jt(t,n,l)}break;case 1:var r=t.stateNode;if(typeof r.componentDidMount=="function"){var a=t.return;try{r.componentDidMount()}catch(l){jt(t,a,l)}}var s=t.return;try{V0(t)}catch(l){jt(t,s,l)}break;case 5:var i=t.return;try{V0(t)}catch(l){jt(t,i,l)}}}catch(l){jt(t,t.return,l)}if(t===e){Se=null;break}var o=t.sibling;if(o!==null){o.return=t.return,Se=o;break}Se=t.return}}var gV=Math.ceil,py=Bs.ReactCurrentDispatcher,J1=Bs.ReactCurrentOwner,fa=Bs.ReactCurrentBatchConfig,st=0,An=null,an=null,Dn=0,Hr=0,yd=Ki(0),bn=0,Vh=null,qo=0,lb=0,Z1=0,xh=null,Nr=null,Y1=0,Pd=1/0,ks=null,hy=!1,G0=null,Si=null,ng=!1,pi=null,fy=0,wh=0,q0=null,Rg=-1,Fg=0;function dr(){return st&6?Qt():Rg!==-1?Rg:Rg=Qt()}function Ii(e){return e.mode&1?st&2&&Dn!==0?Dn&-Dn:YU.transition!==null?(Fg===0&&(Fg=a$()),Fg):(e=mt,e!==0||(e=window.event,e=e===void 0?16:c$(e.type)),e):1}function Aa(e,t,n,r){if(50<wh)throw wh=0,q0=null,Error(de(185));pf(e,n,r),(!(st&2)||e!==An)&&(e===An&&(!(st&2)&&(lb|=n),bn===4&&ui(e,Dn)),Ar(e,r),n===1&&st===0&&!(t.mode&1)&&(Pd=Qt()+500,ab&&Xi()))}function Ar(e,t){var n=e.callbackNode;YW(e,t);var r=Jg(e,e===An?Dn:0);if(r===0)n!==null&&lC(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(n!=null&&lC(n),t===1)e.tag===0?ZU(eT.bind(null,e)):$$(eT.bind(null,e)),KU(function(){!(st&6)&&Xi()}),n=null;else{switch(s$(r)){case 1:n=N1;break;case 4:n=n$;break;case 16:n=Qg;break;case 536870912:n=r$;break;default:n=Qg}n=EA(n,wA.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function wA(e,t){if(Rg=-1,Fg=0,st&6)throw Error(de(327));var n=e.callbackNode;if(Nd()&&e.callbackNode!==n)return null;var r=Jg(e,e===An?Dn:0);if(r===0)return null;if(r&30||r&e.expiredLanes||t)t=my(e,r);else{t=r;var a=st;st|=2;var s=SA();(An!==e||Dn!==t)&&(ks=null,Pd=Qt()+500,Po(e,t));do try{vV();break}catch(o){kA(e,o)}while(!0);L1(),py.current=s,st=a,an!==null?t=0:(An=null,Dn=0,t=bn)}if(t!==0){if(t===2&&(a=x0(e),a!==0&&(r=a,t=K0(e,a))),t===1)throw n=Vh,Po(e,0),ui(e,r),Ar(e,Qt()),n;if(t===6)ui(e,r);else{if(a=e.current.alternate,!(r&30)&&!yV(a)&&(t=my(e,r),t===2&&(s=x0(e),s!==0&&(r=s,t=K0(e,s))),t===1))throw n=Vh,Po(e,0),ui(e,r),Ar(e,Qt()),n;switch(e.finishedWork=a,e.finishedLanes=r,t){case 0:case 1:throw Error(de(345));case 2:wo(e,Nr,ks);break;case 3:if(ui(e,r),(r&130023424)===r&&(t=Y1+500-Qt(),10<t)){if(Jg(e,0)!==0)break;if(a=e.suspendedLanes,(a&r)!==r){dr(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=E0(wo.bind(null,e,Nr,ks),t);break}wo(e,Nr,ks);break;case 4:if(ui(e,r),(r&4194240)===r)break;for(t=e.eventTimes,a=-1;0<r;){var i=31-$a(r);s=1<<i,i=t[i],i>a&&(a=i),r&=~s}if(r=a,r=Qt()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*gV(r/1960))-r,10<r){e.timeoutHandle=E0(wo.bind(null,e,Nr,ks),r);break}wo(e,Nr,ks);break;case 5:wo(e,Nr,ks);break;default:throw Error(de(329))}}}return Ar(e,Qt()),e.callbackNode===n?wA.bind(null,e):null}function K0(e,t){var n=xh;return e.current.memoizedState.isDehydrated&&(Po(e,t).flags|=256),e=my(e,t),e!==2&&(t=Nr,Nr=n,t!==null&&X0(t)),e}function X0(e){Nr===null?Nr=e:Nr.push.apply(Nr,e)}function yV(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var a=n[r],s=a.getSnapshot;a=a.value;try{if(!Ma(s(),a))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function ui(e,t){for(t&=~Z1,t&=~lb,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-$a(t),r=1<<n;e[n]=-1,t&=~r}}function eT(e){if(st&6)throw Error(de(327));Nd();var t=Jg(e,0);if(!(t&1))return Ar(e,Qt()),null;var n=my(e,t);if(e.tag!==0&&n===2){var r=x0(e);r!==0&&(t=r,n=K0(e,r))}if(n===1)throw n=Vh,Po(e,0),ui(e,t),Ar(e,Qt()),n;if(n===6)throw Error(de(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wo(e,Nr,ks),Ar(e,Qt()),null}function ek(e,t){var n=st;st|=1;try{return e(t)}finally{st=n,st===0&&(Pd=Qt()+500,ab&&Xi())}}function Ko(e){pi!==null&&pi.tag===0&&!(st&6)&&Nd();var t=st;st|=1;var n=fa.transition,r=mt;try{if(fa.transition=null,mt=1,e)return e()}finally{mt=r,fa.transition=n,st=t,!(st&6)&&Xi()}}function tk(){Hr=yd.current,Et(yd)}function Po(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,qU(n)),an!==null)for(n=an.return;n!==null;){var r=n;switch(M1(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&ny();break;case 3:Md(),Et(_r),Et(Qn),j1();break;case 5:V1(r);break;case 4:Md();break;case 13:Et(Lt);break;case 19:Et(Lt);break;case 10:z1(r.type._context);break;case 22:case 23:tk()}n=n.return}if(An=e,an=e=Ni(e.current,null),Dn=Hr=t,bn=0,Vh=null,Z1=lb=qo=0,Nr=xh=null,Ro!==null){for(t=0;t<Ro.length;t++)if(n=Ro[t],r=n.interleaved,r!==null){n.interleaved=null;var a=r.next,s=n.pending;if(s!==null){var i=s.next;s.next=a,r.next=i}n.pending=r}Ro=null}return e}function kA(e,t){do{var n=an;try{if(L1(),_g.current=cy,dy){for(var r=zt.memoizedState;r!==null;){var a=r.queue;a!==null&&(a.pending=null),r=r.next}dy=!1}if(Go=0,Tn=fn=zt=null,bh=!1,Bh=0,J1.current=null,n===null||n.return===null){bn=1,Vh=t,an=null;break}e:{var s=e,i=n.return,o=n,l=t;if(t=Dn,o.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var d=l,u=o,c=u.tag;if(!(u.mode&1)&&(c===0||c===11||c===15)){var p=u.alternate;p?(u.updateQueue=p.updateQueue,u.memoizedState=p.memoizedState,u.lanes=p.lanes):(u.updateQueue=null,u.memoizedState=null)}var h=WC(i);if(h!==null){h.flags&=-257,UC(h,i,o,s,t),h.mode&1&&BC(s,d,t),t=h,l=d;var f=t.updateQueue;if(f===null){var m=new Set;m.add(l),t.updateQueue=m}else f.add(l);break e}else{if(!(t&1)){BC(s,d,t),nk();break e}l=Error(de(426))}}else if(Rt&&o.mode&1){var g=WC(i);if(g!==null){!(g.flags&65536)&&(g.flags|=256),UC(g,i,o,s,t),O1(Od(l,o));break e}}s=l=Od(l,o),bn!==4&&(bn=2),xh===null?xh=[s]:xh.push(s),s=i;do{switch(s.tag){case 3:s.flags|=65536,t&=-t,s.lanes|=t;var y=sA(s,l,t);DC(s,y);break e;case 1:o=l;var b=s.type,v=s.stateNode;if(!(s.flags&128)&&(typeof b.getDerivedStateFromError=="function"||v!==null&&typeof v.componentDidCatch=="function"&&(Si===null||!Si.has(v)))){s.flags|=65536,t&=-t,s.lanes|=t;var x=iA(s,o,t);DC(s,x);break e}}s=s.return}while(s!==null)}NA(n)}catch(w){t=w,an===n&&n!==null&&(an=n=n.return);continue}break}while(!0)}function SA(){var e=py.current;return py.current=cy,e===null?cy:e}function nk(){(bn===0||bn===3||bn===2)&&(bn=4),An===null||!(qo&268435455)&&!(lb&268435455)||ui(An,Dn)}function my(e,t){var n=st;st|=2;var r=SA();(An!==e||Dn!==t)&&(ks=null,Po(e,t));do try{bV();break}catch(a){kA(e,a)}while(!0);if(L1(),st=n,py.current=r,an!==null)throw Error(de(261));return An=null,Dn=0,bn}function bV(){for(;an!==null;)IA(an)}function vV(){for(;an!==null&&!jW();)IA(an)}function IA(e){var t=TA(e.alternate,e,Hr);e.memoizedProps=e.pendingProps,t===null?NA(e):an=t,J1.current=null}function NA(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=pV(n,t),n!==null){n.flags&=32767,an=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{bn=6,an=null;return}}else if(n=cV(n,t,Hr),n!==null){an=n;return}if(t=t.sibling,t!==null){an=t;return}an=t=e}while(t!==null);bn===0&&(bn=5)}function wo(e,t,n){var r=mt,a=fa.transition;try{fa.transition=null,mt=1,xV(e,t,n,r)}finally{fa.transition=a,mt=r}return null}function xV(e,t,n,r){do Nd();while(pi!==null);if(st&6)throw Error(de(327));n=e.finishedWork;var a=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(de(177));e.callbackNode=null,e.callbackPriority=0;var s=n.lanes|n.childLanes;if(eU(e,s),e===An&&(an=An=null,Dn=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||ng||(ng=!0,EA(Qg,function(){return Nd(),null})),s=(n.flags&15990)!==0,n.subtreeFlags&15990||s){s=fa.transition,fa.transition=null;var i=mt;mt=1;var o=st;st|=4,J1.current=null,fV(e,n),vA(n,e),BU(C0),Zg=!!N0,C0=N0=null,e.current=n,mV(n),HW(),st=o,mt=i,fa.transition=s}else e.current=n;if(ng&&(ng=!1,pi=e,fy=a),s=e.pendingLanes,s===0&&(Si=null),KW(n.stateNode),Ar(e,Qt()),t!==null)for(r=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(hy)throw hy=!1,e=G0,G0=null,e;return fy&1&&e.tag!==0&&Nd(),s=e.pendingLanes,s&1?e===q0?wh++:(wh=0,q0=e):wh=0,Xi(),null}function Nd(){if(pi!==null){var e=s$(fy),t=fa.transition,n=mt;try{if(fa.transition=null,mt=16>e?16:e,pi===null)var r=!1;else{if(e=pi,pi=null,fy=0,st&6)throw Error(de(331));var a=st;for(st|=4,Se=e.current;Se!==null;){var s=Se,i=s.child;if(Se.flags&16){var o=s.deletions;if(o!==null){for(var l=0;l<o.length;l++){var d=o[l];for(Se=d;Se!==null;){var u=Se;switch(u.tag){case 0:case 11:case 15:vh(8,u,s)}var c=u.child;if(c!==null)c.return=u,Se=c;else for(;Se!==null;){u=Se;var p=u.sibling,h=u.return;if(gA(u),u===d){Se=null;break}if(p!==null){p.return=h,Se=p;break}Se=h}}}var f=s.alternate;if(f!==null){var m=f.child;if(m!==null){f.child=null;do{var g=m.sibling;m.sibling=null,m=g}while(m!==null)}}Se=s}}if(s.subtreeFlags&2064&&i!==null)i.return=s,Se=i;else e:for(;Se!==null;){if(s=Se,s.flags&2048)switch(s.tag){case 0:case 11:case 15:vh(9,s,s.return)}var y=s.sibling;if(y!==null){y.return=s.return,Se=y;break e}Se=s.return}}var b=e.current;for(Se=b;Se!==null;){i=Se;var v=i.child;if(i.subtreeFlags&2064&&v!==null)v.return=i,Se=v;else e:for(i=b;Se!==null;){if(o=Se,o.flags&2048)try{switch(o.tag){case 0:case 11:case 15:ob(9,o)}}catch(w){jt(o,o.return,w)}if(o===i){Se=null;break e}var x=o.sibling;if(x!==null){x.return=o.return,Se=x;break e}Se=o.return}}if(st=a,Xi(),as&&typeof as.onPostCommitFiberRoot=="function")try{as.onPostCommitFiberRoot(Yy,e)}catch{}r=!0}return r}finally{mt=n,fa.transition=t}}return!1}function tT(e,t,n){t=Od(n,t),t=sA(e,t,1),e=ki(e,t,1),t=dr(),e!==null&&(pf(e,1,t),Ar(e,t))}function jt(e,t,n){if(e.tag===3)tT(e,e,n);else for(;t!==null;){if(t.tag===3){tT(t,e,n);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(Si===null||!Si.has(r))){e=Od(n,e),e=iA(t,e,1),t=ki(t,e,1),e=dr(),t!==null&&(pf(t,1,e),Ar(t,e));break}}t=t.return}}function wV(e,t,n){var r=e.pingCache;r!==null&&r.delete(t),t=dr(),e.pingedLanes|=e.suspendedLanes&n,An===e&&(Dn&n)===n&&(bn===4||bn===3&&(Dn&130023424)===Dn&&500>Qt()-Y1?Po(e,0):Z1|=n),Ar(e,t)}function CA(e,t){t===0&&(e.mode&1?(t=Gm,Gm<<=1,!(Gm&130023424)&&(Gm=4194304)):t=1);var n=dr();e=Os(e,t),e!==null&&(pf(e,t,n),Ar(e,n))}function kV(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),CA(e,n)}function SV(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;a!==null&&(n=a.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(de(314))}r!==null&&r.delete(t),CA(e,n)}var TA;TA=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||_r.current)Tr=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return Tr=!1,dV(e,t,n);Tr=!!(e.flags&131072)}else Tr=!1,Rt&&t.flags&1048576&&A$(t,sy,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Ag(e,t),e=t.pendingProps;var a=Rd(t,Qn.current);Id(t,n),a=G1(null,t,r,e,a,n);var s=q1();return t.flags|=1,typeof a=="object"&&a!==null&&typeof a.render=="function"&&a.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,$r(r)?(s=!0,ry(t)):s=!1,t.memoizedState=a.state!==null&&a.state!==void 0?a.state:null,W1(t),a.updater=ib,t.stateNode=a,a._reactInternals=t,M0(t,r,e,n),t=L0(null,t,r,!0,s,n)):(t.tag=0,Rt&&s&&D1(t),or(null,t,a,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Ag(e,t),e=t.pendingProps,a=r._init,r=a(r._payload),t.type=r,a=t.tag=NV(r),e=Ca(r,e),a){case 0:t=P0(null,t,r,e,n);break e;case 1:t=HC(null,t,r,e,n);break e;case 11:t=VC(null,t,r,e,n);break e;case 14:t=jC(null,t,r,Ca(r.type,e),n);break e}throw Error(de(306,r,""))}return t;case 0:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:Ca(r,a),P0(e,t,r,a,n);case 1:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:Ca(r,a),HC(e,t,r,a,n);case 3:e:{if(dA(t),e===null)throw Error(de(387));r=t.pendingProps,s=t.memoizedState,a=s.element,P$(e,t),ly(t,r,null,n);var i=t.memoizedState;if(r=i.element,s.isDehydrated)if(s={element:r,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},t.updateQueue.baseState=s,t.memoizedState=s,t.flags&256){a=Od(Error(de(423)),t),t=GC(e,t,r,n,a);break e}else if(r!==a){a=Od(Error(de(424)),t),t=GC(e,t,r,n,a);break e}else for(Gr=wi(t.stateNode.containerInfo.firstChild),Jr=t,Rt=!0,Ea=null,n=M$(t,null,r,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(Fd(),r===a){t=Ps(e,t,n);break e}or(e,t,r,n)}t=t.child}return t;case 5:return L$(t),e===null&&R0(t),r=t.type,a=t.pendingProps,s=e!==null?e.memoizedProps:null,i=a.children,T0(r,a)?i=null:s!==null&&T0(r,s)&&(t.flags|=32),uA(e,t),or(e,t,i,n),t.child;case 6:return e===null&&R0(t),null;case 13:return cA(e,t,n);case 4:return U1(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=Dd(t,null,r,n):or(e,t,r,n),t.child;case 11:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:Ca(r,a),VC(e,t,r,a,n);case 7:return or(e,t,t.pendingProps,n),t.child;case 8:return or(e,t,t.pendingProps.children,n),t.child;case 12:return or(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,a=t.pendingProps,s=t.memoizedProps,i=a.value,Nt(iy,r._currentValue),r._currentValue=i,s!==null)if(Ma(s.value,i)){if(s.children===a.children&&!_r.current){t=Ps(e,t,n);break e}}else for(s=t.child,s!==null&&(s.return=t);s!==null;){var o=s.dependencies;if(o!==null){i=s.child;for(var l=o.firstContext;l!==null;){if(l.context===r){if(s.tag===1){l=$s(-1,n&-n),l.tag=2;var d=s.updateQueue;if(d!==null){d=d.shared;var u=d.pending;u===null?l.next=l:(l.next=u.next,u.next=l),d.pending=l}}s.lanes|=n,l=s.alternate,l!==null&&(l.lanes|=n),F0(s.return,n,t),o.lanes|=n;break}l=l.next}}else if(s.tag===10)i=s.type===t.type?null:s.child;else if(s.tag===18){if(i=s.return,i===null)throw Error(de(341));i.lanes|=n,o=i.alternate,o!==null&&(o.lanes|=n),F0(i,n,t),i=s.sibling}else i=s.child;if(i!==null)i.return=s;else for(i=s;i!==null;){if(i===t){i=null;break}if(s=i.sibling,s!==null){s.return=i.return,i=s;break}i=i.return}s=i}or(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,r=t.pendingProps.children,Id(t,n),a=ga(a),r=r(a),t.flags|=1,or(e,t,r,n),t.child;case 14:return r=t.type,a=Ca(r,t.pendingProps),a=Ca(r.type,a),jC(e,t,r,a,n);case 15:return oA(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:Ca(r,a),Ag(e,t),t.tag=1,$r(r)?(e=!0,ry(t)):e=!1,Id(t,n),aA(t,r,a),M0(t,r,a,n),L0(null,t,r,!0,e,n);case 19:return pA(e,t,n);case 22:return lA(e,t,n)}throw Error(de(156,t.tag))};function EA(e,t){return t$(e,t)}function IV(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ha(e,t,n,r){return new IV(e,t,n,r)}function rk(e){return e=e.prototype,!(!e||!e.isReactComponent)}function NV(e){if(typeof e=="function")return rk(e)?1:0;if(e!=null){if(e=e.$$typeof,e===k1)return 11;if(e===S1)return 14}return 2}function Ni(e,t){var n=e.alternate;return n===null?(n=ha(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Dg(e,t,n,r,a,s){var i=2;if(r=e,typeof e=="function")rk(e)&&(i=1);else if(typeof e=="string")i=5;else e:switch(e){case od:return Lo(n.children,a,s,t);case w1:i=8,a|=8;break;case s0:return e=ha(12,n,t,a|2),e.elementType=s0,e.lanes=s,e;case i0:return e=ha(13,n,t,a),e.elementType=i0,e.lanes=s,e;case o0:return e=ha(19,n,t,a),e.elementType=o0,e.lanes=s,e;case L_:return ub(n,a,s,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case O_:i=10;break e;case P_:i=9;break e;case k1:i=11;break e;case S1:i=14;break e;case ai:i=16,r=null;break e}throw Error(de(130,e==null?e:typeof e,""))}return t=ha(i,n,t,a),t.elementType=e,t.type=r,t.lanes=s,t}function Lo(e,t,n,r){return e=ha(7,e,r,t),e.lanes=n,e}function ub(e,t,n,r){return e=ha(22,e,r,t),e.elementType=L_,e.lanes=n,e.stateNode={isHidden:!1},e}function Ex(e,t,n){return e=ha(6,e,null,t),e.lanes=n,e}function _x(e,t,n){return t=ha(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function CV(e,t,n,r,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=ux(0),this.expirationTimes=ux(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=ux(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function ak(e,t,n,r,a,s,i,o,l){return e=new CV(e,t,n,o,l),t===1?(t=1,s===!0&&(t|=8)):t=0,s=ha(3,null,null,t),e.current=s,s.stateNode=e,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},W1(s),e}function TV(e,t,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:id,key:r==null?null:""+r,children:e,containerInfo:t,implementation:n}}function _A(e){if(!e)return Ai;e=e._reactInternals;e:{if(bl(e)!==e||e.tag!==1)throw Error(de(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if($r(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(de(171))}if(e.tag===1){var n=e.type;if($r(n))return _$(e,n,t)}return t}function $A(e,t,n,r,a,s,i,o,l){return e=ak(n,r,!0,e,a,s,i,o,l),e.context=_A(null),n=e.current,r=dr(),a=Ii(n),s=$s(r,a),s.callback=t??null,ki(n,s,a),e.current.lanes=a,pf(e,a,r),Ar(e,r),e}function db(e,t,n,r){var a=t.current,s=dr(),i=Ii(a);return n=_A(n),t.context===null?t.context=n:t.pendingContext=n,t=$s(s,i),t.payload={element:e},r=r===void 0?null:r,r!==null&&(t.callback=r),e=ki(a,t,i),e!==null&&(Aa(e,a,i,s),Eg(e,a,i)),i}function gy(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function nT(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function sk(e,t){nT(e,t),(e=e.alternate)&&nT(e,t)}function EV(){return null}var AA=typeof reportError=="function"?reportError:function(e){console.error(e)};function ik(e){this._internalRoot=e}cb.prototype.render=ik.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(de(409));db(e,t,null,null)};cb.prototype.unmount=ik.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Ko(function(){db(null,e,null,null)}),t[Ms]=null}};function cb(e){this._internalRoot=e}cb.prototype.unstable_scheduleHydration=function(e){if(e){var t=l$();e={blockedOn:null,target:e,priority:t};for(var n=0;n<li.length&&t!==0&&t<li[n].priority;n++);li.splice(n,0,e),n===0&&d$(e)}};function ok(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function pb(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function rT(){}function _V(e,t,n,r,a){if(a){if(typeof r=="function"){var s=r;r=function(){var d=gy(i);s.call(d)}}var i=$A(t,r,e,0,null,!1,!1,"",rT);return e._reactRootContainer=i,e[Ms]=i.current,Mh(e.nodeType===8?e.parentNode:e),Ko(),i}for(;a=e.lastChild;)e.removeChild(a);if(typeof r=="function"){var o=r;r=function(){var d=gy(l);o.call(d)}}var l=ak(e,0,!1,null,null,!1,!1,"",rT);return e._reactRootContainer=l,e[Ms]=l.current,Mh(e.nodeType===8?e.parentNode:e),Ko(function(){db(t,l,n,r)}),l}function hb(e,t,n,r,a){var s=n._reactRootContainer;if(s){var i=s;if(typeof a=="function"){var o=a;a=function(){var l=gy(i);o.call(l)}}db(t,i,e,a)}else i=_V(n,t,e,a,r);return gy(i)}i$=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=th(t.pendingLanes);n!==0&&(C1(t,n|1),Ar(t,Qt()),!(st&6)&&(Pd=Qt()+500,Xi()))}break;case 13:Ko(function(){var r=Os(e,1);if(r!==null){var a=dr();Aa(r,e,1,a)}}),sk(e,1)}};T1=function(e){if(e.tag===13){var t=Os(e,134217728);if(t!==null){var n=dr();Aa(t,e,134217728,n)}sk(e,134217728)}};o$=function(e){if(e.tag===13){var t=Ii(e),n=Os(e,t);if(n!==null){var r=dr();Aa(n,e,t,r)}sk(e,t)}};l$=function(){return mt};u$=function(e,t){var n=mt;try{return mt=e,t()}finally{mt=n}};y0=function(e,t,n){switch(t){case"input":if(d0(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=rb(r);if(!a)throw Error(de(90));B_(r),d0(r,a)}}}break;case"textarea":U_(e,n);break;case"select":t=n.value,t!=null&&xd(e,!!n.multiple,t,!1)}};X_=ek;Q_=Ko;var $V={usingClientEntryPoint:!1,Events:[ff,cd,rb,q_,K_,ek]},Gp={findFiberByHostInstance:Ao,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},AV={bundleType:Gp.bundleType,version:Gp.version,rendererPackageName:Gp.rendererPackageName,rendererConfig:Gp.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Bs.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=Y_(e),e===null?null:e.stateNode},findFiberByHostInstance:Gp.findFiberByHostInstance||EV,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var rg=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rg.isDisabled&&rg.supportsFiber)try{Yy=rg.inject(AV),as=rg}catch{}}ra.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=$V;ra.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!ok(t))throw Error(de(200));return TV(e,t,null,n)};ra.createRoot=function(e,t){if(!ok(e))throw Error(de(299));var n=!1,r="",a=AA;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onRecoverableError!==void 0&&(a=t.onRecoverableError)),t=ak(e,1,!1,null,null,n,!1,r,a),e[Ms]=t.current,Mh(e.nodeType===8?e.parentNode:e),new ik(t)};ra.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(de(188)):(e=Object.keys(e).join(","),Error(de(268,e)));return e=Y_(t),e=e===null?null:e.stateNode,e};ra.flushSync=function(e){return Ko(e)};ra.hydrate=function(e,t,n){if(!pb(t))throw Error(de(200));return hb(null,e,t,!0,n)};ra.hydrateRoot=function(e,t,n){if(!ok(e))throw Error(de(405));var r=n!=null&&n.hydratedSources||null,a=!1,s="",i=AA;if(n!=null&&(n.unstable_strictMode===!0&&(a=!0),n.identifierPrefix!==void 0&&(s=n.identifierPrefix),n.onRecoverableError!==void 0&&(i=n.onRecoverableError)),t=$A(t,null,e,1,n??null,a,!1,s,i),e[Ms]=t.current,Mh(e),r)for(e=0;e<r.length;e++)n=r[e],a=n._getVersion,a=a(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new cb(t)};ra.render=function(e,t,n){if(!pb(t))throw Error(de(200));return hb(null,e,t,!1,n)};ra.unmountComponentAtNode=function(e){if(!pb(e))throw Error(de(40));return e._reactRootContainer?(Ko(function(){hb(null,null,e,!1,function(){e._reactRootContainer=null,e[Ms]=null})}),!0):!1};ra.unstable_batchedUpdates=ek;ra.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!pb(n))throw Error(de(200));if(e==null||e._reactInternals===void 0)throw Error(de(38));return hb(e,t,n,!1,r)};ra.version="18.3.1-next-f1338f8080-20240426";function RA(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(RA)}catch(e){console.error(e)}}RA(),R_.exports=ra;var RV=R_.exports,aT=RV;r0.createRoot=aT.createRoot,r0.hydrateRoot=aT.hydrateRoot;/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function jh(){return jh=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},jh.apply(this,arguments)}var hi;(function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"})(hi||(hi={}));const sT="popstate";function FV(e){e===void 0&&(e={});function t(r,a){let{pathname:s,search:i,hash:o}=r.location;return Q0("",{pathname:s,search:i,hash:o},a.state&&a.state.usr||null,a.state&&a.state.key||"default")}function n(r,a){return typeof a=="string"?a:yy(a)}return MV(t,n,null,e)}function Zt(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function FA(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}function DV(){return Math.random().toString(36).substr(2,8)}function iT(e,t){return{usr:e.state,key:e.key,idx:t}}function Q0(e,t,n,r){return n===void 0&&(n=null),jh({pathname:typeof e=="string"?e:e.pathname,search:"",hash:""},typeof t=="string"?ic(t):t,{state:n,key:t&&t.key||r||DV()})}function yy(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&n!=="?"&&(t+=n.charAt(0)==="?"?n:"?"+n),r&&r!=="#"&&(t+=r.charAt(0)==="#"?r:"#"+r),t}function ic(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function MV(e,t,n,r){r===void 0&&(r={});let{window:a=document.defaultView,v5Compat:s=!1}=r,i=a.history,o=hi.Pop,l=null,d=u();d==null&&(d=0,i.replaceState(jh({},i.state,{idx:d}),""));function u(){return(i.state||{idx:null}).idx}function c(){o=hi.Pop;let g=u(),y=g==null?null:g-d;d=g,l&&l({action:o,location:m.location,delta:y})}function p(g,y){o=hi.Push;let b=Q0(m.location,g,y);d=u()+1;let v=iT(b,d),x=m.createHref(b);try{i.pushState(v,"",x)}catch(w){if(w instanceof DOMException&&w.name==="DataCloneError")throw w;a.location.assign(x)}s&&l&&l({action:o,location:m.location,delta:1})}function h(g,y){o=hi.Replace;let b=Q0(m.location,g,y);d=u();let v=iT(b,d),x=m.createHref(b);i.replaceState(v,"",x),s&&l&&l({action:o,location:m.location,delta:0})}function f(g){let y=a.location.origin!=="null"?a.location.origin:a.location.href,b=typeof g=="string"?g:yy(g);return b=b.replace(/ $/,"%20"),Zt(y,"No window.location.(origin|href) available to create URL for href: "+b),new URL(b,y)}let m={get action(){return o},get location(){return e(a,i)},listen(g){if(l)throw new Error("A history only accepts one active listener");return a.addEventListener(sT,c),l=g,()=>{a.removeEventListener(sT,c),l=null}},createHref(g){return t(a,g)},createURL:f,encodeLocation(g){let y=f(g);return{pathname:y.pathname,search:y.search,hash:y.hash}},push:p,replace:h,go(g){return i.go(g)}};return m}var oT;(function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"})(oT||(oT={}));function OV(e,t,n){return n===void 0&&(n="/"),PV(e,t,n)}function PV(e,t,n,r){let a=typeof t=="string"?ic(t):t,s=lk(a.pathname||"/",n);if(s==null)return null;let i=DA(e);LV(i);let o=null;for(let l=0;o==null&&l<i.length;++l){let d=QV(s);o=qV(i[l],d)}return o}function DA(e,t,n,r){t===void 0&&(t=[]),n===void 0&&(n=[]),r===void 0&&(r="");let a=(s,i,o)=>{let l={relativePath:o===void 0?s.path||"":o,caseSensitive:s.caseSensitive===!0,childrenIndex:i,route:s};l.relativePath.startsWith("/")&&(Zt(l.relativePath.startsWith(r),'Absolute route path "'+l.relativePath+'" nested under path '+('"'+r+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),l.relativePath=l.relativePath.slice(r.length));let d=Ci([r,l.relativePath]),u=n.concat(l);s.children&&s.children.length>0&&(Zt(s.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+d+'".')),DA(s.children,t,u,d)),!(s.path==null&&!s.index)&&t.push({path:d,score:HV(d,s.index),routesMeta:u})};return e.forEach((s,i)=>{var o;if(s.path===""||!((o=s.path)!=null&&o.includes("?")))a(s,i);else for(let l of MA(s.path))a(s,i,l)}),t}function MA(e){let t=e.split("/");if(t.length===0)return[];let[n,...r]=t,a=n.endsWith("?"),s=n.replace(/\?$/,"");if(r.length===0)return a?[s,""]:[s];let i=MA(r.join("/")),o=[];return o.push(...i.map(l=>l===""?s:[s,l].join("/"))),a&&o.push(...i),o.map(l=>e.startsWith("/")&&l===""?"/":l)}function LV(e){e.sort((t,n)=>t.score!==n.score?n.score-t.score:GV(t.routesMeta.map(r=>r.childrenIndex),n.routesMeta.map(r=>r.childrenIndex)))}const zV=/^:[\w-]+$/,BV=3,WV=2,UV=1,VV=10,jV=-2,lT=e=>e==="*";function HV(e,t){let n=e.split("/"),r=n.length;return n.some(lT)&&(r+=jV),t&&(r+=WV),n.filter(a=>!lT(a)).reduce((a,s)=>a+(zV.test(s)?BV:s===""?UV:VV),r)}function GV(e,t){return e.length===t.length&&e.slice(0,-1).every((r,a)=>r===t[a])?e[e.length-1]-t[t.length-1]:0}function qV(e,t,n){let{routesMeta:r}=e,a={},s="/",i=[];for(let o=0;o<r.length;++o){let l=r[o],d=o===r.length-1,u=s==="/"?t:t.slice(s.length)||"/",c=KV({path:l.relativePath,caseSensitive:l.caseSensitive,end:d},u),p=l.route;if(!c)return null;Object.assign(a,c.params),i.push({params:a,pathname:Ci([s,c.pathname]),pathnameBase:ej(Ci([s,c.pathnameBase])),route:p}),c.pathnameBase!=="/"&&(s=Ci([s,c.pathnameBase]))}return i}function KV(e,t){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=XV(e.path,e.caseSensitive,e.end),a=t.match(n);if(!a)return null;let s=a[0],i=s.replace(/(.)\/+$/,"$1"),o=a.slice(1);return{params:r.reduce((d,u,c)=>{let{paramName:p,isOptional:h}=u;if(p==="*"){let m=o[c]||"";i=s.slice(0,s.length-m.length).replace(/(.)\/+$/,"$1")}const f=o[c];return h&&!f?d[p]=void 0:d[p]=(f||"").replace(/%2F/g,"/"),d},{}),pathname:s,pathnameBase:i,pattern:e}}function XV(e,t,n){t===void 0&&(t=!1),n===void 0&&(n=!0),FA(e==="*"||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were '+('"'+e.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+e.replace(/\*$/,"/*")+'".'));let r=[],a="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(i,o,l)=>(r.push({paramName:o,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return e.endsWith("*")?(r.push({paramName:"*"}),a+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":e!==""&&e!=="/"&&(a+="(?:(?=\\/|$))"),[new RegExp(a,t?void 0:"i"),r]}function QV(e){try{return e.split("/").map(t=>decodeURIComponent(t).replace(/\//g,"%2F")).join("/")}catch(t){return FA(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+t+").")),e}}function lk(e,t){if(t==="/")return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&r!=="/"?null:e.slice(n)||"/"}function JV(e,t){t===void 0&&(t="/");let{pathname:n,search:r="",hash:a=""}=typeof e=="string"?ic(e):e;return{pathname:n?n.startsWith("/")?n:ZV(n,t):t,search:tj(r),hash:nj(a)}}function ZV(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(a=>{a===".."?n.length>1&&n.pop():a!=="."&&n.push(a)}),n.length>1?n.join("/"):"/"}function $x(e,t,n,r){return"Cannot include a '"+e+"' character in a manually specified "+("`to."+t+"` field ["+JSON.stringify(r)+"].  Please separate it out to the ")+("`to."+n+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function YV(e){return e.filter((t,n)=>n===0||t.route.path&&t.route.path.length>0)}function uk(e,t){let n=YV(e);return t?n.map((r,a)=>a===n.length-1?r.pathname:r.pathnameBase):n.map(r=>r.pathnameBase)}function dk(e,t,n,r){r===void 0&&(r=!1);let a;typeof e=="string"?a=ic(e):(a=jh({},e),Zt(!a.pathname||!a.pathname.includes("?"),$x("?","pathname","search",a)),Zt(!a.pathname||!a.pathname.includes("#"),$x("#","pathname","hash",a)),Zt(!a.search||!a.search.includes("#"),$x("#","search","hash",a)));let s=e===""||a.pathname==="",i=s?"/":a.pathname,o;if(i==null)o=n;else{let c=t.length-1;if(!r&&i.startsWith("..")){let p=i.split("/");for(;p[0]==="..";)p.shift(),c-=1;a.pathname=p.join("/")}o=c>=0?t[c]:"/"}let l=JV(a,o),d=i&&i!=="/"&&i.endsWith("/"),u=(s||i===".")&&n.endsWith("/");return!l.pathname.endsWith("/")&&(d||u)&&(l.pathname+="/"),l}const Ci=e=>e.join("/").replace(/\/\/+/g,"/"),ej=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),tj=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,nj=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e;function rj(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}const OA=["post","put","patch","delete"];new Set(OA);const aj=["get",...OA];new Set(aj);/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Hh(){return Hh=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Hh.apply(this,arguments)}const ck=Y.createContext(null),sj=Y.createContext(null),Qi=Y.createContext(null),fb=Y.createContext(null),Ji=Y.createContext({outlet:null,matches:[],isDataRoute:!1}),PA=Y.createContext(null);function ij(e,t){let{relative:n}=t===void 0?{}:t;oc()||Zt(!1);let{basename:r,navigator:a}=Y.useContext(Qi),{hash:s,pathname:i,search:o}=zA(e,{relative:n}),l=i;return r!=="/"&&(l=i==="/"?r:Ci([r,i])),a.createHref({pathname:l,search:o,hash:s})}function oc(){return Y.useContext(fb)!=null}function hs(){return oc()||Zt(!1),Y.useContext(fb).location}function LA(e){Y.useContext(Qi).static||Y.useLayoutEffect(e)}function gf(){let{isDataRoute:e}=Y.useContext(Ji);return e?vj():oj()}function oj(){oc()||Zt(!1);let e=Y.useContext(ck),{basename:t,future:n,navigator:r}=Y.useContext(Qi),{matches:a}=Y.useContext(Ji),{pathname:s}=hs(),i=JSON.stringify(uk(a,n.v7_relativeSplatPath)),o=Y.useRef(!1);return LA(()=>{o.current=!0}),Y.useCallback(function(d,u){if(u===void 0&&(u={}),!o.current)return;if(typeof d=="number"){r.go(d);return}let c=dk(d,JSON.parse(i),s,u.relative==="path");e==null&&t!=="/"&&(c.pathname=c.pathname==="/"?t:Ci([t,c.pathname])),(u.replace?r.replace:r.push)(c,u.state,u)},[t,r,i,s,e])}function zA(e,t){let{relative:n}=t===void 0?{}:t,{future:r}=Y.useContext(Qi),{matches:a}=Y.useContext(Ji),{pathname:s}=hs(),i=JSON.stringify(uk(a,r.v7_relativeSplatPath));return Y.useMemo(()=>dk(e,JSON.parse(i),s,n==="path"),[e,i,s,n])}function lj(e,t){return uj(e,t)}function uj(e,t,n,r){oc()||Zt(!1);let{navigator:a}=Y.useContext(Qi),{matches:s}=Y.useContext(Ji),i=s[s.length-1],o=i?i.params:{};i&&i.pathname;let l=i?i.pathnameBase:"/";i&&i.route;let d=hs(),u;if(t){var c;let g=typeof t=="string"?ic(t):t;l==="/"||(c=g.pathname)!=null&&c.startsWith(l)||Zt(!1),u=g}else u=d;let p=u.pathname||"/",h=p;if(l!=="/"){let g=l.replace(/^\//,"").split("/");h="/"+p.replace(/^\//,"").split("/").slice(g.length).join("/")}let f=OV(e,{pathname:h}),m=fj(f&&f.map(g=>Object.assign({},g,{params:Object.assign({},o,g.params),pathname:Ci([l,a.encodeLocation?a.encodeLocation(g.pathname).pathname:g.pathname]),pathnameBase:g.pathnameBase==="/"?l:Ci([l,a.encodeLocation?a.encodeLocation(g.pathnameBase).pathname:g.pathnameBase])})),s,n,r);return t&&m?Y.createElement(fb.Provider,{value:{location:Hh({pathname:"/",search:"",hash:"",state:null,key:"default"},u),navigationType:hi.Pop}},m):m}function dj(){let e=bj(),t=rj(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,a={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return Y.createElement(Y.Fragment,null,Y.createElement("h2",null,"Unexpected Application Error!"),Y.createElement("h3",{style:{fontStyle:"italic"}},t),n?Y.createElement("pre",{style:a},n):null,null)}const cj=Y.createElement(dj,null);class pj extends Y.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,n){return n.location!==t.location||n.revalidation!=="idle"&&t.revalidation==="idle"?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:t.error!==void 0?t.error:n.error,location:n.location,revalidation:t.revalidation||n.revalidation}}componentDidCatch(t,n){console.error("React Router caught the following error during render",t,n)}render(){return this.state.error!==void 0?Y.createElement(Ji.Provider,{value:this.props.routeContext},Y.createElement(PA.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function hj(e){let{routeContext:t,match:n,children:r}=e,a=Y.useContext(ck);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),Y.createElement(Ji.Provider,{value:t},r)}function fj(e,t,n,r){var a;if(t===void 0&&(t=[]),n===void 0&&(n=null),r===void 0&&(r=null),e==null){var s;if(!n)return null;if(n.errors)e=n.matches;else if((s=r)!=null&&s.v7_partialHydration&&t.length===0&&!n.initialized&&n.matches.length>0)e=n.matches;else return null}let i=e,o=(a=n)==null?void 0:a.errors;if(o!=null){let u=i.findIndex(c=>c.route.id&&(o==null?void 0:o[c.route.id])!==void 0);u>=0||Zt(!1),i=i.slice(0,Math.min(i.length,u+1))}let l=!1,d=-1;if(n&&r&&r.v7_partialHydration)for(let u=0;u<i.length;u++){let c=i[u];if((c.route.HydrateFallback||c.route.hydrateFallbackElement)&&(d=u),c.route.id){let{loaderData:p,errors:h}=n,f=c.route.loader&&p[c.route.id]===void 0&&(!h||h[c.route.id]===void 0);if(c.route.lazy||f){l=!0,d>=0?i=i.slice(0,d+1):i=[i[0]];break}}}return i.reduceRight((u,c,p)=>{let h,f=!1,m=null,g=null;n&&(h=o&&c.route.id?o[c.route.id]:void 0,m=c.route.errorElement||cj,l&&(d<0&&p===0?(xj("route-fallback"),f=!0,g=null):d===p&&(f=!0,g=c.route.hydrateFallbackElement||null)));let y=t.concat(i.slice(0,p+1)),b=()=>{let v;return h?v=m:f?v=g:c.route.Component?v=Y.createElement(c.route.Component,null):c.route.element?v=c.route.element:v=u,Y.createElement(hj,{match:c,routeContext:{outlet:u,matches:y,isDataRoute:n!=null},children:v})};return n&&(c.route.ErrorBoundary||c.route.errorElement||p===0)?Y.createElement(pj,{location:n.location,revalidation:n.revalidation,component:m,error:h,children:b(),routeContext:{outlet:null,matches:y,isDataRoute:!0}}):b()},null)}var BA=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(BA||{}),WA=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(WA||{});function mj(e){let t=Y.useContext(ck);return t||Zt(!1),t}function gj(e){let t=Y.useContext(sj);return t||Zt(!1),t}function yj(e){let t=Y.useContext(Ji);return t||Zt(!1),t}function UA(e){let t=yj(),n=t.matches[t.matches.length-1];return n.route.id||Zt(!1),n.route.id}function bj(){var e;let t=Y.useContext(PA),n=gj(),r=UA();return t!==void 0?t:(e=n.errors)==null?void 0:e[r]}function vj(){let{router:e}=mj(BA.UseNavigateStable),t=UA(WA.UseNavigateStable),n=Y.useRef(!1);return LA(()=>{n.current=!0}),Y.useCallback(function(a,s){s===void 0&&(s={}),n.current&&(typeof a=="number"?e.navigate(a):e.navigate(a,Hh({fromRouteId:t},s)))},[e,t])}const uT={};function xj(e,t,n){uT[e]||(uT[e]=!0)}function wj(e,t){e==null||e.v7_startTransition,e==null||e.v7_relativeSplatPath}function dT(e){let{to:t,replace:n,state:r,relative:a}=e;oc()||Zt(!1);let{future:s,static:i}=Y.useContext(Qi),{matches:o}=Y.useContext(Ji),{pathname:l}=hs(),d=gf(),u=dk(t,uk(o,s.v7_relativeSplatPath),l,a==="path"),c=JSON.stringify(u);return Y.useEffect(()=>d(JSON.parse(c),{replace:n,state:r,relative:a}),[d,c,a,n,r]),null}function ko(e){Zt(!1)}function kj(e){let{basename:t="/",children:n=null,location:r,navigationType:a=hi.Pop,navigator:s,static:i=!1,future:o}=e;oc()&&Zt(!1);let l=t.replace(/^\/*/,"/"),d=Y.useMemo(()=>({basename:l,navigator:s,static:i,future:Hh({v7_relativeSplatPath:!1},o)}),[l,o,s,i]);typeof r=="string"&&(r=ic(r));let{pathname:u="/",search:c="",hash:p="",state:h=null,key:f="default"}=r,m=Y.useMemo(()=>{let g=lk(u,l);return g==null?null:{location:{pathname:g,search:c,hash:p,state:h,key:f},navigationType:a}},[l,u,c,p,h,f,a]);return m==null?null:Y.createElement(Qi.Provider,{value:d},Y.createElement(fb.Provider,{children:n,value:m}))}function Sj(e){let{children:t,location:n}=e;return lj(J0(t),n)}new Promise(()=>{});function J0(e,t){t===void 0&&(t=[]);let n=[];return Y.Children.forEach(e,(r,a)=>{if(!Y.isValidElement(r))return;let s=[...t,a];if(r.type===Y.Fragment){n.push.apply(n,J0(r.props.children,s));return}r.type!==ko&&Zt(!1),!r.props.index||!r.props.children||Zt(!1);let i={id:r.props.id||s.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,loader:r.props.loader,action:r.props.action,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:r.props.ErrorBoundary!=null||r.props.errorElement!=null,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(i.children=J0(r.props.children,s)),n.push(i)}),n}/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Z0(){return Z0=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Z0.apply(this,arguments)}function Ij(e,t){if(e==null)return{};var n={},r=Object.keys(e),a,s;for(s=0;s<r.length;s++)a=r[s],!(t.indexOf(a)>=0)&&(n[a]=e[a]);return n}function Nj(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function Cj(e,t){return e.button===0&&(!t||t==="_self")&&!Nj(e)}function Y0(e){return e===void 0&&(e=""),new URLSearchParams(typeof e=="string"||Array.isArray(e)||e instanceof URLSearchParams?e:Object.keys(e).reduce((t,n)=>{let r=e[n];return t.concat(Array.isArray(r)?r.map(a=>[n,a]):[[n,r]])},[]))}function Tj(e,t){let n=Y0(e);return t&&t.forEach((r,a)=>{n.has(a)||t.getAll(a).forEach(s=>{n.append(a,s)})}),n}const Ej=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"],_j="6";try{window.__reactRouterVersion=_j}catch{}const $j="startTransition",cT=wW[$j];function Aj(e){let{basename:t,children:n,future:r,window:a}=e,s=Y.useRef();s.current==null&&(s.current=FV({window:a,v5Compat:!0}));let i=s.current,[o,l]=Y.useState({action:i.action,location:i.location}),{v7_startTransition:d}=r||{},u=Y.useCallback(c=>{d&&cT?cT(()=>l(c)):l(c)},[l,d]);return Y.useLayoutEffect(()=>i.listen(u),[i,u]),Y.useEffect(()=>wj(r),[r]),Y.createElement(kj,{basename:t,children:n,location:o.location,navigationType:o.action,navigator:i,future:r})}const Rj=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",Fj=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Ax=Y.forwardRef(function(t,n){let{onClick:r,relative:a,reloadDocument:s,replace:i,state:o,target:l,to:d,preventScrollReset:u,viewTransition:c}=t,p=Ij(t,Ej),{basename:h}=Y.useContext(Qi),f,m=!1;if(typeof d=="string"&&Fj.test(d)&&(f=d,Rj))try{let v=new URL(window.location.href),x=d.startsWith("//")?new URL(v.protocol+d):new URL(d),w=lk(x.pathname,h);x.origin===v.origin&&w!=null?d=w+x.search+x.hash:m=!0}catch{}let g=ij(d,{relative:a}),y=Dj(d,{replace:i,state:o,target:l,preventScrollReset:u,relative:a,viewTransition:c});function b(v){r&&r(v),v.defaultPrevented||y(v)}return Y.createElement("a",Z0({},p,{href:f||g,onClick:m||s?r:b,ref:n,target:l}))});var pT;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(pT||(pT={}));var hT;(function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"})(hT||(hT={}));function Dj(e,t){let{target:n,replace:r,state:a,preventScrollReset:s,relative:i,viewTransition:o}=t===void 0?{}:t,l=gf(),d=hs(),u=zA(e,{relative:i});return Y.useCallback(c=>{if(Cj(c,n)){c.preventDefault();let p=r!==void 0?r:yy(d)===yy(u);l(e,{replace:p,state:a,preventScrollReset:s,relative:i,viewTransition:o})}},[d,l,u,r,a,n,e,s,i,o])}function Mj(e){let t=Y.useRef(Y0(e)),n=Y.useRef(!1),r=hs(),a=Y.useMemo(()=>Tj(r.search,n.current?null:t.current),[r.search]),s=gf(),i=Y.useCallback((o,l)=>{const d=Y0(typeof o=="function"?o(a):o);n.current=!0,s("?"+d,l)},[s,a]);return[a,i]}function VA(e,t){return function(){return e.apply(t,arguments)}}const{toString:Oj}=Object.prototype,{getPrototypeOf:pk}=Object,{iterator:mb,toStringTag:jA}=Symbol,gb=(e=>t=>{const n=Oj.call(t);return e[n]||(e[n]=n.slice(8,-1).toLowerCase())})(Object.create(null)),Wa=e=>(e=e.toLowerCase(),t=>gb(t)===e),yb=e=>t=>typeof t===e,{isArray:lc}=Array,Ld=yb("undefined");function yf(e){return e!==null&&!Ld(e)&&e.constructor!==null&&!Ld(e.constructor)&&Rr(e.constructor.isBuffer)&&e.constructor.isBuffer(e)}const HA=Wa("ArrayBuffer");function Pj(e){let t;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?t=ArrayBuffer.isView(e):t=e&&e.buffer&&HA(e.buffer),t}const Lj=yb("string"),Rr=yb("function"),GA=yb("number"),bf=e=>e!==null&&typeof e=="object",zj=e=>e===!0||e===!1,Mg=e=>{if(gb(e)!=="object")return!1;const t=pk(e);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(jA in e)&&!(mb in e)},Bj=e=>{if(!bf(e)||yf(e))return!1;try{return Object.keys(e).length===0&&Object.getPrototypeOf(e)===Object.prototype}catch{return!1}},Wj=Wa("Date"),Uj=Wa("File"),Vj=Wa("Blob"),jj=Wa("FileList"),Hj=e=>bf(e)&&Rr(e.pipe),Gj=e=>{let t;return e&&(typeof FormData=="function"&&e instanceof FormData||Rr(e.append)&&((t=gb(e))==="formdata"||t==="object"&&Rr(e.toString)&&e.toString()==="[object FormData]"))},qj=Wa("URLSearchParams"),[Kj,Xj,Qj,Jj]=["ReadableStream","Request","Response","Headers"].map(Wa),Zj=e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function vf(e,t,{allOwnKeys:n=!1}={}){if(e===null||typeof e>"u")return;let r,a;if(typeof e!="object"&&(e=[e]),lc(e))for(r=0,a=e.length;r<a;r++)t.call(null,e[r],r,e);else{if(yf(e))return;const s=n?Object.getOwnPropertyNames(e):Object.keys(e),i=s.length;let o;for(r=0;r<i;r++)o=s[r],t.call(null,e[o],o,e)}}function qA(e,t){if(yf(e))return null;t=t.toLowerCase();const n=Object.keys(e);let r=n.length,a;for(;r-- >0;)if(a=n[r],t===a.toLowerCase())return a;return null}const Do=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:global,KA=e=>!Ld(e)&&e!==Do;function ew(){const{caseless:e,skipUndefined:t}=KA(this)&&this||{},n={},r=(a,s)=>{const i=e&&qA(n,s)||s;Mg(n[i])&&Mg(a)?n[i]=ew(n[i],a):Mg(a)?n[i]=ew({},a):lc(a)?n[i]=a.slice():(!t||!Ld(a))&&(n[i]=a)};for(let a=0,s=arguments.length;a<s;a++)arguments[a]&&vf(arguments[a],r);return n}const Yj=(e,t,n,{allOwnKeys:r}={})=>(vf(t,(a,s)=>{n&&Rr(a)?e[s]=VA(a,n):e[s]=a},{allOwnKeys:r}),e),e5=e=>(e.charCodeAt(0)===65279&&(e=e.slice(1)),e),t5=(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},n5=(e,t,n,r)=>{let a,s,i;const o={};if(t=t||{},e==null)return t;do{for(a=Object.getOwnPropertyNames(e),s=a.length;s-- >0;)i=a[s],(!r||r(i,e,t))&&!o[i]&&(t[i]=e[i],o[i]=!0);e=n!==!1&&pk(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},r5=(e,t,n)=>{e=String(e),(n===void 0||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return r!==-1&&r===n},a5=e=>{if(!e)return null;if(lc(e))return e;let t=e.length;if(!GA(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},s5=(e=>t=>e&&t instanceof e)(typeof Uint8Array<"u"&&pk(Uint8Array)),i5=(e,t)=>{const r=(e&&e[mb]).call(e);let a;for(;(a=r.next())&&!a.done;){const s=a.value;t.call(e,s[0],s[1])}},o5=(e,t)=>{let n;const r=[];for(;(n=e.exec(t))!==null;)r.push(n);return r},l5=Wa("HTMLFormElement"),u5=e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,function(n,r,a){return r.toUpperCase()+a}),fT=(({hasOwnProperty:e})=>(t,n)=>e.call(t,n))(Object.prototype),d5=Wa("RegExp"),XA=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};vf(n,(a,s)=>{let i;(i=t(a,s,e))!==!1&&(r[s]=i||a)}),Object.defineProperties(e,r)},c5=e=>{XA(e,(t,n)=>{if(Rr(e)&&["arguments","caller","callee"].indexOf(n)!==-1)return!1;const r=e[n];if(Rr(r)){if(t.enumerable=!1,"writable"in t){t.writable=!1;return}t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")})}})},p5=(e,t)=>{const n={},r=a=>{a.forEach(s=>{n[s]=!0})};return lc(e)?r(e):r(String(e).split(t)),n},h5=()=>{},f5=(e,t)=>e!=null&&Number.isFinite(e=+e)?e:t;function m5(e){return!!(e&&Rr(e.append)&&e[jA]==="FormData"&&e[mb])}const g5=e=>{const t=new Array(10),n=(r,a)=>{if(bf(r)){if(t.indexOf(r)>=0)return;if(yf(r))return r;if(!("toJSON"in r)){t[a]=r;const s=lc(r)?[]:{};return vf(r,(i,o)=>{const l=n(i,a+1);!Ld(l)&&(s[o]=l)}),t[a]=void 0,s}}return r};return n(e,0)},y5=Wa("AsyncFunction"),b5=e=>e&&(bf(e)||Rr(e))&&Rr(e.then)&&Rr(e.catch),QA=((e,t)=>e?setImmediate:t?((n,r)=>(Do.addEventListener("message",({source:a,data:s})=>{a===Do&&s===n&&r.length&&r.shift()()},!1),a=>{r.push(a),Do.postMessage(n,"*")}))(`axios@${Math.random()}`,[]):n=>setTimeout(n))(typeof setImmediate=="function",Rr(Do.postMessage)),v5=typeof queueMicrotask<"u"?queueMicrotask.bind(Do):typeof process<"u"&&process.nextTick||QA,x5=e=>e!=null&&Rr(e[mb]),ee={isArray:lc,isArrayBuffer:HA,isBuffer:yf,isFormData:Gj,isArrayBufferView:Pj,isString:Lj,isNumber:GA,isBoolean:zj,isObject:bf,isPlainObject:Mg,isEmptyObject:Bj,isReadableStream:Kj,isRequest:Xj,isResponse:Qj,isHeaders:Jj,isUndefined:Ld,isDate:Wj,isFile:Uj,isBlob:Vj,isRegExp:d5,isFunction:Rr,isStream:Hj,isURLSearchParams:qj,isTypedArray:s5,isFileList:jj,forEach:vf,merge:ew,extend:Yj,trim:Zj,stripBOM:e5,inherits:t5,toFlatObject:n5,kindOf:gb,kindOfTest:Wa,endsWith:r5,toArray:a5,forEachEntry:i5,matchAll:o5,isHTMLForm:l5,hasOwnProperty:fT,hasOwnProp:fT,reduceDescriptors:XA,freezeMethods:c5,toObjectSet:p5,toCamelCase:u5,noop:h5,toFiniteNumber:f5,findKey:qA,global:Do,isContextDefined:KA,isSpecCompliantForm:m5,toJSONObject:g5,isAsyncFn:y5,isThenable:b5,setImmediate:QA,asap:v5,isIterable:x5};function je(e,t,n,r,a){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),a&&(this.response=a,this.status=a.status?a.status:null)}ee.inherits(je,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:ee.toJSONObject(this.config),code:this.code,status:this.status}}});const JA=je.prototype,ZA={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(e=>{ZA[e]={value:e}});Object.defineProperties(je,ZA);Object.defineProperty(JA,"isAxiosError",{value:!0});je.from=(e,t,n,r,a,s)=>{const i=Object.create(JA);ee.toFlatObject(e,i,function(u){return u!==Error.prototype},d=>d!=="isAxiosError");const o=e&&e.message?e.message:"Error",l=t==null&&e?e.code:t;return je.call(i,o,l,n,r,a),e&&i.cause==null&&Object.defineProperty(i,"cause",{value:e,configurable:!0}),i.name=e&&e.name||"Error",s&&Object.assign(i,s),i};const w5=null;function tw(e){return ee.isPlainObject(e)||ee.isArray(e)}function YA(e){return ee.endsWith(e,"[]")?e.slice(0,-2):e}function mT(e,t,n){return e?e.concat(t).map(function(a,s){return a=YA(a),!n&&s?"["+a+"]":a}).join(n?".":""):t}function k5(e){return ee.isArray(e)&&!e.some(tw)}const S5=ee.toFlatObject(ee,{},null,function(t){return/^is[A-Z]/.test(t)});function bb(e,t,n){if(!ee.isObject(e))throw new TypeError("target must be an object");t=t||new FormData,n=ee.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,function(m,g){return!ee.isUndefined(g[m])});const r=n.metaTokens,a=n.visitor||u,s=n.dots,i=n.indexes,l=(n.Blob||typeof Blob<"u"&&Blob)&&ee.isSpecCompliantForm(t);if(!ee.isFunction(a))throw new TypeError("visitor must be a function");function d(f){if(f===null)return"";if(ee.isDate(f))return f.toISOString();if(ee.isBoolean(f))return f.toString();if(!l&&ee.isBlob(f))throw new je("Blob is not supported. Use a Buffer instead.");return ee.isArrayBuffer(f)||ee.isTypedArray(f)?l&&typeof Blob=="function"?new Blob([f]):Buffer.from(f):f}function u(f,m,g){let y=f;if(f&&!g&&typeof f=="object"){if(ee.endsWith(m,"{}"))m=r?m:m.slice(0,-2),f=JSON.stringify(f);else if(ee.isArray(f)&&k5(f)||(ee.isFileList(f)||ee.endsWith(m,"[]"))&&(y=ee.toArray(f)))return m=YA(m),y.forEach(function(v,x){!(ee.isUndefined(v)||v===null)&&t.append(i===!0?mT([m],x,s):i===null?m:m+"[]",d(v))}),!1}return tw(f)?!0:(t.append(mT(g,m,s),d(f)),!1)}const c=[],p=Object.assign(S5,{defaultVisitor:u,convertValue:d,isVisitable:tw});function h(f,m){if(!ee.isUndefined(f)){if(c.indexOf(f)!==-1)throw Error("Circular reference detected in "+m.join("."));c.push(f),ee.forEach(f,function(y,b){(!(ee.isUndefined(y)||y===null)&&a.call(t,y,ee.isString(b)?b.trim():b,m,p))===!0&&h(y,m?m.concat(b):[b])}),c.pop()}}if(!ee.isObject(e))throw new TypeError("data must be an object");return h(e),t}function gT(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,function(r){return t[r]})}function hk(e,t){this._pairs=[],e&&bb(e,this,t)}const eR=hk.prototype;eR.append=function(t,n){this._pairs.push([t,n])};eR.toString=function(t){const n=t?function(r){return t.call(this,r,gT)}:gT;return this._pairs.map(function(a){return n(a[0])+"="+n(a[1])},"").join("&")};function I5(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+")}function tR(e,t,n){if(!t)return e;const r=n&&n.encode||I5;ee.isFunction(n)&&(n={serialize:n});const a=n&&n.serialize;let s;if(a?s=a(t,n):s=ee.isURLSearchParams(t)?t.toString():new hk(t,n).toString(r),s){const i=e.indexOf("#");i!==-1&&(e=e.slice(0,i)),e+=(e.indexOf("?")===-1?"?":"&")+s}return e}class yT{constructor(){this.handlers=[]}use(t,n,r){return this.handlers.push({fulfilled:t,rejected:n,synchronous:r?r.synchronous:!1,runWhen:r?r.runWhen:null}),this.handlers.length-1}eject(t){this.handlers[t]&&(this.handlers[t]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(t){ee.forEach(this.handlers,function(r){r!==null&&t(r)})}}const nR={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},N5=typeof URLSearchParams<"u"?URLSearchParams:hk,C5=typeof FormData<"u"?FormData:null,T5=typeof Blob<"u"?Blob:null,E5={isBrowser:!0,classes:{URLSearchParams:N5,FormData:C5,Blob:T5},protocols:["http","https","file","blob","url","data"]},fk=typeof window<"u"&&typeof document<"u",nw=typeof navigator=="object"&&navigator||void 0,_5=fk&&(!nw||["ReactNative","NativeScript","NS"].indexOf(nw.product)<0),$5=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&typeof self.importScripts=="function",A5=fk&&window.location.href||"http://localhost",R5=Object.freeze(Object.defineProperty({__proto__:null,hasBrowserEnv:fk,hasStandardBrowserEnv:_5,hasStandardBrowserWebWorkerEnv:$5,navigator:nw,origin:A5},Symbol.toStringTag,{value:"Module"})),Hn={...R5,...E5};function F5(e,t){return bb(e,new Hn.classes.URLSearchParams,{visitor:function(n,r,a,s){return Hn.isNode&&ee.isBuffer(n)?(this.append(r,n.toString("base64")),!1):s.defaultVisitor.apply(this,arguments)},...t})}function D5(e){return ee.matchAll(/\w+|\[(\w*)]/g,e).map(t=>t[0]==="[]"?"":t[1]||t[0])}function M5(e){const t={},n=Object.keys(e);let r;const a=n.length;let s;for(r=0;r<a;r++)s=n[r],t[s]=e[s];return t}function rR(e){function t(n,r,a,s){let i=n[s++];if(i==="__proto__")return!0;const o=Number.isFinite(+i),l=s>=n.length;return i=!i&&ee.isArray(a)?a.length:i,l?(ee.hasOwnProp(a,i)?a[i]=[a[i],r]:a[i]=r,!o):((!a[i]||!ee.isObject(a[i]))&&(a[i]=[]),t(n,r,a[i],s)&&ee.isArray(a[i])&&(a[i]=M5(a[i])),!o)}if(ee.isFormData(e)&&ee.isFunction(e.entries)){const n={};return ee.forEachEntry(e,(r,a)=>{t(D5(r),a,n,0)}),n}return null}function O5(e,t,n){if(ee.isString(e))try{return(t||JSON.parse)(e),ee.trim(e)}catch(r){if(r.name!=="SyntaxError")throw r}return(n||JSON.stringify)(e)}const xf={transitional:nR,adapter:["xhr","http","fetch"],transformRequest:[function(t,n){const r=n.getContentType()||"",a=r.indexOf("application/json")>-1,s=ee.isObject(t);if(s&&ee.isHTMLForm(t)&&(t=new FormData(t)),ee.isFormData(t))return a?JSON.stringify(rR(t)):t;if(ee.isArrayBuffer(t)||ee.isBuffer(t)||ee.isStream(t)||ee.isFile(t)||ee.isBlob(t)||ee.isReadableStream(t))return t;if(ee.isArrayBufferView(t))return t.buffer;if(ee.isURLSearchParams(t))return n.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),t.toString();let o;if(s){if(r.indexOf("application/x-www-form-urlencoded")>-1)return F5(t,this.formSerializer).toString();if((o=ee.isFileList(t))||r.indexOf("multipart/form-data")>-1){const l=this.env&&this.env.FormData;return bb(o?{"files[]":t}:t,l&&new l,this.formSerializer)}}return s||a?(n.setContentType("application/json",!1),O5(t)):t}],transformResponse:[function(t){const n=this.transitional||xf.transitional,r=n&&n.forcedJSONParsing,a=this.responseType==="json";if(ee.isResponse(t)||ee.isReadableStream(t))return t;if(t&&ee.isString(t)&&(r&&!this.responseType||a)){const i=!(n&&n.silentJSONParsing)&&a;try{return JSON.parse(t,this.parseReviver)}catch(o){if(i)throw o.name==="SyntaxError"?je.from(o,je.ERR_BAD_RESPONSE,this,null,this.response):o}}return t}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:Hn.classes.FormData,Blob:Hn.classes.Blob},validateStatus:function(t){return t>=200&&t<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};ee.forEach(["delete","get","head","post","put","patch"],e=>{xf.headers[e]={}});const P5=ee.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),L5=e=>{const t={};let n,r,a;return e&&e.split(`
`).forEach(function(i){a=i.indexOf(":"),n=i.substring(0,a).trim().toLowerCase(),r=i.substring(a+1).trim(),!(!n||t[n]&&P5[n])&&(n==="set-cookie"?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)}),t},bT=Symbol("internals");function qp(e){return e&&String(e).trim().toLowerCase()}function Og(e){return e===!1||e==null?e:ee.isArray(e)?e.map(Og):String(e)}function z5(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}const B5=e=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());function Rx(e,t,n,r,a){if(ee.isFunction(r))return r.call(this,t,n);if(a&&(t=n),!!ee.isString(t)){if(ee.isString(r))return t.indexOf(r)!==-1;if(ee.isRegExp(r))return r.test(t)}}function W5(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(t,n,r)=>n.toUpperCase()+r)}function U5(e,t){const n=ee.toCamelCase(" "+t);["get","set","has"].forEach(r=>{Object.defineProperty(e,r+n,{value:function(a,s,i){return this[r].call(this,t,a,s,i)},configurable:!0})})}let Fr=class{constructor(t){t&&this.set(t)}set(t,n,r){const a=this;function s(o,l,d){const u=qp(l);if(!u)throw new Error("header name must be a non-empty string");const c=ee.findKey(a,u);(!c||a[c]===void 0||d===!0||d===void 0&&a[c]!==!1)&&(a[c||l]=Og(o))}const i=(o,l)=>ee.forEach(o,(d,u)=>s(d,u,l));if(ee.isPlainObject(t)||t instanceof this.constructor)i(t,n);else if(ee.isString(t)&&(t=t.trim())&&!B5(t))i(L5(t),n);else if(ee.isObject(t)&&ee.isIterable(t)){let o={},l,d;for(const u of t){if(!ee.isArray(u))throw TypeError("Object iterator must return a key-value pair");o[d=u[0]]=(l=o[d])?ee.isArray(l)?[...l,u[1]]:[l,u[1]]:u[1]}i(o,n)}else t!=null&&s(n,t,r);return this}get(t,n){if(t=qp(t),t){const r=ee.findKey(this,t);if(r){const a=this[r];if(!n)return a;if(n===!0)return z5(a);if(ee.isFunction(n))return n.call(this,a,r);if(ee.isRegExp(n))return n.exec(a);throw new TypeError("parser must be boolean|regexp|function")}}}has(t,n){if(t=qp(t),t){const r=ee.findKey(this,t);return!!(r&&this[r]!==void 0&&(!n||Rx(this,this[r],r,n)))}return!1}delete(t,n){const r=this;let a=!1;function s(i){if(i=qp(i),i){const o=ee.findKey(r,i);o&&(!n||Rx(r,r[o],o,n))&&(delete r[o],a=!0)}}return ee.isArray(t)?t.forEach(s):s(t),a}clear(t){const n=Object.keys(this);let r=n.length,a=!1;for(;r--;){const s=n[r];(!t||Rx(this,this[s],s,t,!0))&&(delete this[s],a=!0)}return a}normalize(t){const n=this,r={};return ee.forEach(this,(a,s)=>{const i=ee.findKey(r,s);if(i){n[i]=Og(a),delete n[s];return}const o=t?W5(s):String(s).trim();o!==s&&delete n[s],n[o]=Og(a),r[o]=!0}),this}concat(...t){return this.constructor.concat(this,...t)}toJSON(t){const n=Object.create(null);return ee.forEach(this,(r,a)=>{r!=null&&r!==!1&&(n[a]=t&&ee.isArray(r)?r.join(", "):r)}),n}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([t,n])=>t+": "+n).join(`
`)}getSetCookie(){return this.get("set-cookie")||[]}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(t){return t instanceof this?t:new this(t)}static concat(t,...n){const r=new this(t);return n.forEach(a=>r.set(a)),r}static accessor(t){const r=(this[bT]=this[bT]={accessors:{}}).accessors,a=this.prototype;function s(i){const o=qp(i);r[o]||(U5(a,i),r[o]=!0)}return ee.isArray(t)?t.forEach(s):s(t),this}};Fr.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]);ee.reduceDescriptors(Fr.prototype,({value:e},t)=>{let n=t[0].toUpperCase()+t.slice(1);return{get:()=>e,set(r){this[n]=r}}});ee.freezeMethods(Fr);function Fx(e,t){const n=this||xf,r=t||n,a=Fr.from(r.headers);let s=r.data;return ee.forEach(e,function(o){s=o.call(n,s,a.normalize(),t?t.status:void 0)}),a.normalize(),s}function aR(e){return!!(e&&e.__CANCEL__)}function uc(e,t,n){je.call(this,e??"canceled",je.ERR_CANCELED,t,n),this.name="CanceledError"}ee.inherits(uc,je,{__CANCEL__:!0});function sR(e,t,n){const r=n.config.validateStatus;!n.status||!r||r(n.status)?e(n):t(new je("Request failed with status code "+n.status,[je.ERR_BAD_REQUEST,je.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n))}function V5(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}function j5(e,t){e=e||10;const n=new Array(e),r=new Array(e);let a=0,s=0,i;return t=t!==void 0?t:1e3,function(l){const d=Date.now(),u=r[s];i||(i=d),n[a]=l,r[a]=d;let c=s,p=0;for(;c!==a;)p+=n[c++],c=c%e;if(a=(a+1)%e,a===s&&(s=(s+1)%e),d-i<t)return;const h=u&&d-u;return h?Math.round(p*1e3/h):void 0}}function H5(e,t){let n=0,r=1e3/t,a,s;const i=(d,u=Date.now())=>{n=u,a=null,s&&(clearTimeout(s),s=null),e(...d)};return[(...d)=>{const u=Date.now(),c=u-n;c>=r?i(d,u):(a=d,s||(s=setTimeout(()=>{s=null,i(a)},r-c)))},()=>a&&i(a)]}const by=(e,t,n=3)=>{let r=0;const a=j5(50,250);return H5(s=>{const i=s.loaded,o=s.lengthComputable?s.total:void 0,l=i-r,d=a(l),u=i<=o;r=i;const c={loaded:i,total:o,progress:o?i/o:void 0,bytes:l,rate:d||void 0,estimated:d&&o&&u?(o-i)/d:void 0,event:s,lengthComputable:o!=null,[t?"download":"upload"]:!0};e(c)},n)},vT=(e,t)=>{const n=e!=null;return[r=>t[0]({lengthComputable:n,total:e,loaded:r}),t[1]]},xT=e=>(...t)=>ee.asap(()=>e(...t)),G5=Hn.hasStandardBrowserEnv?((e,t)=>n=>(n=new URL(n,Hn.origin),e.protocol===n.protocol&&e.host===n.host&&(t||e.port===n.port)))(new URL(Hn.origin),Hn.navigator&&/(msie|trident)/i.test(Hn.navigator.userAgent)):()=>!0,q5=Hn.hasStandardBrowserEnv?{write(e,t,n,r,a,s){const i=[e+"="+encodeURIComponent(t)];ee.isNumber(n)&&i.push("expires="+new Date(n).toGMTString()),ee.isString(r)&&i.push("path="+r),ee.isString(a)&&i.push("domain="+a),s===!0&&i.push("secure"),document.cookie=i.join("; ")},read(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove(e){this.write(e,"",Date.now()-864e5)}}:{write(){},read(){return null},remove(){}};function K5(e){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)}function X5(e,t){return t?e.replace(/\/?\/$/,"")+"/"+t.replace(/^\/+/,""):e}function iR(e,t,n){let r=!K5(t);return e&&(r||n==!1)?X5(e,t):t}const wT=e=>e instanceof Fr?{...e}:e;function Xo(e,t){t=t||{};const n={};function r(d,u,c,p){return ee.isPlainObject(d)&&ee.isPlainObject(u)?ee.merge.call({caseless:p},d,u):ee.isPlainObject(u)?ee.merge({},u):ee.isArray(u)?u.slice():u}function a(d,u,c,p){if(ee.isUndefined(u)){if(!ee.isUndefined(d))return r(void 0,d,c,p)}else return r(d,u,c,p)}function s(d,u){if(!ee.isUndefined(u))return r(void 0,u)}function i(d,u){if(ee.isUndefined(u)){if(!ee.isUndefined(d))return r(void 0,d)}else return r(void 0,u)}function o(d,u,c){if(c in t)return r(d,u);if(c in e)return r(void 0,d)}const l={url:s,method:s,data:s,baseURL:i,transformRequest:i,transformResponse:i,paramsSerializer:i,timeout:i,timeoutMessage:i,withCredentials:i,withXSRFToken:i,adapter:i,responseType:i,xsrfCookieName:i,xsrfHeaderName:i,onUploadProgress:i,onDownloadProgress:i,decompress:i,maxContentLength:i,maxBodyLength:i,beforeRedirect:i,transport:i,httpAgent:i,httpsAgent:i,cancelToken:i,socketPath:i,responseEncoding:i,validateStatus:o,headers:(d,u,c)=>a(wT(d),wT(u),c,!0)};return ee.forEach(Object.keys({...e,...t}),function(u){const c=l[u]||a,p=c(e[u],t[u],u);ee.isUndefined(p)&&c!==o||(n[u]=p)}),n}const oR=e=>{const t=Xo({},e);let{data:n,withXSRFToken:r,xsrfHeaderName:a,xsrfCookieName:s,headers:i,auth:o}=t;if(t.headers=i=Fr.from(i),t.url=tR(iR(t.baseURL,t.url,t.allowAbsoluteUrls),e.params,e.paramsSerializer),o&&i.set("Authorization","Basic "+btoa((o.username||"")+":"+(o.password?unescape(encodeURIComponent(o.password)):""))),ee.isFormData(n)){if(Hn.hasStandardBrowserEnv||Hn.hasStandardBrowserWebWorkerEnv)i.setContentType(void 0);else if(ee.isFunction(n.getHeaders)){const l=n.getHeaders(),d=["content-type","content-length"];Object.entries(l).forEach(([u,c])=>{d.includes(u.toLowerCase())&&i.set(u,c)})}}if(Hn.hasStandardBrowserEnv&&(r&&ee.isFunction(r)&&(r=r(t)),r||r!==!1&&G5(t.url))){const l=a&&s&&q5.read(s);l&&i.set(a,l)}return t},Q5=typeof XMLHttpRequest<"u",J5=Q5&&function(e){return new Promise(function(n,r){const a=oR(e);let s=a.data;const i=Fr.from(a.headers).normalize();let{responseType:o,onUploadProgress:l,onDownloadProgress:d}=a,u,c,p,h,f;function m(){h&&h(),f&&f(),a.cancelToken&&a.cancelToken.unsubscribe(u),a.signal&&a.signal.removeEventListener("abort",u)}let g=new XMLHttpRequest;g.open(a.method.toUpperCase(),a.url,!0),g.timeout=a.timeout;function y(){if(!g)return;const v=Fr.from("getAllResponseHeaders"in g&&g.getAllResponseHeaders()),w={data:!o||o==="text"||o==="json"?g.responseText:g.response,status:g.status,statusText:g.statusText,headers:v,config:e,request:g};sR(function(N){n(N),m()},function(N){r(N),m()},w),g=null}"onloadend"in g?g.onloadend=y:g.onreadystatechange=function(){!g||g.readyState!==4||g.status===0&&!(g.responseURL&&g.responseURL.indexOf("file:")===0)||setTimeout(y)},g.onabort=function(){g&&(r(new je("Request aborted",je.ECONNABORTED,e,g)),g=null)},g.onerror=function(x){const w=x&&x.message?x.message:"Network Error",I=new je(w,je.ERR_NETWORK,e,g);I.event=x||null,r(I),g=null},g.ontimeout=function(){let x=a.timeout?"timeout of "+a.timeout+"ms exceeded":"timeout exceeded";const w=a.transitional||nR;a.timeoutErrorMessage&&(x=a.timeoutErrorMessage),r(new je(x,w.clarifyTimeoutError?je.ETIMEDOUT:je.ECONNABORTED,e,g)),g=null},s===void 0&&i.setContentType(null),"setRequestHeader"in g&&ee.forEach(i.toJSON(),function(x,w){g.setRequestHeader(w,x)}),ee.isUndefined(a.withCredentials)||(g.withCredentials=!!a.withCredentials),o&&o!=="json"&&(g.responseType=a.responseType),d&&([p,f]=by(d,!0),g.addEventListener("progress",p)),l&&g.upload&&([c,h]=by(l),g.upload.addEventListener("progress",c),g.upload.addEventListener("loadend",h)),(a.cancelToken||a.signal)&&(u=v=>{g&&(r(!v||v.type?new uc(null,e,g):v),g.abort(),g=null)},a.cancelToken&&a.cancelToken.subscribe(u),a.signal&&(a.signal.aborted?u():a.signal.addEventListener("abort",u)));const b=V5(a.url);if(b&&Hn.protocols.indexOf(b)===-1){r(new je("Unsupported protocol "+b+":",je.ERR_BAD_REQUEST,e));return}g.send(s||null)})},Z5=(e,t)=>{const{length:n}=e=e?e.filter(Boolean):[];if(t||n){let r=new AbortController,a;const s=function(d){if(!a){a=!0,o();const u=d instanceof Error?d:this.reason;r.abort(u instanceof je?u:new uc(u instanceof Error?u.message:u))}};let i=t&&setTimeout(()=>{i=null,s(new je(`timeout ${t} of ms exceeded`,je.ETIMEDOUT))},t);const o=()=>{e&&(i&&clearTimeout(i),i=null,e.forEach(d=>{d.unsubscribe?d.unsubscribe(s):d.removeEventListener("abort",s)}),e=null)};e.forEach(d=>d.addEventListener("abort",s));const{signal:l}=r;return l.unsubscribe=()=>ee.asap(o),l}},Y5=function*(e,t){let n=e.byteLength;if(n<t){yield e;return}let r=0,a;for(;r<n;)a=r+t,yield e.slice(r,a),r=a},e6=async function*(e,t){for await(const n of t6(e))yield*Y5(n,t)},t6=async function*(e){if(e[Symbol.asyncIterator]){yield*e;return}const t=e.getReader();try{for(;;){const{done:n,value:r}=await t.read();if(n)break;yield r}}finally{await t.cancel()}},kT=(e,t,n,r)=>{const a=e6(e,t);let s=0,i,o=l=>{i||(i=!0,r&&r(l))};return new ReadableStream({async pull(l){try{const{done:d,value:u}=await a.next();if(d){o(),l.close();return}let c=u.byteLength;if(n){let p=s+=c;n(p)}l.enqueue(new Uint8Array(u))}catch(d){throw o(d),d}},cancel(l){return o(l),a.return()}},{highWaterMark:2})},ST=64*1024,{isFunction:ag}=ee,n6=(({Request:e,Response:t})=>({Request:e,Response:t}))(ee.global),{ReadableStream:IT,TextEncoder:NT}=ee.global,CT=(e,...t)=>{try{return!!e(...t)}catch{return!1}},r6=e=>{e=ee.merge.call({skipUndefined:!0},n6,e);const{fetch:t,Request:n,Response:r}=e,a=t?ag(t):typeof fetch=="function",s=ag(n),i=ag(r);if(!a)return!1;const o=a&&ag(IT),l=a&&(typeof NT=="function"?(f=>m=>f.encode(m))(new NT):async f=>new Uint8Array(await new n(f).arrayBuffer())),d=s&&o&&CT(()=>{let f=!1;const m=new n(Hn.origin,{body:new IT,method:"POST",get duplex(){return f=!0,"half"}}).headers.has("Content-Type");return f&&!m}),u=i&&o&&CT(()=>ee.isReadableStream(new r("").body)),c={stream:u&&(f=>f.body)};a&&["text","arrayBuffer","blob","formData","stream"].forEach(f=>{!c[f]&&(c[f]=(m,g)=>{let y=m&&m[f];if(y)return y.call(m);throw new je(`Response type '${f}' is not supported`,je.ERR_NOT_SUPPORT,g)})});const p=async f=>{if(f==null)return 0;if(ee.isBlob(f))return f.size;if(ee.isSpecCompliantForm(f))return(await new n(Hn.origin,{method:"POST",body:f}).arrayBuffer()).byteLength;if(ee.isArrayBufferView(f)||ee.isArrayBuffer(f))return f.byteLength;if(ee.isURLSearchParams(f)&&(f=f+""),ee.isString(f))return(await l(f)).byteLength},h=async(f,m)=>{const g=ee.toFiniteNumber(f.getContentLength());return g??p(m)};return async f=>{let{url:m,method:g,data:y,signal:b,cancelToken:v,timeout:x,onDownloadProgress:w,onUploadProgress:I,responseType:N,headers:T,withCredentials:A="same-origin",fetchOptions:R}=oR(f),F=t||fetch;N=N?(N+"").toLowerCase():"text";let C=Z5([b,v&&v.toAbortSignal()],x),M=null;const B=C&&C.unsubscribe&&(()=>{C.unsubscribe()});let U;try{if(I&&d&&g!=="get"&&g!=="head"&&(U=await h(T,y))!==0){let J=new n(m,{method:"POST",body:y,duplex:"half"}),re;if(ee.isFormData(y)&&(re=J.headers.get("content-type"))&&T.setContentType(re),J.body){const[ae,ie]=vT(U,by(xT(I)));y=kT(J.body,ST,ae,ie)}}ee.isString(A)||(A=A?"include":"omit");const G=s&&"credentials"in n.prototype,X={...R,signal:C,method:g.toUpperCase(),headers:T.normalize().toJSON(),body:y,duplex:"half",credentials:G?A:void 0};M=s&&new n(m,X);let P=await(s?F(M,R):F(m,X));const q=u&&(N==="stream"||N==="response");if(u&&(w||q&&B)){const J={};["status","statusText","headers"].forEach(le=>{J[le]=P[le]});const re=ee.toFiniteNumber(P.headers.get("content-length")),[ae,ie]=w&&vT(re,by(xT(w),!0))||[];P=new r(kT(P.body,ST,ae,()=>{ie&&ie(),B&&B()}),J)}N=N||"text";let Q=await c[ee.findKey(c,N)||"text"](P,f);return!q&&B&&B(),await new Promise((J,re)=>{sR(J,re,{data:Q,headers:Fr.from(P.headers),status:P.status,statusText:P.statusText,config:f,request:M})})}catch(G){throw B&&B(),G&&G.name==="TypeError"&&/Load failed|fetch/i.test(G.message)?Object.assign(new je("Network Error",je.ERR_NETWORK,f,M),{cause:G.cause||G}):je.from(G,G&&G.code,f,M)}}},a6=new Map,lR=e=>{let t=e?e.env:{};const{fetch:n,Request:r,Response:a}=t,s=[r,a,n];let i=s.length,o=i,l,d,u=a6;for(;o--;)l=s[o],d=u.get(l),d===void 0&&u.set(l,d=o?new Map:r6(t)),u=d;return d};lR();const rw={http:w5,xhr:J5,fetch:{get:lR}};ee.forEach(rw,(e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch{}Object.defineProperty(e,"adapterName",{value:t})}});const TT=e=>`- ${e}`,s6=e=>ee.isFunction(e)||e===null||e===!1,uR={getAdapter:(e,t)=>{e=ee.isArray(e)?e:[e];const{length:n}=e;let r,a;const s={};for(let i=0;i<n;i++){r=e[i];let o;if(a=r,!s6(r)&&(a=rw[(o=String(r)).toLowerCase()],a===void 0))throw new je(`Unknown adapter '${o}'`);if(a&&(ee.isFunction(a)||(a=a.get(t))))break;s[o||"#"+i]=a}if(!a){const i=Object.entries(s).map(([l,d])=>`adapter ${l} `+(d===!1?"is not supported by the environment":"is not available in the build"));let o=n?i.length>1?`since :
`+i.map(TT).join(`
`):" "+TT(i[0]):"as no adapter specified";throw new je("There is no suitable adapter to dispatch the request "+o,"ERR_NOT_SUPPORT")}return a},adapters:rw};function Dx(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new uc(null,e)}function ET(e){return Dx(e),e.headers=Fr.from(e.headers),e.data=Fx.call(e,e.transformRequest),["post","put","patch"].indexOf(e.method)!==-1&&e.headers.setContentType("application/x-www-form-urlencoded",!1),uR.getAdapter(e.adapter||xf.adapter,e)(e).then(function(r){return Dx(e),r.data=Fx.call(e,e.transformResponse,r),r.headers=Fr.from(r.headers),r},function(r){return aR(r)||(Dx(e),r&&r.response&&(r.response.data=Fx.call(e,e.transformResponse,r.response),r.response.headers=Fr.from(r.response.headers))),Promise.reject(r)})}const dR="1.12.2",vb={};["object","boolean","number","function","string","symbol"].forEach((e,t)=>{vb[e]=function(r){return typeof r===e||"a"+(t<1?"n ":" ")+e}});const _T={};vb.transitional=function(t,n,r){function a(s,i){return"[Axios v"+dR+"] Transitional option '"+s+"'"+i+(r?". "+r:"")}return(s,i,o)=>{if(t===!1)throw new je(a(i," has been removed"+(n?" in "+n:"")),je.ERR_DEPRECATED);return n&&!_T[i]&&(_T[i]=!0,console.warn(a(i," has been deprecated since v"+n+" and will be removed in the near future"))),t?t(s,i,o):!0}};vb.spelling=function(t){return(n,r)=>(console.warn(`${r} is likely a misspelling of ${t}`),!0)};function i6(e,t,n){if(typeof e!="object")throw new je("options must be an object",je.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let a=r.length;for(;a-- >0;){const s=r[a],i=t[s];if(i){const o=e[s],l=o===void 0||i(o,s,e);if(l!==!0)throw new je("option "+s+" must be "+l,je.ERR_BAD_OPTION_VALUE);continue}if(n!==!0)throw new je("Unknown option "+s,je.ERR_BAD_OPTION)}}const Pg={assertOptions:i6,validators:vb},Ga=Pg.validators;let zo=class{constructor(t){this.defaults=t||{},this.interceptors={request:new yT,response:new yT}}async request(t,n){try{return await this._request(t,n)}catch(r){if(r instanceof Error){let a={};Error.captureStackTrace?Error.captureStackTrace(a):a=new Error;const s=a.stack?a.stack.replace(/^.+\n/,""):"";try{r.stack?s&&!String(r.stack).endsWith(s.replace(/^.+\n.+\n/,""))&&(r.stack+=`
`+s):r.stack=s}catch{}}throw r}}_request(t,n){typeof t=="string"?(n=n||{},n.url=t):n=t||{},n=Xo(this.defaults,n);const{transitional:r,paramsSerializer:a,headers:s}=n;r!==void 0&&Pg.assertOptions(r,{silentJSONParsing:Ga.transitional(Ga.boolean),forcedJSONParsing:Ga.transitional(Ga.boolean),clarifyTimeoutError:Ga.transitional(Ga.boolean)},!1),a!=null&&(ee.isFunction(a)?n.paramsSerializer={serialize:a}:Pg.assertOptions(a,{encode:Ga.function,serialize:Ga.function},!0)),n.allowAbsoluteUrls!==void 0||(this.defaults.allowAbsoluteUrls!==void 0?n.allowAbsoluteUrls=this.defaults.allowAbsoluteUrls:n.allowAbsoluteUrls=!0),Pg.assertOptions(n,{baseUrl:Ga.spelling("baseURL"),withXsrfToken:Ga.spelling("withXSRFToken")},!0),n.method=(n.method||this.defaults.method||"get").toLowerCase();let i=s&&ee.merge(s.common,s[n.method]);s&&ee.forEach(["delete","get","head","post","put","patch","common"],f=>{delete s[f]}),n.headers=Fr.concat(i,s);const o=[];let l=!0;this.interceptors.request.forEach(function(m){typeof m.runWhen=="function"&&m.runWhen(n)===!1||(l=l&&m.synchronous,o.unshift(m.fulfilled,m.rejected))});const d=[];this.interceptors.response.forEach(function(m){d.push(m.fulfilled,m.rejected)});let u,c=0,p;if(!l){const f=[ET.bind(this),void 0];for(f.unshift(...o),f.push(...d),p=f.length,u=Promise.resolve(n);c<p;)u=u.then(f[c++],f[c++]);return u}p=o.length;let h=n;for(;c<p;){const f=o[c++],m=o[c++];try{h=f(h)}catch(g){m.call(this,g);break}}try{u=ET.call(this,h)}catch(f){return Promise.reject(f)}for(c=0,p=d.length;c<p;)u=u.then(d[c++],d[c++]);return u}getUri(t){t=Xo(this.defaults,t);const n=iR(t.baseURL,t.url,t.allowAbsoluteUrls);return tR(n,t.params,t.paramsSerializer)}};ee.forEach(["delete","get","head","options"],function(t){zo.prototype[t]=function(n,r){return this.request(Xo(r||{},{method:t,url:n,data:(r||{}).data}))}});ee.forEach(["post","put","patch"],function(t){function n(r){return function(s,i,o){return this.request(Xo(o||{},{method:t,headers:r?{"Content-Type":"multipart/form-data"}:{},url:s,data:i}))}}zo.prototype[t]=n(),zo.prototype[t+"Form"]=n(!0)});let o6=class cR{constructor(t){if(typeof t!="function")throw new TypeError("executor must be a function.");let n;this.promise=new Promise(function(s){n=s});const r=this;this.promise.then(a=>{if(!r._listeners)return;let s=r._listeners.length;for(;s-- >0;)r._listeners[s](a);r._listeners=null}),this.promise.then=a=>{let s;const i=new Promise(o=>{r.subscribe(o),s=o}).then(a);return i.cancel=function(){r.unsubscribe(s)},i},t(function(s,i,o){r.reason||(r.reason=new uc(s,i,o),n(r.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(t){if(this.reason){t(this.reason);return}this._listeners?this._listeners.push(t):this._listeners=[t]}unsubscribe(t){if(!this._listeners)return;const n=this._listeners.indexOf(t);n!==-1&&this._listeners.splice(n,1)}toAbortSignal(){const t=new AbortController,n=r=>{t.abort(r)};return this.subscribe(n),t.signal.unsubscribe=()=>this.unsubscribe(n),t.signal}static source(){let t;return{token:new cR(function(a){t=a}),cancel:t}}};function l6(e){return function(n){return e.apply(null,n)}}function u6(e){return ee.isObject(e)&&e.isAxiosError===!0}const aw={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(aw).forEach(([e,t])=>{aw[t]=e});function pR(e){const t=new zo(e),n=VA(zo.prototype.request,t);return ee.extend(n,zo.prototype,t,{allOwnKeys:!0}),ee.extend(n,t,null,{allOwnKeys:!0}),n.create=function(a){return pR(Xo(e,a))},n}const Wt=pR(xf);Wt.Axios=zo;Wt.CanceledError=uc;Wt.CancelToken=o6;Wt.isCancel=aR;Wt.VERSION=dR;Wt.toFormData=bb;Wt.AxiosError=je;Wt.Cancel=Wt.CanceledError;Wt.all=function(t){return Promise.all(t)};Wt.spread=l6;Wt.isAxiosError=u6;Wt.mergeConfig=Xo;Wt.AxiosHeaders=Fr;Wt.formToJSON=e=>rR(ee.isHTMLForm(e)?new FormData(e):e);Wt.getAdapter=uR.getAdapter;Wt.HttpStatusCode=aw;Wt.default=Wt;const{Axios:AEe,AxiosError:REe,CanceledError:FEe,isCancel:DEe,CancelToken:MEe,VERSION:OEe,all:PEe,Cancel:LEe,isAxiosError:zEe,spread:BEe,toFormData:WEe,AxiosHeaders:UEe,HttpStatusCode:VEe,formToJSON:jEe,getAdapter:HEe,mergeConfig:GEe}=Wt,Kn=Wt.create({baseURL:"/api",withCredentials:!0,headers:{"Content-Type":"application/json"}});Kn.interceptors.request.use(e=>{const t=sessionStorage.getItem("mobile_jwt");return t&&(e.headers.Authorization=`Bearer ${t}`),e},e=>Promise.reject(e));const hR=Y.createContext();function d6({children:e}){const[t,n]=Y.useState(null),[r,a]=Y.useState(!0);Y.useEffect(()=>{let d=!0;return console.log("AuthContext: Checking authentication..."),Kn.get("/auth/me").then(u=>{console.log("AuthContext: User authenticated",u.data.user),d&&n(u.data.user)}).catch(u=>{var c,p;console.log("AuthContext: Not authenticated",(c=u.response)==null?void 0:c.status,(p=u.response)==null?void 0:p.data),d&&n(null)}).finally(()=>{d&&(a(!1),console.log("AuthContext: Loading complete"))}),()=>{d=!1}},[]);const l={user:t,loading:r,login:async d=>{const u=await Kn.post("/auth/login",d);return n(u.data.user),u.data.user},register:async d=>{const u=await Kn.post("/auth/register",d);return n(u.data.user),u.data.user},logout:async()=>{await Kn.post("/auth/logout"),n(null)},setUser:n};return $.jsx(hR.Provider,{value:l,children:e})}function xb(){const e=Y.useContext(hR);if(!e)throw new Error("useAuth must be used within AuthProvider");return e}function Mx({children:e,allow:t=[]}){const{user:n,loading:r}=xb(),a=hs();return r?$.jsx("div",{style:{display:"grid",placeItems:"center",height:"100vh",color:"#6b7280"},children:"Загрузка..."}):n?t.length>0&&!t.includes(n.role)?$.jsx(dT,{to:"/",replace:!0}):e:$.jsx(dT,{to:"/login",state:{from:a},replace:!0})}class c6 extends Y.Component{constructor(t){super(t),this.state={hasError:!1,error:null,errorInfo:null}}static getDerivedStateFromError(t){return{hasError:!0}}componentDidCatch(t,n){console.error("[ErrorBoundary] Caught error:",t),console.error("[ErrorBoundary] Error info:",n),this.setState({error:t,errorInfo:n})}render(){return this.state.hasError?$.jsx("div",{style:{minHeight:"100vh",display:"flex",alignItems:"center",justifyContent:"center",padding:"2rem",background:"linear-gradient(135deg, #667eea 0%, #764ba2 100%)"},children:$.jsxs("div",{style:{background:"#fff",borderRadius:"16px",padding:"2rem",maxWidth:"500px",width:"100%"},children:[$.jsx("h2",{style:{color:"#dc2626",marginBottom:"1rem"},children:"⚠️ Произошла ошибка"}),$.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"1rem"},children:"Что-то пошло не так. Пожалуйста, попробуйте перезагрузить страницу."}),this.state.error&&$.jsxs("div",{style:{background:"rgba(239, 68, 68, 0.1)",padding:"1rem",borderRadius:"8px",marginBottom:"1rem",fontSize:"0.85rem",color:"#dc2626",wordBreak:"break-all"},children:[$.jsx("strong",{children:"Ошибка:"})," ",this.state.error.toString()]}),this.state.errorInfo&&$.jsxs("details",{style:{fontSize:"0.75rem",color:"var(--text-tertiary)",marginBottom:"1rem"},children:[$.jsx("summary",{children:"Технические детали"}),$.jsx("pre",{style:{marginTop:"0.5rem",padding:"0.5rem",background:"#f3f4f6",borderRadius:"4px",overflow:"auto",maxHeight:"200px"},children:this.state.errorInfo.componentStack})]}),$.jsx("button",{className:"primary-button",onClick:()=>window.location.reload(),style:{width:"100%"},children:"Перезагрузить страницу"})]})}):this.props.children}}function p6(){return $.jsxs("div",{style:{maxWidth:"1100px",margin:"0 auto",display:"grid",gap:"3rem"},children:[$.jsxs("section",{style:{display:"grid",gap:"1.5rem",gridTemplateColumns:"repeat(auto-fit, minmax(280px, 1fr))",alignItems:"center"},children:[$.jsxs("div",{style:{display:"grid",gap:"1.25rem"},children:[$.jsx("span",{style:{color:"#6b7280",fontWeight:600,letterSpacing:"0.06em"},children:"REAL-TIME ATTENDANCE"}),$.jsx("h1",{style:{fontSize:"2.5rem",margin:0,lineHeight:1.2},children:"Контроль посещаемости с проверкой подлинности лица в реальном времени"}),$.jsx("p",{style:{color:"#4b5563",fontSize:"1rem",lineHeight:1.6},children:"Система совмещает биометрическую идентификацию и детекцию поддельных лиц через WebAssembly-модуль, обеспечивает безопасную авторизацию сотрудников и даёт администраторам удобные инструменты управления."})]}),$.jsxs("div",{style:{background:"#fff",border:"1px solid rgba(229, 231, 235, 0.9)",borderRadius:"18px",padding:"2rem",display:"grid",gap:"1.5rem",boxShadow:"0 24px 70px rgba(15, 23, 42, 0.08)"},children:[$.jsxs("div",{children:[$.jsx("h3",{style:{margin:0,color:"#111827"},children:"Возможности"}),$.jsxs("ul",{style:{margin:"0.75rem 0 0",paddingLeft:"1.2rem",color:"#4b5563",lineHeight:1.6},children:[$.jsx("li",{children:"Двухфакторная проверка сотрудника: ливнес + сравнение с эталоном"}),$.jsx("li",{children:"Отдельный кабинет администратора с управлением персоналом"}),$.jsx("li",{children:"Хранение дескрипторов лиц в защищённой базе PostgreSQL"})]})]}),$.jsxs("div",{children:[$.jsx("h3",{style:{margin:0,color:"#111827"},children:"Технологии"}),$.jsxs("ul",{style:{margin:"0.75rem 0 0",paddingLeft:"1.2rem",color:"#4b5563",lineHeight:1.6},children:[$.jsx("li",{children:"Node.js + Prisma + PostgreSQL для API и хранения данных"}),$.jsx("li",{children:"face-api.js для генерации дескрипторов"}),$.jsx("li",{children:"WebAssembly-модуль для анализа подлинности лиц"})]})]})]})]}),$.jsxs("section",{style:{background:"#fff",borderRadius:"18px",padding:"2.5rem",border:"1px solid rgba(229, 231, 235, 0.9)",boxShadow:"0 18px 60px rgba(15, 23, 42, 0.04)"},children:[$.jsx("h2",{style:{margin:0,fontSize:"1.75rem",color:"#111827"},children:"Как это работает"}),$.jsx("div",{style:{display:"grid",gap:"1.5rem",marginTop:"1.5rem",gridTemplateColumns:"repeat(auto-fit, minmax(220px, 1fr))"},children:[{title:"Администратор",text:"Создаёт учетные записи сотрудников, загружает эталонные фотографии и управляет базой дескрипторов."},{title:"Сотрудник",text:"Авторизуется в системе, проходит проверку на подлинность через камеру и отмечает присутствие."},{title:"Сервер",text:"Сохраняет данные в PostgreSQL, извлекает дескрипторы и сравнивает их с эталонным набором (порог 0.6)."}].map(e=>$.jsxs("div",{style:{display:"grid",gap:"0.75rem"},children:[$.jsx("h3",{style:{margin:0,color:"#1f2937"},children:e.title}),$.jsx("p",{style:{margin:0,color:"#4b5563",lineHeight:1.6},children:e.text})]},e.title))})]})]})}function h6(){const e=gf(),t=hs(),{login:n}=xb(),[r,a]=Y.useState(""),[s,i]=Y.useState(""),[o,l]=Y.useState(!1),[d,u]=Y.useState(""),c=async p=>{var h,f;p.preventDefault(),l(!0),u("");try{(await n({email:r,password:s})).role==="ADMIN"?e("/admin",{replace:!0}):e("/dashboard",{replace:!0,state:t.state})}catch(m){const g=((f=(h=m.response)==null?void 0:h.data)==null?void 0:f.message)||"Не удалось войти";u(g)}finally{l(!1)}};return $.jsx("div",{style:{display:"grid",justifyContent:"center"},children:$.jsxs("form",{onSubmit:c,style:{width:"min(500px, 100%)",background:"#fff",borderRadius:"16px",border:"1px solid rgba(229, 231, 235, 0.9)",padding:"2.5rem",display:"grid",gap:"1.5rem",boxShadow:"0 20px 60px rgba(15, 23, 42, 0.06)"},children:[$.jsxs("div",{children:[$.jsx("h2",{style:{margin:0,color:"#111827"},children:"Вход в систему"}),$.jsx("p",{style:{margin:"0.4rem 0 0",color:"#6b7280"},children:"Введите учётные данные, чтобы продолжить"})]}),$.jsxs("label",{style:{display:"grid",gap:"0.4rem",color:"#374151"},children:["Email",$.jsx("input",{type:"email",value:r,onChange:p=>a(p.target.value),required:!0,style:$T})]}),$.jsxs("label",{style:{display:"grid",gap:"0.4rem",color:"#374151"},children:["Пароль",$.jsx("input",{type:"password",value:s,onChange:p=>i(p.target.value),required:!0,style:$T})]}),d&&$.jsx("div",{style:{color:"#b91c1c",fontSize:"0.95rem"},children:d}),$.jsx("button",{type:"submit",className:"primary-button",disabled:o,children:o?"Вход...":"Войти"})]})})}const $T={padding:"0.75rem 1rem",borderRadius:"12px",border:"1px solid #d1d5db",background:"#f9fafb",fontSize:"1rem"};var f6=Object.defineProperty,vy=Object.getOwnPropertySymbols,fR=Object.prototype.hasOwnProperty,mR=Object.prototype.propertyIsEnumerable,AT=(e,t,n)=>t in e?f6(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,sw=(e,t)=>{for(var n in t||(t={}))fR.call(t,n)&&AT(e,n,t[n]);if(vy)for(var n of vy(t))mR.call(t,n)&&AT(e,n,t[n]);return e},iw=(e,t)=>{var n={};for(var r in e)fR.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&vy)for(var r of vy(e))t.indexOf(r)<0&&mR.call(e,r)&&(n[r]=e[r]);return n};/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */var Qo;(e=>{const t=class Je{constructor(l,d,u,c){if(this.version=l,this.errorCorrectionLevel=d,this.modules=[],this.isFunction=[],l<Je.MIN_VERSION||l>Je.MAX_VERSION)throw new RangeError("Version value out of range");if(c<-1||c>7)throw new RangeError("Mask value out of range");this.size=l*4+17;let p=[];for(let f=0;f<this.size;f++)p.push(!1);for(let f=0;f<this.size;f++)this.modules.push(p.slice()),this.isFunction.push(p.slice());this.drawFunctionPatterns();const h=this.addEccAndInterleave(u);if(this.drawCodewords(h),c==-1){let f=1e9;for(let m=0;m<8;m++){this.applyMask(m),this.drawFormatBits(m);const g=this.getPenaltyScore();g<f&&(c=m,f=g),this.applyMask(m)}}a(0<=c&&c<=7),this.mask=c,this.applyMask(c),this.drawFormatBits(c),this.isFunction=[]}static encodeText(l,d){const u=e.QrSegment.makeSegments(l);return Je.encodeSegments(u,d)}static encodeBinary(l,d){const u=e.QrSegment.makeBytes(l);return Je.encodeSegments([u],d)}static encodeSegments(l,d,u=1,c=40,p=-1,h=!0){if(!(Je.MIN_VERSION<=u&&u<=c&&c<=Je.MAX_VERSION)||p<-1||p>7)throw new RangeError("Invalid value");let f,m;for(f=u;;f++){const v=Je.getNumDataCodewords(f,d)*8,x=i.getTotalBits(l,f);if(x<=v){m=x;break}if(f>=c)throw new RangeError("Data too long")}for(const v of[Je.Ecc.MEDIUM,Je.Ecc.QUARTILE,Je.Ecc.HIGH])h&&m<=Je.getNumDataCodewords(f,v)*8&&(d=v);let g=[];for(const v of l){n(v.mode.modeBits,4,g),n(v.numChars,v.mode.numCharCountBits(f),g);for(const x of v.getData())g.push(x)}a(g.length==m);const y=Je.getNumDataCodewords(f,d)*8;a(g.length<=y),n(0,Math.min(4,y-g.length),g),n(0,(8-g.length%8)%8,g),a(g.length%8==0);for(let v=236;g.length<y;v^=253)n(v,8,g);let b=[];for(;b.length*8<g.length;)b.push(0);return g.forEach((v,x)=>b[x>>>3]|=v<<7-(x&7)),new Je(f,d,b,p)}getModule(l,d){return 0<=l&&l<this.size&&0<=d&&d<this.size&&this.modules[d][l]}getModules(){return this.modules}drawFunctionPatterns(){for(let u=0;u<this.size;u++)this.setFunctionModule(6,u,u%2==0),this.setFunctionModule(u,6,u%2==0);this.drawFinderPattern(3,3),this.drawFinderPattern(this.size-4,3),this.drawFinderPattern(3,this.size-4);const l=this.getAlignmentPatternPositions(),d=l.length;for(let u=0;u<d;u++)for(let c=0;c<d;c++)u==0&&c==0||u==0&&c==d-1||u==d-1&&c==0||this.drawAlignmentPattern(l[u],l[c]);this.drawFormatBits(0),this.drawVersion()}drawFormatBits(l){const d=this.errorCorrectionLevel.formatBits<<3|l;let u=d;for(let p=0;p<10;p++)u=u<<1^(u>>>9)*1335;const c=(d<<10|u)^21522;a(c>>>15==0);for(let p=0;p<=5;p++)this.setFunctionModule(8,p,r(c,p));this.setFunctionModule(8,7,r(c,6)),this.setFunctionModule(8,8,r(c,7)),this.setFunctionModule(7,8,r(c,8));for(let p=9;p<15;p++)this.setFunctionModule(14-p,8,r(c,p));for(let p=0;p<8;p++)this.setFunctionModule(this.size-1-p,8,r(c,p));for(let p=8;p<15;p++)this.setFunctionModule(8,this.size-15+p,r(c,p));this.setFunctionModule(8,this.size-8,!0)}drawVersion(){if(this.version<7)return;let l=this.version;for(let u=0;u<12;u++)l=l<<1^(l>>>11)*7973;const d=this.version<<12|l;a(d>>>18==0);for(let u=0;u<18;u++){const c=r(d,u),p=this.size-11+u%3,h=Math.floor(u/3);this.setFunctionModule(p,h,c),this.setFunctionModule(h,p,c)}}drawFinderPattern(l,d){for(let u=-4;u<=4;u++)for(let c=-4;c<=4;c++){const p=Math.max(Math.abs(c),Math.abs(u)),h=l+c,f=d+u;0<=h&&h<this.size&&0<=f&&f<this.size&&this.setFunctionModule(h,f,p!=2&&p!=4)}}drawAlignmentPattern(l,d){for(let u=-2;u<=2;u++)for(let c=-2;c<=2;c++)this.setFunctionModule(l+c,d+u,Math.max(Math.abs(c),Math.abs(u))!=1)}setFunctionModule(l,d,u){this.modules[d][l]=u,this.isFunction[d][l]=!0}addEccAndInterleave(l){const d=this.version,u=this.errorCorrectionLevel;if(l.length!=Je.getNumDataCodewords(d,u))throw new RangeError("Invalid argument");const c=Je.NUM_ERROR_CORRECTION_BLOCKS[u.ordinal][d],p=Je.ECC_CODEWORDS_PER_BLOCK[u.ordinal][d],h=Math.floor(Je.getNumRawDataModules(d)/8),f=c-h%c,m=Math.floor(h/c);let g=[];const y=Je.reedSolomonComputeDivisor(p);for(let v=0,x=0;v<c;v++){let w=l.slice(x,x+m-p+(v<f?0:1));x+=w.length;const I=Je.reedSolomonComputeRemainder(w,y);v<f&&w.push(0),g.push(w.concat(I))}let b=[];for(let v=0;v<g[0].length;v++)g.forEach((x,w)=>{(v!=m-p||w>=f)&&b.push(x[v])});return a(b.length==h),b}drawCodewords(l){if(l.length!=Math.floor(Je.getNumRawDataModules(this.version)/8))throw new RangeError("Invalid argument");let d=0;for(let u=this.size-1;u>=1;u-=2){u==6&&(u=5);for(let c=0;c<this.size;c++)for(let p=0;p<2;p++){const h=u-p,m=(u+1&2)==0?this.size-1-c:c;!this.isFunction[m][h]&&d<l.length*8&&(this.modules[m][h]=r(l[d>>>3],7-(d&7)),d++)}}a(d==l.length*8)}applyMask(l){if(l<0||l>7)throw new RangeError("Mask value out of range");for(let d=0;d<this.size;d++)for(let u=0;u<this.size;u++){let c;switch(l){case 0:c=(u+d)%2==0;break;case 1:c=d%2==0;break;case 2:c=u%3==0;break;case 3:c=(u+d)%3==0;break;case 4:c=(Math.floor(u/3)+Math.floor(d/2))%2==0;break;case 5:c=u*d%2+u*d%3==0;break;case 6:c=(u*d%2+u*d%3)%2==0;break;case 7:c=((u+d)%2+u*d%3)%2==0;break;default:throw new Error("Unreachable")}!this.isFunction[d][u]&&c&&(this.modules[d][u]=!this.modules[d][u])}}getPenaltyScore(){let l=0;for(let p=0;p<this.size;p++){let h=!1,f=0,m=[0,0,0,0,0,0,0];for(let g=0;g<this.size;g++)this.modules[p][g]==h?(f++,f==5?l+=Je.PENALTY_N1:f>5&&l++):(this.finderPenaltyAddHistory(f,m),h||(l+=this.finderPenaltyCountPatterns(m)*Je.PENALTY_N3),h=this.modules[p][g],f=1);l+=this.finderPenaltyTerminateAndCount(h,f,m)*Je.PENALTY_N3}for(let p=0;p<this.size;p++){let h=!1,f=0,m=[0,0,0,0,0,0,0];for(let g=0;g<this.size;g++)this.modules[g][p]==h?(f++,f==5?l+=Je.PENALTY_N1:f>5&&l++):(this.finderPenaltyAddHistory(f,m),h||(l+=this.finderPenaltyCountPatterns(m)*Je.PENALTY_N3),h=this.modules[g][p],f=1);l+=this.finderPenaltyTerminateAndCount(h,f,m)*Je.PENALTY_N3}for(let p=0;p<this.size-1;p++)for(let h=0;h<this.size-1;h++){const f=this.modules[p][h];f==this.modules[p][h+1]&&f==this.modules[p+1][h]&&f==this.modules[p+1][h+1]&&(l+=Je.PENALTY_N2)}let d=0;for(const p of this.modules)d=p.reduce((h,f)=>h+(f?1:0),d);const u=this.size*this.size,c=Math.ceil(Math.abs(d*20-u*10)/u)-1;return a(0<=c&&c<=9),l+=c*Je.PENALTY_N4,a(0<=l&&l<=2568888),l}getAlignmentPatternPositions(){if(this.version==1)return[];{const l=Math.floor(this.version/7)+2,d=this.version==32?26:Math.ceil((this.version*4+4)/(l*2-2))*2;let u=[6];for(let c=this.size-7;u.length<l;c-=d)u.splice(1,0,c);return u}}static getNumRawDataModules(l){if(l<Je.MIN_VERSION||l>Je.MAX_VERSION)throw new RangeError("Version number out of range");let d=(16*l+128)*l+64;if(l>=2){const u=Math.floor(l/7)+2;d-=(25*u-10)*u-55,l>=7&&(d-=36)}return a(208<=d&&d<=29648),d}static getNumDataCodewords(l,d){return Math.floor(Je.getNumRawDataModules(l)/8)-Je.ECC_CODEWORDS_PER_BLOCK[d.ordinal][l]*Je.NUM_ERROR_CORRECTION_BLOCKS[d.ordinal][l]}static reedSolomonComputeDivisor(l){if(l<1||l>255)throw new RangeError("Degree out of range");let d=[];for(let c=0;c<l-1;c++)d.push(0);d.push(1);let u=1;for(let c=0;c<l;c++){for(let p=0;p<d.length;p++)d[p]=Je.reedSolomonMultiply(d[p],u),p+1<d.length&&(d[p]^=d[p+1]);u=Je.reedSolomonMultiply(u,2)}return d}static reedSolomonComputeRemainder(l,d){let u=d.map(c=>0);for(const c of l){const p=c^u.shift();u.push(0),d.forEach((h,f)=>u[f]^=Je.reedSolomonMultiply(h,p))}return u}static reedSolomonMultiply(l,d){if(l>>>8||d>>>8)throw new RangeError("Byte out of range");let u=0;for(let c=7;c>=0;c--)u=u<<1^(u>>>7)*285,u^=(d>>>c&1)*l;return a(u>>>8==0),u}finderPenaltyCountPatterns(l){const d=l[1];a(d<=this.size*3);const u=d>0&&l[2]==d&&l[3]==d*3&&l[4]==d&&l[5]==d;return(u&&l[0]>=d*4&&l[6]>=d?1:0)+(u&&l[6]>=d*4&&l[0]>=d?1:0)}finderPenaltyTerminateAndCount(l,d,u){return l&&(this.finderPenaltyAddHistory(d,u),d=0),d+=this.size,this.finderPenaltyAddHistory(d,u),this.finderPenaltyCountPatterns(u)}finderPenaltyAddHistory(l,d){d[0]==0&&(l+=this.size),d.pop(),d.unshift(l)}};t.MIN_VERSION=1,t.MAX_VERSION=40,t.PENALTY_N1=3,t.PENALTY_N2=3,t.PENALTY_N3=40,t.PENALTY_N4=10,t.ECC_CODEWORDS_PER_BLOCK=[[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30]],t.NUM_ERROR_CORRECTION_BLOCKS=[[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25],[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49],[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68],[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]],e.QrCode=t;function n(o,l,d){if(l<0||l>31||o>>>l)throw new RangeError("Value out of range");for(let u=l-1;u>=0;u--)d.push(o>>>u&1)}function r(o,l){return(o>>>l&1)!=0}function a(o){if(!o)throw new Error("Assertion error")}const s=class Vt{constructor(l,d,u){if(this.mode=l,this.numChars=d,this.bitData=u,d<0)throw new RangeError("Invalid argument");this.bitData=u.slice()}static makeBytes(l){let d=[];for(const u of l)n(u,8,d);return new Vt(Vt.Mode.BYTE,l.length,d)}static makeNumeric(l){if(!Vt.isNumeric(l))throw new RangeError("String contains non-numeric characters");let d=[];for(let u=0;u<l.length;){const c=Math.min(l.length-u,3);n(parseInt(l.substring(u,u+c),10),c*3+1,d),u+=c}return new Vt(Vt.Mode.NUMERIC,l.length,d)}static makeAlphanumeric(l){if(!Vt.isAlphanumeric(l))throw new RangeError("String contains unencodable characters in alphanumeric mode");let d=[],u;for(u=0;u+2<=l.length;u+=2){let c=Vt.ALPHANUMERIC_CHARSET.indexOf(l.charAt(u))*45;c+=Vt.ALPHANUMERIC_CHARSET.indexOf(l.charAt(u+1)),n(c,11,d)}return u<l.length&&n(Vt.ALPHANUMERIC_CHARSET.indexOf(l.charAt(u)),6,d),new Vt(Vt.Mode.ALPHANUMERIC,l.length,d)}static makeSegments(l){return l==""?[]:Vt.isNumeric(l)?[Vt.makeNumeric(l)]:Vt.isAlphanumeric(l)?[Vt.makeAlphanumeric(l)]:[Vt.makeBytes(Vt.toUtf8ByteArray(l))]}static makeEci(l){let d=[];if(l<0)throw new RangeError("ECI assignment value out of range");if(l<128)n(l,8,d);else if(l<16384)n(2,2,d),n(l,14,d);else if(l<1e6)n(6,3,d),n(l,21,d);else throw new RangeError("ECI assignment value out of range");return new Vt(Vt.Mode.ECI,0,d)}static isNumeric(l){return Vt.NUMERIC_REGEX.test(l)}static isAlphanumeric(l){return Vt.ALPHANUMERIC_REGEX.test(l)}getData(){return this.bitData.slice()}static getTotalBits(l,d){let u=0;for(const c of l){const p=c.mode.numCharCountBits(d);if(c.numChars>=1<<p)return 1/0;u+=4+p+c.bitData.length}return u}static toUtf8ByteArray(l){l=encodeURI(l);let d=[];for(let u=0;u<l.length;u++)l.charAt(u)!="%"?d.push(l.charCodeAt(u)):(d.push(parseInt(l.substring(u+1,u+3),16)),u+=2);return d}};s.NUMERIC_REGEX=/^[0-9]*$/,s.ALPHANUMERIC_REGEX=/^[A-Z0-9 $%*+.\/:-]*$/,s.ALPHANUMERIC_CHARSET="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";let i=s;e.QrSegment=s})(Qo||(Qo={}));(e=>{(t=>{const n=class{constructor(a,s){this.ordinal=a,this.formatBits=s}};n.LOW=new n(0,1),n.MEDIUM=new n(1,0),n.QUARTILE=new n(2,3),n.HIGH=new n(3,2),t.Ecc=n})(e.QrCode||(e.QrCode={}))})(Qo||(Qo={}));(e=>{(t=>{const n=class{constructor(a,s){this.modeBits=a,this.numBitsCharCount=s}numCharCountBits(a){return this.numBitsCharCount[Math.floor((a+7)/17)]}};n.NUMERIC=new n(1,[10,12,14]),n.ALPHANUMERIC=new n(2,[9,11,13]),n.BYTE=new n(4,[8,16,16]),n.KANJI=new n(8,[8,10,12]),n.ECI=new n(7,[0,0,0]),t.Mode=n})(e.QrSegment||(e.QrSegment={}))})(Qo||(Qo={}));var bd=Qo;/**
 * @license qrcode.react
 * Copyright (c) Paul O'Shannessy
 * SPDX-License-Identifier: ISC
 */var m6={L:bd.QrCode.Ecc.LOW,M:bd.QrCode.Ecc.MEDIUM,Q:bd.QrCode.Ecc.QUARTILE,H:bd.QrCode.Ecc.HIGH},gR=128,yR="L",bR="#FFFFFF",vR="#000000",xR=!1,wR=1,g6=4,y6=0,b6=.1;function kR(e,t=0){const n=[];return e.forEach(function(r,a){let s=null;r.forEach(function(i,o){if(!i&&s!==null){n.push(`M${s+t} ${a+t}h${o-s}v1H${s+t}z`),s=null;return}if(o===r.length-1){if(!i)return;s===null?n.push(`M${o+t},${a+t} h1v1H${o+t}z`):n.push(`M${s+t},${a+t} h${o+1-s}v1H${s+t}z`);return}i&&s===null&&(s=o)})}),n.join("")}function SR(e,t){return e.slice().map((n,r)=>r<t.y||r>=t.y+t.h?n:n.map((a,s)=>s<t.x||s>=t.x+t.w?a:!1))}function v6(e,t,n,r){if(r==null)return null;const a=e.length+n*2,s=Math.floor(t*b6),i=a/t,o=(r.width||s)*i,l=(r.height||s)*i,d=r.x==null?e.length/2-o/2:r.x*i,u=r.y==null?e.length/2-l/2:r.y*i,c=r.opacity==null?1:r.opacity;let p=null;if(r.excavate){let f=Math.floor(d),m=Math.floor(u),g=Math.ceil(o+d-f),y=Math.ceil(l+u-m);p={x:f,y:m,w:g,h:y}}const h=r.crossOrigin;return{x:d,y:u,h:l,w:o,excavation:p,opacity:c,crossOrigin:h}}function x6(e,t){return t!=null?Math.max(Math.floor(t),0):e?g6:y6}function IR({value:e,level:t,minVersion:n,includeMargin:r,marginSize:a,imageSettings:s,size:i,boostLevel:o}){let l=Kt.useMemo(()=>{const f=(Array.isArray(e)?e:[e]).reduce((m,g)=>(m.push(...bd.QrSegment.makeSegments(g)),m),[]);return bd.QrCode.encodeSegments(f,m6[t],n,void 0,void 0,o)},[e,t,n,o]);const{cells:d,margin:u,numCells:c,calculatedImageSettings:p}=Kt.useMemo(()=>{let h=l.getModules();const f=x6(r,a),m=h.length+f*2,g=v6(h,i,f,s);return{cells:h,margin:f,numCells:m,calculatedImageSettings:g}},[l,i,s,r,a]);return{qrcode:l,margin:u,cells:d,numCells:c,calculatedImageSettings:p}}var w6=function(){try{new Path2D().addPath(new Path2D)}catch{return!1}return!0}(),k6=Kt.forwardRef(function(t,n){const r=t,{value:a,size:s=gR,level:i=yR,bgColor:o=bR,fgColor:l=vR,includeMargin:d=xR,minVersion:u=wR,boostLevel:c,marginSize:p,imageSettings:h}=r,m=iw(r,["value","size","level","bgColor","fgColor","includeMargin","minVersion","boostLevel","marginSize","imageSettings"]),{style:g}=m,y=iw(m,["style"]),b=h==null?void 0:h.src,v=Kt.useRef(null),x=Kt.useRef(null),w=Kt.useCallback(B=>{v.current=B,typeof n=="function"?n(B):n&&(n.current=B)},[n]),[I,N]=Kt.useState(!1),{margin:T,cells:A,numCells:R,calculatedImageSettings:F}=IR({value:a,level:i,minVersion:u,boostLevel:c,includeMargin:d,marginSize:p,imageSettings:h,size:s});Kt.useEffect(()=>{if(v.current!=null){const B=v.current,U=B.getContext("2d");if(!U)return;let G=A;const X=x.current,P=F!=null&&X!==null&&X.complete&&X.naturalHeight!==0&&X.naturalWidth!==0;P&&F.excavation!=null&&(G=SR(A,F.excavation));const q=window.devicePixelRatio||1;B.height=B.width=s*q;const Q=s/R*q;U.scale(Q,Q),U.fillStyle=o,U.fillRect(0,0,R,R),U.fillStyle=l,w6?U.fill(new Path2D(kR(G,T))):A.forEach(function(J,re){J.forEach(function(ae,ie){ae&&U.fillRect(ie+T,re+T,1,1)})}),F&&(U.globalAlpha=F.opacity),P&&U.drawImage(X,F.x+T,F.y+T,F.w,F.h)}}),Kt.useEffect(()=>{N(!1)},[b]);const C=sw({height:s,width:s},g);let M=null;return b!=null&&(M=Kt.createElement("img",{src:b,key:b,style:{display:"none"},onLoad:()=>{N(!0)},ref:x,crossOrigin:F==null?void 0:F.crossOrigin})),Kt.createElement(Kt.Fragment,null,Kt.createElement("canvas",sw({style:C,height:s,width:s,ref:w,role:"img"},y)),M)});k6.displayName="QRCodeCanvas";var NR=Kt.forwardRef(function(t,n){const r=t,{value:a,size:s=gR,level:i=yR,bgColor:o=bR,fgColor:l=vR,includeMargin:d=xR,minVersion:u=wR,boostLevel:c,title:p,marginSize:h,imageSettings:f}=r,m=iw(r,["value","size","level","bgColor","fgColor","includeMargin","minVersion","boostLevel","title","marginSize","imageSettings"]),{margin:g,cells:y,numCells:b,calculatedImageSettings:v}=IR({value:a,level:i,minVersion:u,boostLevel:c,includeMargin:d,marginSize:h,imageSettings:f,size:s});let x=y,w=null;f!=null&&v!=null&&(v.excavation!=null&&(x=SR(y,v.excavation)),w=Kt.createElement("image",{href:f.src,height:v.h,width:v.w,x:v.x+g,y:v.y+g,preserveAspectRatio:"none",opacity:v.opacity,crossOrigin:v.crossOrigin}));const I=kR(x,g);return Kt.createElement("svg",sw({height:s,width:s,viewBox:`0 0 ${b} ${b}`,ref:n,role:"img"},m),!!p&&Kt.createElement("title",null,p),Kt.createElement("path",{fill:o,d:`M0,0 h${b}v${b}H0z`,shapeRendering:"crispEdges"}),Kt.createElement("path",{fill:l,d:I,shapeRendering:"crispEdges"}),w)});NR.displayName="QRCodeSVG";let sg;function wb(){return typeof window>"u"?Promise.reject(new Error("Liveness module доступен только в браузере")):window._livenessModuleReady?Promise.resolve(window._livenessModuleReady):sg||(sg=new Promise((e,t)=>{if(window.Module&&window.Module._nentendo){window._livenessModuleReady=window.Module,e(window.Module);return}const n=window.Module||{};n.locateFile=a=>`/wasm/${a}`,n.onRuntimeInitialized=()=>{window._livenessModuleReady=n,e(n)},window.Module=n;const r=document.createElement("script");r.src="/wasm/Emscrippeng_test.js",r.async=!0,r.onerror=()=>t(new Error("Не удалось загрузить модуль проверки подлинности")),document.body.appendChild(r)}),sg)}async function mk(e){const t=await wb(),r=new TextEncoder().encode(e),a=t._malloc(r.length+1);t.HEAPU8.set(r,a),t.HEAPU8[a+r.length]=0;const s=t._nentendo(a);return t._free(a),s}var S6=Object.defineProperty,I6=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),gk=(e,t)=>{for(var n in t)S6(e,n,{get:t[n],enumerable:!0})},N6={};gk(N6,{Abs:()=>cc,Acos:()=>xl,Acosh:()=>wl,AdadeltaOptimizer:()=>OS,AdagradOptimizer:()=>PS,AdamOptimizer:()=>LS,AdamaxOptimizer:()=>zS,Add:()=>Yi,AddN:()=>kl,All:()=>pc,Any:()=>hc,ArgMax:()=>fc,ArgMin:()=>mc,Asin:()=>Sl,Asinh:()=>Il,Atan:()=>Nl,Atan2:()=>Tl,Atanh:()=>Cl,AvgPool:()=>El,AvgPool3D:()=>gc,AvgPool3DGrad:()=>If,AvgPoolGrad:()=>Sf,BackendWasm:()=>DB,BatchMatMul:()=>_l,BatchToSpaceND:()=>yc,Bincount:()=>bc,BitwiseAnd:()=>vc,BroadcastArgs:()=>Nf,BroadcastTo:()=>BR,Callback:()=>FO,CallbackList:()=>CM,Cast:()=>$l,Ceil:()=>Al,ClipByValue:()=>eo,Complex:()=>Cb,ComplexAbs:()=>Cf,Concat:()=>xc,Conv2D:()=>Rl,Conv2DBackpropFilter:()=>Tb,Conv2DBackpropInput:()=>Fl,Conv3D:()=>Dl,Conv3DBackpropFilterV2:()=>wc,Conv3DBackpropInputV2:()=>kc,Cos:()=>Ml,Cosh:()=>Ol,CropAndResize:()=>Ic,Cumprod:()=>Sc,Cumsum:()=>Pl,CustomCallback:()=>EM,DataStorage:()=>Sb,DenseBincount:()=>Tf,DepthToSpace:()=>Nc,DepthwiseConv2dNative:()=>Ll,DepthwiseConv2dNativeBackpropFilter:()=>Eb,DepthwiseConv2dNativeBackpropInput:()=>_b,Diag:()=>Ef,Dilation2D:()=>zl,Dilation2DBackpropFilter:()=>Wd,Dilation2DBackpropInput:()=>Bd,Draw:()=>$b,ENV:()=>wk,EarlyStopping:()=>DO,Einsum:()=>Ab,Elu:()=>Wl,EluGrad:()=>Cc,Environment:()=>LR,Equal:()=>Tc,Erf:()=>Ul,Exp:()=>Vl,ExpandDims:()=>Ec,Expm1:()=>jl,FFT:()=>Rb,Fill:()=>_f,FlipLeftRight:()=>_c,Floor:()=>Hl,FloorDiv:()=>Gl,FromPixels:()=>Sy,FusedBatchNorm:()=>ql,FusedConv2D:()=>Zo,FusedDepthwiseConv2D:()=>Yo,GPGPUContext:()=>Hg,GatherNd:()=>Ac,GatherV2:()=>$c,GraphModel:()=>N2,Greater:()=>Rc,GreaterEqual:()=>Kl,History:()=>TM,IFFT:()=>Fb,Identity:()=>Xl,Imag:()=>Db,InputSpec:()=>Jt,IsFinite:()=>Ql,IsInf:()=>Jl,IsNan:()=>Zl,KernelBackend:()=>wf,LRN:()=>nu,LRNGrad:()=>zc,LayerVariable:()=>bM,LayersModel:()=>Rs,LeakyRelu:()=>Yl,Less:()=>Fc,LessEqual:()=>Dc,LinSpace:()=>Mc,Log:()=>eu,Log1p:()=>tu,LogSoftmax:()=>UR,LogicalAnd:()=>Oc,LogicalNot:()=>Pc,LogicalOr:()=>Lc,LogicalXor:()=>WR,LowerBound:()=>gH,MathBackendCPU:()=>E2,MathBackendWebGL:()=>nN,MatrixBandPart:()=>yH,Max:()=>ru,MaxPool:()=>su,MaxPool3D:()=>Bc,MaxPool3DGrad:()=>Af,MaxPoolGrad:()=>$f,MaxPoolWithArgmax:()=>Rf,Maximum:()=>au,Mean:()=>iu,Min:()=>ou,Minimum:()=>lu,MirrorPad:()=>uu,Mod:()=>du,MomentumOptimizer:()=>BS,Multinomial:()=>Wc,Multiply:()=>cu,Neg:()=>Uc,NonMaxSuppressionV3:()=>jc,NonMaxSuppressionV4:()=>Hc,NonMaxSuppressionV5:()=>Gc,NotEqual:()=>Vc,OP_SCOPE_SUFFIX:()=>Ck,OneHot:()=>pu,OnesLike:()=>qc,Optimizer:()=>Gs,OptimizerConstructors:()=>JD,Pack:()=>Kc,PadV2:()=>hu,Pool:()=>bH,Pow:()=>fu,Prelu:()=>mu,Prod:()=>gu,RMSPropOptimizer:()=>WS,RNN:()=>qs,RaggedGather:()=>Mb,RaggedRange:()=>Ob,RaggedTensorToTensor:()=>Pb,Range:()=>Ff,Rank:()=>uw,Real:()=>Lb,RealDiv:()=>Bl,Reciprocal:()=>yu,Reduction:()=>Gn,Relu:()=>bu,Relu6:()=>wu,Reshape:()=>Xc,ResizeBilinear:()=>xu,ResizeBilinearGrad:()=>Jc,ResizeNearestNeighbor:()=>vu,ResizeNearestNeighborGrad:()=>Qc,Reverse:()=>ku,RotateWithOffset:()=>pp,Round:()=>Su,Rsqrt:()=>Iu,SGDOptimizer:()=>xv,ScatterNd:()=>Zc,SearchSorted:()=>ep,Select:()=>tp,Selu:()=>Nu,Sequential:()=>Fv,Sigmoid:()=>_u,Sign:()=>Eu,Sin:()=>Cu,Sinh:()=>Tu,Slice:()=>np,Softmax:()=>Fu,Softplus:()=>$u,SpaceToBatchND:()=>rp,SparseFillEmptyRows:()=>Df,SparseReshape:()=>sp,SparseSegmentMean:()=>Mf,SparseSegmentSum:()=>Of,SparseToDense:()=>ip,SplitV:()=>ap,Sqrt:()=>Au,Square:()=>Pf,SquaredDifference:()=>Du,StaticRegexReplace:()=>Lf,Step:()=>no,StridedSlice:()=>op,StringNGrams:()=>zf,StringSplit:()=>Bf,StringToHashBucketFast:()=>Wf,Sub:()=>Mu,Sum:()=>Ru,SymbolicTensor:()=>La,Tan:()=>Ou,Tanh:()=>Pu,Tensor:()=>Pe,TensorBuffer:()=>Yt,TensorScatterUpdate:()=>Yc,Tile:()=>to,TopK:()=>lp,Transform:()=>up,Transpose:()=>As,Unique:()=>Uf,Unpack:()=>dp,UnsortedSegmentSum:()=>Vf,UpperBound:()=>vH,Variable:()=>el,ZerosLike:()=>cp,_FusedMatMul:()=>Jo,abs:()=>Xt,acos:()=>Ak,acosh:()=>Rk,add:()=>te,addN:()=>gF,all:()=>Vb,any:()=>Jh,argMax:()=>al,argMin:()=>Fk,asin:()=>Dk,asinh:()=>Mk,atan:()=>Ok,atan2:()=>Pk,atanh:()=>Lk,avgPool:()=>Vs,avgPool3d:()=>Bk,backend:()=>Tk,backend_util:()=>E,basicLSTMCell:()=>xF,batchNorm:()=>Lu,batchNorm2d:()=>Wk,batchNorm3d:()=>Uk,batchNorm4d:()=>Vk,batchToSpaceND:()=>Qf,bincount:()=>jk,bitwiseAnd:()=>wF,booleanMaskAsync:()=>dD,broadcastArgs:()=>kF,broadcastTo:()=>Bo,broadcast_util:()=>hp,browser:()=>um,buffer:()=>Ve,callbacks:()=>fre,cast:()=>ue,ceil:()=>Hk,clipByValue:()=>On,clone:()=>is,complex:()=>Ls,concat:()=>gt,concat1d:()=>Gk,concat2d:()=>qk,concat3d:()=>Kk,concat4d:()=>Xk,constraints:()=>kM,conv1d:()=>jb,conv2d:()=>Jn,conv2dTranspose:()=>Hb,conv3d:()=>Jk,conv3dTranspose:()=>Zk,copyRegisteredKernels:()=>SH,cos:()=>Jf,cosh:()=>Gb,cosineWindow:()=>mv,cumprod:()=>ef,cumsum:()=>qb,customGrad:()=>cs,data:()=>a3,denseBincount:()=>Cy,deprecationWarn:()=>nF,depthToSpace:()=>Yk,depthwiseConv2d:()=>zu,deregisterOp:()=>yre,device_util:()=>qf,diag:()=>IF,dilation2d:()=>eS,disableDeprecationWarnings:()=>YH,dispose:()=>Fe,disposeVariables:()=>eG,div:()=>be,divNoNan:()=>tS,dot:()=>nS,dropout:()=>AS,einsum:()=>To,elu:()=>fp,enableDebugMode:()=>ZH,enableProdMode:()=>JH,enclosingPowerOfTwo:()=>RS,engine:()=>ua,ensureShape:()=>CF,env:()=>K,equal:()=>Or,erf:()=>Kb,euclideanNorm:()=>sS,exp:()=>Pn,expandDims:()=>yn,expm1:()=>iS,eye:()=>Xb,fft:()=>om,fill:()=>Dr,findBackend:()=>iG,findBackendFactory:()=>oG,floor:()=>gp,floorDiv:()=>Ub,forceHalfFloat:()=>EL,fused:()=>Xd,gather:()=>yp,gatherND:()=>fD,gather_util:()=>jS,getBackend:()=>rF,getGradient:()=>ow,getKernel:()=>Kh,getKernelsForBackend:()=>Iy,getThreadsCount:()=>wCe,gpgpu_util:()=>sL,grad:()=>zq,grads:()=>Bq,greater:()=>nr,greaterEqual:()=>js,ifft:()=>Kd,imag:()=>Zf,image:()=>qr,inTopKAsync:()=>mD,initializers:()=>SM,input:()=>UM,io:()=>$n,irfft:()=>lv,isFinite:()=>oS,isInf:()=>lS,isNaN:()=>uS,keep:()=>sn,kernel_impls:()=>gs,layers:()=>IM,leakyRelu:()=>Yf,less:()=>jd,lessEqual:()=>ao,linalg:()=>MS,linspace:()=>AF,loadGraphModel:()=>Sae,loadGraphModelSync:()=>Iae,loadLayersModel:()=>ute,localResponseNormalization:()=>dS,log:()=>Pr,log1p:()=>em,logSigmoid:()=>cS,logSoftmax:()=>Jb,logSumExp:()=>tm,logicalAnd:()=>ba,logicalNot:()=>nm,logicalOr:()=>Zb,logicalXor:()=>pS,losses:()=>TD,lowerBound:()=>FF,matMul:()=>We,math:()=>LD,max:()=>Zr,maxPool:()=>hn,maxPool3d:()=>hS,maxPoolWithArgmax:()=>DF,maximum:()=>ms,mean:()=>Ft,memory:()=>gw,meshgrid:()=>MF,metrics:()=>$O,min:()=>Vd,minimum:()=>Li,mirrorPad:()=>fS,mod:()=>mS,model:()=>pte,models:()=>AO,moments:()=>rm,movingAverage:()=>cD,mul:()=>W,multiRNNCell:()=>OF,multinomial:()=>PF,neg:()=>St,nextFrame:()=>HS,norm:()=>mp,notEqual:()=>ol,oneHot:()=>Hd,ones:()=>ur,onesLike:()=>Lr,op:()=>z,outerProduct:()=>LF,pad:()=>Ua,pad1d:()=>zF,pad2d:()=>BF,pad3d:()=>WF,pad4d:()=>UF,pool:()=>gS,pow:()=>ds,prelu:()=>sm,print:()=>$k,prod:()=>yS,profile:()=>tG,raggedGather:()=>VF,raggedRange:()=>jF,raggedTensorToTensor:()=>HF,rand:()=>GF,randomGamma:()=>QF,randomNormal:()=>ev,randomStandardNormal:()=>JF,randomUniform:()=>so,randomUniformInt:()=>ZF,range:()=>ll,ready:()=>aG,real:()=>Gd,reciprocal:()=>kS,registerBackend:()=>Wb,registerCallbackConstructor:()=>fte,registerGradient:()=>VR,registerKernel:()=>jf,registerOp:()=>gre,regularizers:()=>RO,relu:()=>ut,relu6:()=>tv,removeBackend:()=>sG,reshape:()=>V,reverse:()=>na,reverse1d:()=>YF,reverse2d:()=>eD,reverse3d:()=>tD,reverse4d:()=>nD,rfft:()=>lm,round:()=>nv,rsqrt:()=>rv,scalar:()=>Ce,scatterND:()=>pD,scatter_util:()=>cv,searchSorted:()=>Yb,selu:()=>av,separableConv2d:()=>bp,sequential:()=>hte,serialization:()=>oe,setBackend:()=>rG,setPlatform:()=>lG,setThreadsCount:()=>xCe,setWasmPath:()=>bCe,setWasmPaths:()=>vCe,setWebGLContext:()=>_P,setdiff1dAsync:()=>rD,shared:()=>_2,sigmoid:()=>ma,sign:()=>SS,signal:()=>CD,sin:()=>sv,sinh:()=>iv,slice:()=>Xe,slice1d:()=>im,slice2d:()=>ov,slice3d:()=>vp,slice4d:()=>qd,slice_util:()=>ln,softmax:()=>io,softplus:()=>Bu,spaceToBatchND:()=>am,sparse:()=>ED,sparseToDense:()=>hD,spectral:()=>ND,split:()=>cr,sqrt:()=>wn,square:()=>ft,squaredDifference:()=>uv,squeeze:()=>oo,stack:()=>en,step:()=>Wu,stridedSlice:()=>IS,string:()=>_D,sub:()=>me,sum:()=>ke,sumOutType:()=>Bb,tan:()=>NS,tanh:()=>Pi,tensor:()=>Xn,tensor1d:()=>ot,tensor2d:()=>os,tensor3d:()=>dv,tensor4d:()=>zi,tensor5d:()=>aD,tensor6d:()=>sD,tensorScatterUpdate:()=>oD,tensor_util:()=>Ra,test_util:()=>qF,tidy:()=>j,tile:()=>Er,time:()=>nG,topk:()=>TS,train:()=>Io,transpose:()=>Ue,truncatedNormal:()=>hv,unique:()=>ES,unregisterGradient:()=>kH,unregisterKernel:()=>wH,unsortedSegmentSum:()=>fv,unstack:()=>Ut,upcastType:()=>ea,upperBound:()=>lD,util:()=>k,valueAndGrad:()=>Wq,valueAndGrads:()=>Uq,variable:()=>_S,variableGrads:()=>RF,version:()=>ECe,version_converter:()=>Cae,version_core:()=>pQ,version_cpu:()=>Tie,version_layers:()=>fI,version_wasm:()=>kCe,version_webgl:()=>gfe,webgl:()=>yfe,webgl_util:()=>EP,where:()=>xn,whereAsync:()=>$S,zeros:()=>Dt,zerosLike:()=>Ze});var C6=Object.create,yk=Object.defineProperty,T6=Object.getOwnPropertyDescriptor,E6=Object.getOwnPropertyNames,_6=Object.getPrototypeOf,$6=Object.prototype.hasOwnProperty,nn=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),De=(e,t)=>{for(var n in t)yk(e,n,{get:t[n],enumerable:!0})},A6=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of E6(t))!$6.call(e,a)&&a!==n&&yk(e,a,{get:()=>t[a],enumerable:!(r=T6(t,a))||r.enumerable});return e},Zi=(e,t,n)=>(n=e!=null?C6(_6(e)):{},A6(!e||!e.__esModule?yk(n,"default",{value:e,enumerable:!0}):n,e)),R6=nn((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(C,M,B){this.low=C|0,this.high=M|0,this.unsigned=!!B}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function a(C){return(C&&C.__isLong__)===!0}r.isLong=a;var s={},i={};function o(C,M){var B,U,G;return M?(C>>>=0,(G=0<=C&&C<256)&&(U=i[C],U)?U:(B=d(C,(C|0)<0?-1:0,!0),G&&(i[C]=B),B)):(C|=0,(G=-128<=C&&C<128)&&(U=s[C],U)?U:(B=d(C,C<0?-1:0,!1),G&&(s[C]=B),B))}r.fromInt=o;function l(C,M){if(isNaN(C))return M?x:v;if(M){if(C<0)return x;if(C>=g)return A}else{if(C<=-y)return R;if(C+1>=y)return T}return C<0?l(-C,M).neg():d(C%m|0,C/m|0,M)}r.fromNumber=l;function d(C,M,B){return new r(C,M,B)}r.fromBits=d;var u=Math.pow;function c(C,M,B){if(C.length===0)throw Error("empty string");if(C==="NaN"||C==="Infinity"||C==="+Infinity"||C==="-Infinity")return v;if(typeof M=="number"?(B=M,M=!1):M=!!M,B=B||10,B<2||36<B)throw RangeError("radix");var U;if((U=C.indexOf("-"))>0)throw Error("interior hyphen");if(U===0)return c(C.substring(1),M,B).neg();for(var G=l(u(B,8)),X=v,P=0;P<C.length;P+=8){var q=Math.min(8,C.length-P),Q=parseInt(C.substring(P,P+q),B);if(q<8){var J=l(u(B,q));X=X.mul(J).add(l(Q))}else X=X.mul(G),X=X.add(l(Q))}return X.unsigned=M,X}r.fromString=c;function p(C,M){return typeof C=="number"?l(C,M):typeof C=="string"?c(C,M):d(C.low,C.high,typeof M=="boolean"?M:C.unsigned)}r.fromValue=p;var h=65536,f=1<<24,m=h*h,g=m*m,y=g/2,b=o(f),v=o(0);r.ZERO=v;var x=o(0,!0);r.UZERO=x;var w=o(1);r.ONE=w;var I=o(1,!0);r.UONE=I;var N=o(-1);r.NEG_ONE=N;var T=d(-1,2147483647,!1);r.MAX_VALUE=T;var A=d(-1,-1,!0);r.MAX_UNSIGNED_VALUE=A;var R=d(0,-2147483648,!1);r.MIN_VALUE=R;var F=r.prototype;F.toInt=function(){return this.unsigned?this.low>>>0:this.low},F.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},F.toString=function(C){if(C=C||10,C<2||36<C)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var M=l(C),B=this.div(M),U=B.mul(M).sub(this);return B.toString(C)+U.toInt().toString(C)}else return"-"+this.neg().toString(C);for(var G=l(u(C,6),this.unsigned),X=this,P="";;){var q=X.div(G),Q=X.sub(q.mul(G)).toInt()>>>0,J=Q.toString(C);if(X=q,X.isZero())return J+P;for(;J.length<6;)J="0"+J;P=""+J+P}},F.getHighBits=function(){return this.high},F.getHighBitsUnsigned=function(){return this.high>>>0},F.getLowBits=function(){return this.low},F.getLowBitsUnsigned=function(){return this.low>>>0},F.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var C=this.high!=0?this.high:this.low,M=31;M>0&&!(C&1<<M);M--);return this.high!=0?M+33:M+1},F.isZero=function(){return this.high===0&&this.low===0},F.eqz=F.isZero,F.isNegative=function(){return!this.unsigned&&this.high<0},F.isPositive=function(){return this.unsigned||this.high>=0},F.isOdd=function(){return(this.low&1)===1},F.isEven=function(){return(this.low&1)===0},F.equals=function(C){return a(C)||(C=p(C)),this.unsigned!==C.unsigned&&this.high>>>31===1&&C.high>>>31===1?!1:this.high===C.high&&this.low===C.low},F.eq=F.equals,F.notEquals=function(C){return!this.eq(C)},F.neq=F.notEquals,F.ne=F.notEquals,F.lessThan=function(C){return this.comp(C)<0},F.lt=F.lessThan,F.lessThanOrEqual=function(C){return this.comp(C)<=0},F.lte=F.lessThanOrEqual,F.le=F.lessThanOrEqual,F.greaterThan=function(C){return this.comp(C)>0},F.gt=F.greaterThan,F.greaterThanOrEqual=function(C){return this.comp(C)>=0},F.gte=F.greaterThanOrEqual,F.ge=F.greaterThanOrEqual,F.compare=function(C){if(a(C)||(C=p(C)),this.eq(C))return 0;var M=this.isNegative(),B=C.isNegative();return M&&!B?-1:!M&&B?1:this.unsigned?C.high>>>0>this.high>>>0||C.high===this.high&&C.low>>>0>this.low>>>0?-1:1:this.sub(C).isNegative()?-1:1},F.comp=F.compare,F.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(w)},F.neg=F.negate,F.add=function(C){a(C)||(C=p(C));var M=this.high>>>16,B=this.high&65535,U=this.low>>>16,G=this.low&65535,X=C.high>>>16,P=C.high&65535,q=C.low>>>16,Q=C.low&65535,J=0,re=0,ae=0,ie=0;return ie+=G+Q,ae+=ie>>>16,ie&=65535,ae+=U+q,re+=ae>>>16,ae&=65535,re+=B+P,J+=re>>>16,re&=65535,J+=M+X,J&=65535,d(ae<<16|ie,J<<16|re,this.unsigned)},F.subtract=function(C){return a(C)||(C=p(C)),this.add(C.neg())},F.sub=F.subtract,F.multiply=function(C){if(this.isZero())return v;if(a(C)||(C=p(C)),n){var M=n.mul(this.low,this.high,C.low,C.high);return d(M,n.get_high(),this.unsigned)}if(C.isZero())return v;if(this.eq(R))return C.isOdd()?R:v;if(C.eq(R))return this.isOdd()?R:v;if(this.isNegative())return C.isNegative()?this.neg().mul(C.neg()):this.neg().mul(C).neg();if(C.isNegative())return this.mul(C.neg()).neg();if(this.lt(b)&&C.lt(b))return l(this.toNumber()*C.toNumber(),this.unsigned);var B=this.high>>>16,U=this.high&65535,G=this.low>>>16,X=this.low&65535,P=C.high>>>16,q=C.high&65535,Q=C.low>>>16,J=C.low&65535,re=0,ae=0,ie=0,le=0;return le+=X*J,ie+=le>>>16,le&=65535,ie+=G*J,ae+=ie>>>16,ie&=65535,ie+=X*Q,ae+=ie>>>16,ie&=65535,ae+=U*J,re+=ae>>>16,ae&=65535,ae+=G*Q,re+=ae>>>16,ae&=65535,ae+=X*q,re+=ae>>>16,ae&=65535,re+=B*J+U*Q+G*q+X*P,re&=65535,d(ie<<16|le,re<<16|ae,this.unsigned)},F.mul=F.multiply,F.divide=function(C){if(a(C)||(C=p(C)),C.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&C.low===-1&&C.high===-1)return this;var M=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,C.low,C.high);return d(M,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?x:v;var B,U,G;if(this.unsigned){if(C.unsigned||(C=C.toUnsigned()),C.gt(this))return x;if(C.gt(this.shru(1)))return I;G=x}else{if(this.eq(R)){if(C.eq(w)||C.eq(N))return R;if(C.eq(R))return w;var X=this.shr(1);return B=X.div(C).shl(1),B.eq(v)?C.isNegative()?w:N:(U=this.sub(C.mul(B)),G=B.add(U.div(C)),G)}else if(C.eq(R))return this.unsigned?x:v;if(this.isNegative())return C.isNegative()?this.neg().div(C.neg()):this.neg().div(C).neg();if(C.isNegative())return this.div(C.neg()).neg();G=v}for(U=this;U.gte(C);){B=Math.max(1,Math.floor(U.toNumber()/C.toNumber()));for(var P=Math.ceil(Math.log(B)/Math.LN2),q=P<=48?1:u(2,P-48),Q=l(B),J=Q.mul(C);J.isNegative()||J.gt(U);)B-=q,Q=l(B,this.unsigned),J=Q.mul(C);Q.isZero()&&(Q=w),G=G.add(Q),U=U.sub(J)}return G},F.div=F.divide,F.modulo=function(C){if(a(C)||(C=p(C)),n){var M=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,C.low,C.high);return d(M,n.get_high(),this.unsigned)}return this.sub(this.div(C).mul(C))},F.mod=F.modulo,F.rem=F.modulo,F.not=function(){return d(~this.low,~this.high,this.unsigned)},F.and=function(C){return a(C)||(C=p(C)),d(this.low&C.low,this.high&C.high,this.unsigned)},F.or=function(C){return a(C)||(C=p(C)),d(this.low|C.low,this.high|C.high,this.unsigned)},F.xor=function(C){return a(C)||(C=p(C)),d(this.low^C.low,this.high^C.high,this.unsigned)},F.shiftLeft=function(C){return a(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?d(this.low<<C,this.high<<C|this.low>>>32-C,this.unsigned):d(0,this.low<<C-32,this.unsigned)},F.shl=F.shiftLeft,F.shiftRight=function(C){return a(C)&&(C=C.toInt()),(C&=63)===0?this:C<32?d(this.low>>>C|this.high<<32-C,this.high>>C,this.unsigned):d(this.high>>C-32,this.high>=0?0:-1,this.unsigned)},F.shr=F.shiftRight,F.shiftRightUnsigned=function(C){if(a(C)&&(C=C.toInt()),C&=63,C===0)return this;var M=this.high;if(C<32){var B=this.low;return d(B>>>C|M<<32-C,M>>>C,this.unsigned)}else return C===32?d(M,0,this.unsigned):d(M>>>C-32,0,this.unsigned)},F.shru=F.shiftRightUnsigned,F.shr_u=F.shiftRightUnsigned,F.toSigned=function(){return this.unsigned?d(this.low,this.high,!1):this},F.toUnsigned=function(){return this.unsigned?this:d(this.low,this.high,!0)},F.toBytes=function(C){return C?this.toBytesLE():this.toBytesBE()},F.toBytesLE=function(){var C=this.high,M=this.low;return[M&255,M>>>8&255,M>>>16&255,M>>>24,C&255,C>>>8&255,C>>>16&255,C>>>24]},F.toBytesBE=function(){var C=this.high,M=this.low;return[C>>>24,C>>>16&255,C>>>8&255,C&255,M>>>24,M>>>16&255,M>>>8&255,M&255]},r.fromBytes=function(C,M,B){return B?r.fromBytesLE(C,M):r.fromBytesBE(C,M)},r.fromBytesLE=function(C,M){return new r(C[0]|C[1]<<8|C[2]<<16|C[3]<<24,C[4]|C[5]<<8|C[6]<<16|C[7]<<24,M)},r.fromBytesBE=function(C,M){return new r(C[4]<<24|C[5]<<16|C[6]<<8|C[7],C[0]<<24|C[1]<<16|C[2]<<8|C[3],M)}}),F6=nn(()=>{}),D6=nn(()=>{}),M6=nn((e,t)=>{(function(n,r,a){function s(d){var u=this,c=l();u.next=function(){var p=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=p-(u.c=p|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(d),u.s0<0&&(u.s0+=1),u.s1-=c(d),u.s1<0&&(u.s1+=1),u.s2-=c(d),u.s2<0&&(u.s2+=1),c=null}function i(d,u){return u.c=d.c,u.s0=d.s0,u.s1=d.s1,u.s2=d.s2,u}function o(d,u){var c=new s(d),p=u&&u.state,h=c.next;return h.int32=function(){return c.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,p&&(typeof p=="object"&&i(p,c),h.state=function(){return i(c,{})}),h}function l(){var d=4022871197,u=function(c){c=String(c);for(var p=0;p<c.length;p++){d+=c.charCodeAt(p);var h=.02519603282416938*d;d=h>>>0,h-=d,h*=d,d=h>>>0,h-=d,d+=h*4294967296}return(d>>>0)*23283064365386963e-26};return u}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),O6=nn((e,t)=>{(function(n,r,a){function s(l){var d=this,u="";d.x=0,d.y=0,d.z=0,d.w=0,d.next=function(){var p=d.x^d.x<<11;return d.x=d.y,d.y=d.z,d.z=d.w,d.w^=d.w>>>19^p^p>>>8},l===(l|0)?d.x=l:u+=l;for(var c=0;c<u.length+64;c++)d.x^=u.charCodeAt(c)|0,d.next()}function i(l,d){return d.x=l.x,d.y=l.y,d.z=l.z,d.w=l.w,d}function o(l,d){var u=new s(l),c=d&&d.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=u.next,p.quick=p,c&&(typeof c=="object"&&i(c,u),p.state=function(){return i(u,{})}),p}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),P6=nn((e,t)=>{(function(n,r,a){function s(l){var d=this,u="";d.next=function(){var p=d.x^d.x>>>2;return d.x=d.y,d.y=d.z,d.z=d.w,d.w=d.v,(d.d=d.d+362437|0)+(d.v=d.v^d.v<<4^(p^p<<1))|0},d.x=0,d.y=0,d.z=0,d.w=0,d.v=0,l===(l|0)?d.x=l:u+=l;for(var c=0;c<u.length+64;c++)d.x^=u.charCodeAt(c)|0,c==u.length&&(d.d=d.x<<10^d.x>>>4),d.next()}function i(l,d){return d.x=l.x,d.y=l.y,d.z=l.z,d.w=l.w,d.v=l.v,d.d=l.d,d}function o(l,d){var u=new s(l),c=d&&d.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=u.next,p.quick=p,c&&(typeof c=="object"&&i(c,u),p.state=function(){return i(u,{})}),p}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),L6=nn((e,t)=>{(function(n,r,a){function s(l){var d=this;d.next=function(){var c=d.x,p=d.i,h,f;return h=c[p],h^=h>>>7,f=h^h<<24,h=c[p+1&7],f^=h^h>>>10,h=c[p+3&7],f^=h^h>>>3,h=c[p+4&7],f^=h^h<<7,h=c[p+7&7],h=h^h<<13,f^=h^h<<9,c[p]=f,d.i=p+1&7,f};function u(c,p){var h,f=[];if(p===(p|0))f[0]=p;else for(p=""+p,h=0;h<p.length;++h)f[h&7]=f[h&7]<<15^p.charCodeAt(h)+f[h+1&7]<<13;for(;f.length<8;)f.push(0);for(h=0;h<8&&f[h]===0;++h);for(h==8?f[7]=-1:f[h],c.x=f,c.i=0,h=256;h>0;--h)c.next()}u(d,l)}function i(l,d){return d.x=l.x.slice(),d.i=l.i,d}function o(l,d){l==null&&(l=+new Date);var u=new s(l),c=d&&d.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=u.next,p.quick=p,c&&(c.x&&i(c,u),p.state=function(){return i(u,{})}),p}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),z6=nn((e,t)=>{(function(n,r,a){function s(l){var d=this;d.next=function(){var c=d.w,p=d.X,h=d.i,f,m;return d.w=c=c+1640531527|0,m=p[h+34&127],f=p[h=h+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=p[h]=m^f,d.i=h,m+(c^c>>>16)|0};function u(c,p){var h,f,m,g,y,b=[],v=128;for(p===(p|0)?(f=p,p=null):(p=p+"\0",f=0,v=Math.max(v,p.length)),m=0,g=-32;g<v;++g)p&&(f^=p.charCodeAt((g+32)%p.length)),g===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(y=y+1640531527|0,h=b[g&127]^=f+y,m=h==0?m+1:0);for(m>=128&&(b[(p&&p.length||0)&127]=-1),m=127,g=4*128;g>0;--g)f=b[m+34&127],h=b[m=m+1&127],f^=f<<13,h^=h<<17,f^=f>>>15,h^=h>>>12,b[m]=f^h;c.w=y,c.X=b,c.i=m}u(d,l)}function i(l,d){return d.i=l.i,d.w=l.w,d.X=l.X.slice(),d}function o(l,d){l==null&&(l=+new Date);var u=new s(l),c=d&&d.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=u.next,p.quick=p,c&&(c.X&&i(c,u),p.state=function(){return i(u,{})}),p}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),B6=nn((e,t)=>{(function(n,r,a){function s(l){var d=this,u="";d.next=function(){var p=d.b,h=d.c,f=d.d,m=d.a;return p=p<<25^p>>>7^h,h=h-f|0,f=f<<24^f>>>8^m,m=m-p|0,d.b=p=p<<20^p>>>12^h,d.c=h=h-f|0,d.d=f<<16^h>>>16^m,d.a=m-p|0},d.a=0,d.b=0,d.c=-1640531527,d.d=1367130551,l===Math.floor(l)?(d.a=l/4294967296|0,d.b=l|0):u+=l;for(var c=0;c<u.length+20;c++)d.b^=u.charCodeAt(c)|0,d.next()}function i(l,d){return d.a=l.a,d.b=l.b,d.c=l.c,d.d=l.d,d}function o(l,d){var u=new s(l),c=d&&d.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},p.int32=u.next,p.quick=p,c&&(typeof c=="object"&&i(c,u),p.state=function(){return i(u,{})}),p}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),W6=nn(()=>{}),U6=nn((e,t)=>{(function(n,r,a){var s=256,i=6,o=52,l="random",d=a.pow(s,i),u=a.pow(2,o),c=u*2,p=s-1,h;function f(w,I,N){var T=[];I=I==!0?{entropy:!0}:I||{};var A=b(y(I.entropy?[w,x(r)]:w??v(),3),T),R=new m(T),F=function(){for(var C=R.g(i),M=d,B=0;C<u;)C=(C+B)*s,M*=s,B=R.g(1);for(;C>=c;)C/=2,M/=2,B>>>=1;return(C+B)/M};return F.int32=function(){return R.g(4)|0},F.quick=function(){return R.g(4)/4294967296},F.double=F,b(x(R.S),r),(I.pass||N||function(C,M,B,U){return U&&(U.S&&g(U,R),C.state=function(){return g(R,{})}),B?(a[l]=C,M):C})(F,A,"global"in I?I.global:this==a,I.state)}function m(w){var I,N=w.length,T=this,A=0,R=T.i=T.j=0,F=T.S=[];for(N||(w=[N++]);A<s;)F[A]=A++;for(A=0;A<s;A++)F[A]=F[R=p&R+w[A%N]+(I=F[A])],F[R]=I;(T.g=function(C){for(var M,B=0,U=T.i,G=T.j,X=T.S;C--;)M=X[U=p&U+1],B=B*s+X[p&(X[U]=X[G=p&G+M])+(X[G]=M)];return T.i=U,T.j=G,B})(s)}function g(w,I){return I.i=w.i,I.j=w.j,I.S=w.S.slice(),I}function y(w,I){var N=[],T=typeof w,A;if(I&&T=="object")for(A in w)try{N.push(y(w[A],I-1))}catch{}return N.length?N:T=="string"?w:w+"\0"}function b(w,I){for(var N=w+"",T,A=0;A<N.length;)I[p&A]=p&(T^=I[p&A]*19)+N.charCodeAt(A++);return x(I)}function v(){try{var w;return h&&(w=h.randomBytes)?w=w(s):(w=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(w)),x(w)}catch{var I=n.navigator,N=I&&I.plugins;return[+new Date,n,N,n.screen,x(r)]}}function x(w){return String.fromCharCode.apply(0,w)}if(b(a.random(),r),typeof t=="object"&&t.exports){t.exports=f;try{h=W6()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):a["seed"+l]=f})(typeof self<"u"?self:e,[],Math)}),kb=nn((e,t)=>{var n=M6(),r=O6(),a=P6(),s=L6(),i=z6(),o=B6(),l=U6();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l}),CR=nn(()=>{}),bk=nn(()=>{}),TR=nn(()=>{}),V6=nn(()=>{}),j6=nn(()=>{}),H6=nn(()=>{}),G6=nn((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a){a=a||{};function s(){return P.buffer!=ge&&Qe(P.buffer),Ee}function i(){return P.buffer!=ge&&Qe(P.buffer),Ae}function o(){return P.buffer!=ge&&Qe(P.buffer),Le}function l(){return P.buffer!=ge&&Qe(P.buffer),He}function d(){return P.buffer!=ge&&Qe(P.buffer),pt}var u=typeof a<"u"?a:{},c,p;u.ready=new Promise(function(O,Z){c=O,p=Z});var h;typeof process<"u"&&process.listeners&&(h={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},u),m=(O,Z)=>{throw Z},g=typeof window=="object",y=typeof importScripts=="function",b=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=u.ENVIRONMENT_IS_PTHREAD||!1,x="";function w(O){return u.locateFile?u.locateFile(O,x):x+O}var I,N,T;function A(O){O instanceof vs||U("exiting due to exception: "+O)}if(b){var R=bk(),F=TR();y?x=F.dirname(x)+"/":x=__dirname+"/",I=(Z,pe)=>(Z=Qs(Z)?new URL(Z):F.normalize(Z),R.readFileSync(Z,pe?void 0:"utf8")),T=Z=>{var pe=I(Z,!0);return pe.buffer||(pe=new Uint8Array(pe)),pe},N=(Z,pe,$e)=>{Z=Qs(Z)?new URL(Z):F.normalize(Z),R.readFile(Z,function(Oe,Be){Oe?$e(Oe):pe(Be.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Z){if(!(Z instanceof vs))throw Z}),process.on("unhandledRejection",function(Z){throw Z}),m=(Z,pe)=>{if(Pt())throw process.exitCode=Z,pe;A(pe),process.exit(Z)},u.inspect=function(){return"[Emscripten Module object]"};let O;try{O=V6()}catch(Z){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Z}global.Worker=O.Worker}else(g||y)&&(y?x=self.location.href:typeof document<"u"&&document.currentScript&&(x=document.currentScript.src),typeof r<"u"&&r&&(x=r),x.indexOf("blob:")!==0?x=x.substr(0,x.replace(/[?#].*/,"").lastIndexOf("/")+1):x="",b||(I=O=>{var Z=new XMLHttpRequest;return Z.open("GET",O,!1),Z.send(null),Z.responseText},y&&(T=O=>{var Z=new XMLHttpRequest;return Z.open("GET",O,!1),Z.responseType="arraybuffer",Z.send(null),new Uint8Array(Z.response)}),N=(O,Z,pe)=>{var $e=new XMLHttpRequest;$e.open("GET",O,!0),$e.responseType="arraybuffer",$e.onload=()=>{if($e.status==200||$e.status==0&&$e.response){Z($e.response);return}pe()},$e.onerror=pe,$e.send(null)}));b&&typeof performance>"u"&&(global.performance=j6().performance);var C=console.log.bind(console),M=console.warn.bind(console);b&&(C=O=>R.writeSync(1,O+`
`),M=O=>R.writeSync(2,O+`
`));var B=u.print||C,U=u.printErr||M;Object.assign(u,f),f=null,u.arguments&&u.arguments,u.thisProgram&&u.thisProgram,u.quit&&(m=u.quit);var G;u.wasmBinary&&(G=u.wasmBinary);var X=u.noExitRuntime||!0;typeof WebAssembly!="object"&&bs("no native wasm support detected");var P,q,Q=!1,J;function re(O,Z){O||bs(Z)}var ae=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ie(O,Z,pe){Z>>>=0;for(var $e=Z+pe,Oe=Z;O[Oe]&&!(Oe>=$e);)++Oe;if(Oe-Z>16&&O.buffer&&ae)return ae.decode(O.buffer instanceof SharedArrayBuffer?O.slice(Z,Oe):O.subarray(Z,Oe));for(var Be="";Z<Oe;){var ve=O[Z++];if(!(ve&128)){Be+=String.fromCharCode(ve);continue}var Te=O[Z++]&63;if((ve&224)==192){Be+=String.fromCharCode((ve&31)<<6|Te);continue}var At=O[Z++]&63;if((ve&240)==224?ve=(ve&15)<<12|Te<<6|At:ve=(ve&7)<<18|Te<<12|At<<6|O[Z++]&63,ve<65536)Be+=String.fromCharCode(ve);else{var Vr=ve-65536;Be+=String.fromCharCode(55296|Vr>>10,56320|Vr&1023)}}return Be}function le(O,Z){return O>>>=0,O?ie(i(),O,Z):""}function xe(O,Z,pe,$e){if(pe>>>=0,!($e>0))return 0;for(var Oe=pe,Be=pe+$e-1,ve=0;ve<O.length;++ve){var Te=O.charCodeAt(ve);if(Te>=55296&&Te<=57343){var At=O.charCodeAt(++ve);Te=65536+((Te&1023)<<10)|At&1023}if(Te<=127){if(pe>=Be)break;Z[pe++>>>0]=Te}else if(Te<=2047){if(pe+1>=Be)break;Z[pe++>>>0]=192|Te>>6,Z[pe++>>>0]=128|Te&63}else if(Te<=65535){if(pe+2>=Be)break;Z[pe++>>>0]=224|Te>>12,Z[pe++>>>0]=128|Te>>6&63,Z[pe++>>>0]=128|Te&63}else{if(pe+3>=Be)break;Z[pe++>>>0]=240|Te>>18,Z[pe++>>>0]=128|Te>>12&63,Z[pe++>>>0]=128|Te>>6&63,Z[pe++>>>0]=128|Te&63}}return Z[pe>>>0]=0,pe-Oe}function we(O,Z,pe){return xe(O,i(),Z,pe)}var ge,Ee,Ae,Le,He,pt;v&&(ge=u.buffer);function Qe(O){ge=O,u.HEAP8=Ee=new Int8Array(O),u.HEAP16=new Int16Array(O),u.HEAP32=Le=new Int32Array(O),u.HEAPU8=Ae=new Uint8Array(O),u.HEAPU16=new Uint16Array(O),u.HEAPU32=He=new Uint32Array(O),u.HEAPF32=new Float32Array(O),u.HEAPF64=pt=new Float64Array(O)}var tt=u.INITIAL_MEMORY||16777216;if(v)P=u.wasmMemory,ge=u.buffer;else if(u.wasmMemory)P=u.wasmMemory;else if(P=new WebAssembly.Memory({initial:tt/65536,maximum:65536,shared:!0}),!(P.buffer instanceof SharedArrayBuffer))throw U("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&U("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");P&&(ge=P.buffer),tt=ge.byteLength,Qe(ge);var Me,it=[],xt=[],vr=[];function Pt(){return X}function ar(){if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)ia(u.preRun.shift());wt(it)}function In(){!v&&wt(xt)}function sr(){if(!v){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;)ir(u.postRun.shift());wt(vr)}}function ia(O){it.unshift(O)}function xr(O){xt.unshift(O)}function ir(O){vr.unshift(O)}var Nn=0,Wr=null;function Xs(O){Nn++,u.monitorRunDependencies&&u.monitorRunDependencies(Nn)}function Mp(O){if(Nn--,u.monitorRunDependencies&&u.monitorRunDependencies(Nn),Nn==0&&Wr){var Z=Wr;Wr=null,Z()}}function bs(O){u.onAbort&&u.onAbort(O),O="Aborted("+O+")",U(O),Q=!0,J=1,O+=". Build with -sASSERTIONS for more info.";var Z=new WebAssembly.RuntimeError(O);throw p(Z),Z}var Op="data:application/octet-stream;base64,";function ja(O){return O.startsWith(Op)}function Qs(O){return O.startsWith("file://")}var Cn;Cn="tfjs-backend-wasm-threaded-simd.wasm",ja(Cn)||(Cn=w(Cn));function Cm(O){try{if(O==Cn&&G)return new Uint8Array(G);if(T)return T(O);throw"both async and sync fetching of the wasm failed"}catch(Z){bs(Z)}}function Tm(){if(!G&&(g||y)){if(typeof fetch=="function"&&!Qs(Cn))return fetch(Cn,{credentials:"same-origin"}).then(function(O){if(!O.ok)throw"failed to load wasm binary file at '"+Cn+"'";return O.arrayBuffer()}).catch(function(){return Cm(Cn)});if(N)return new Promise(function(O,Z){N(Cn,function(pe){O(new Uint8Array(pe))},Z)})}return Promise.resolve().then(function(){return Cm(Cn)})}function Em(){var O={env:WN,wasi_snapshot_preview1:WN};function Z(ve,Te){var At=ve.exports;if(u.asm=At,xs(u.asm._emscripten_tls_init),Me=u.asm.__indirect_function_table,xr(u.asm.__wasm_call_ctors),q=Te,!v){var Vr=ye.unusedWorkers.length;ye.unusedWorkers.forEach(function(ws){ye.loadWasmModuleToWorker(ws,function(){--Vr||Mp()})})}}v||Xs();function pe(ve){Z(ve.instance,ve.module)}function $e(ve){return Tm().then(function(Te){return WebAssembly.instantiate(Te,O)}).then(function(Te){return Te}).then(ve,function(Te){U("failed to asynchronously prepare wasm: "+Te),bs(Te)})}function Oe(){return!G&&typeof WebAssembly.instantiateStreaming=="function"&&!ja(Cn)&&!Qs(Cn)&&!b&&typeof fetch=="function"?fetch(Cn,{credentials:"same-origin"}).then(function(ve){var Te=WebAssembly.instantiateStreaming(ve,O);return Te.then(pe,function(At){return U("wasm streaming compile failed: "+At),U("falling back to ArrayBuffer instantiation"),$e(pe)})}):$e(pe)}if(u.instantiateWasm)try{var Be=u.instantiateWasm(O,Z);return Be}catch(ve){U("Module.instantiateWasm callback failed with error: "+ve),p(ve)}return Oe().catch(p),{}}var _m={};function vs(O){this.name="ExitStatus",this.message="Program terminated with exit("+O+")",this.status=O}function Qu(O){var Z=ye.pthreads[O];delete ye.pthreads[O],Z.terminate(),tx(O),ye.runningWorkers.splice(ye.runningWorkers.indexOf(Z),1),Z.pthread_ptr=0}function $m(O){var Z=ye.pthreads[O];Z.postMessage({cmd:"cancel"})}function go(O){var Z=ye.pthreads[O];re(Z),ye.returnWorkerToPool(Z)}function yo(O){var Z=ye.getNewWorker();if(!Z)return 6;ye.runningWorkers.push(Z),ye.pthreads[O.pthread_ptr]=Z,Z.pthread_ptr=O.pthread_ptr;var pe={cmd:"run",start_routine:O.startRoutine,arg:O.arg,pthread_ptr:O.pthread_ptr};return Z.runPthread=()=>{b&&Z.ref(),Z.postMessage(pe,O.transferList),delete Z.runPthread},Z.loaded&&Z.runPthread(),0}function Am(O){if(v)return Ju(1,1,O);J=O,Pt()||(ye.terminateAllThreads(),u.onExit&&u.onExit(O),Q=!0),m(O,new vs(O))}function se(O,Z){if(J=O,!Z&&v)throw Ke(O),"unwind";Am(O)}var ce=se;function _e(O){if(O instanceof vs||O=="unwind")return J;m(1,O)}var ye={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){v?ye.initWorker():ye.initMainThread()},initMainThread:function(){for(var O=8;O--;)ye.allocateUnusedWorker()},initWorker:function(){X=!1},setExitStatus:function(O){J=O},terminateAllThreads:function(){for(var O of Object.values(ye.pthreads))ye.returnWorkerToPool(O);for(var O of ye.unusedWorkers)O.terminate();ye.unusedWorkers=[]},returnWorkerToPool:function(O){var Z=O.pthread_ptr;delete ye.pthreads[Z],ye.unusedWorkers.push(O),ye.runningWorkers.splice(ye.runningWorkers.indexOf(O),1),O.pthread_ptr=0,b&&O.unref(),tx(Z)},receiveObjectTransfer:function(O){},threadInitTLS:function(){ye.tlsInitFunctions.forEach(O=>O())},loadWasmModuleToWorker:function(O,Z){O.onmessage=Be=>{var ve=Be.data,Te=ve.cmd;if(O.pthread_ptr&&(ye.currentProxiedOperationCallerThread=O.pthread_ptr),ve.targetThread&&ve.targetThread!=Mm()){var At=ye.pthreads[ve.targetThread];At?At.postMessage(ve,ve.transferList):U('Internal error! Worker sent a message "'+Te+'" to target pthread '+ve.targetThread+", but that thread no longer exists!"),ye.currentProxiedOperationCallerThread=void 0;return}Te==="processProxyingQueue"?Zv(ve.queue):Te==="spawnThread"?yo(ve):Te==="cleanupThread"?go(ve.thread):Te==="killThread"?Qu(ve.thread):Te==="cancelThread"?$m(ve.thread):Te==="loaded"?(O.loaded=!0,b&&O.unref(),Z&&Z(O),O.runPthread&&O.runPthread()):Te==="print"?B("Thread "+ve.threadId+": "+ve.text):Te==="printErr"?U("Thread "+ve.threadId+": "+ve.text):Te==="alert"?alert("Thread "+ve.threadId+": "+ve.text):ve.target==="setimmediate"?O.postMessage(ve):Te==="callHandler"?u[ve.handler](...ve.args):Te&&U("worker sent an unknown command "+Te),ye.currentProxiedOperationCallerThread=void 0},O.onerror=Be=>{var ve="worker sent an error!";throw U(ve+" "+Be.filename+":"+Be.lineno+": "+Be.message),Be},b&&(O.on("message",function(Be){O.onmessage({data:Be})}),O.on("error",function(Be){O.onerror(Be)}),O.on("detachedExit",function(){}));var pe=[],$e=["onExit","onAbort","print","printErr"];for(var Oe of $e)u.hasOwnProperty(Oe)&&pe.push(Oe);O.postMessage({cmd:"load",handlers:pe,urlOrBlob:u.mainScriptUrlOrBlob||r,wasmMemory:P,wasmModule:q})},allocateUnusedWorker:function(){var O,Z=w("tfjs-backend-wasm-threaded-simd.worker.js");O=new Worker(Z),ye.unusedWorkers.push(O)},getNewWorker:function(){return ye.unusedWorkers.length==0&&(ye.allocateUnusedWorker(),ye.loadWasmModuleToWorker(ye.unusedWorkers[0])),ye.unusedWorkers.pop()}};u.PThread=ye;function wt(O){for(;O.length>0;)O.shift()(u)}function Ct(){var O=Mm(),Z=o()[O+52>>>2],pe=o()[O+56>>>2],$e=Z-pe;GN(Z,$e),Om(Z)}u.establishStackSpace=Ct;function Ke(O){if(v)return Ju(2,0,O);try{ce(O)}catch(Z){_e(Z)}}var ze=[];function qt(O){var Z=ze[O];return Z||(O>=ze.length&&(ze.length=O+1),ze[O]=Z=Me.get(O)),Z}function Ur(O,Z){var pe=qt(O)(Z);Pt()?ye.setExitStatus(pe):HN(pe)}u.invokeEntryPoint=Ur;function xs(O){ye.tlsInitFunctions.push(O)}function Rm(O){UN(O,!y,1,!g),ye.threadInitTLS()}function Pp(O){v?postMessage({cmd:"cleanupThread",thread:O}):go(O)}function Fm(O,Z,pe,$e){return v?Ju(3,1,O,Z,pe,$e):Bn(O,Z,pe,$e)}function Bn(O,Z,pe,$e){if(typeof SharedArrayBuffer>"u")return U("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Oe=[],Be=0;if(v&&(Oe.length===0||Be))return Fm(O,Z,pe,$e);var ve={startRoutine:pe,pthread_ptr:O,arg:$e,transferList:Oe};return v?(ve.cmd="spawnThread",postMessage(ve,Oe),0):yo(ve)}function Js(){return 65536}var Dm=!0;function O4(){return Dm}function Zv(O){Atomics.store(o(),O>>2,1),Mm()&&jN(O),Atomics.compareExchange(o(),O>>2,1,0)}u.executeNotifiedProxyingQueue=Zv;function P4(O,Z,pe,$e){if(O==Z)setTimeout(()=>Zv($e));else if(v)postMessage({targetThread:O,cmd:"processProxyingQueue",queue:$e});else{var Oe=ye.pthreads[O];if(!Oe)return;Oe.postMessage({cmd:"processProxyingQueue",queue:$e})}return 1}function L4(O,Z,pe){return-1}function z4(){bs("")}function Lp(O){Lp.shown||(Lp.shown={}),Lp.shown[O]||(Lp.shown[O]=1,b&&(O="warning: "+O),U(O))}function B4(){b||y||Lp("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function W4(){return Date.now()}function ON(){return 4294901760}function U4(){return ON()}var Yv;b?Yv=()=>{var O=process.hrtime();return O[0]*1e3+O[1]/1e6}:Yv=()=>performance.timeOrigin+performance.now();function V4(O,Z,pe){i().copyWithin(O>>>0,Z>>>0,Z+pe>>>0)}function j4(){return b?H6().cpus().length:navigator.hardwareConcurrency}function H4(O){var Z=nx(),pe=O();return Om(Z),pe}function Ju(O,Z){var pe=arguments.length-2,$e=arguments;return H4(()=>{for(var Oe=pe,Be=Pm(Oe*8),ve=Be>>3,Te=0;Te<pe;Te++){var At=$e[2+Te];d()[ve+Te>>>0]=At}return VN(O,Oe,Be,Z)})}var ex=[];function G4(O,Z,pe){ex.length=Z;for(var $e=pe>>3,Oe=0;Oe<Z;Oe++)ex[Oe]=d()[$e+Oe>>>0];var Be=O<0,ve=Be?_m[-O-1]:tW[O];return ve.apply(null,ex)}function q4(O){try{return P.grow(O-ge.byteLength+65535>>>16),Qe(P.buffer),1}catch{}}function K4(O){var Z=i().length;if(O=O>>>0,O<=Z)return!1;var pe=ON();if(O>pe)return!1;let $e=(At,Vr)=>At+(Vr-At%Vr)%Vr;for(var Oe=1;Oe<=4;Oe*=2){var Be=Z*(1+.2/Oe);Be=Math.min(Be,O+100663296);var ve=Math.min(pe,$e(Math.max(O,Be),65536)),Te=q4(ve);if(Te)return!0}return!1}function X4(){throw"unwind"}function PN(O){return v?Ju(4,1,O):52}function LN(O,Z,pe,$e,Oe){return v?Ju(5,1,O,Z,pe,$e,Oe):70}var Q4=[null,[],[]];function J4(O,Z){var pe=Q4[O];Z===0||Z===10?((O===1?B:U)(ie(pe,0)),pe.length=0):pe.push(Z)}function zN(O,Z,pe,$e){if(v)return Ju(6,1,O,Z,pe,$e);for(var Oe=0,Be=0;Be<pe;Be++){var ve=l()[Z>>>2],Te=l()[Z+4>>>2];Z+=8;for(var At=0;At<Te;At++)J4(O,i()[ve+At>>>0]);Oe+=Te}return l()[$e>>>2]=Oe,0}function BN(O){var Z=u["_"+O];return Z}function Z4(O,Z){s().set(O,Z>>>0)}function Y4(O,Z,pe,$e,Oe){var Be={string:jr=>{var Zu=0;if(jr!=null&&jr!==0){var XN=(jr.length<<2)+1;Zu=Pm(XN),we(jr,Zu,XN)}return Zu},array:jr=>{var Zu=Pm(jr.length);return Z4(jr,Zu),Zu}};function ve(jr){return Z==="string"?le(jr):Z==="boolean"?!!jr:jr}var Te=BN(O),At=[],Vr=0;if($e)for(var ws=0;ws<$e.length;ws++){var KN=Be[pe[ws]];KN?(Vr===0&&(Vr=nx()),At[ws]=KN($e[ws])):At[ws]=$e[ws]}var rx=Te.apply(null,At);function rW(jr){return Vr!==0&&Om(Vr),ve(jr)}return rx=rW(rx),rx}function eW(O,Z,pe,$e){pe=pe||[];var Oe=pe.every(ve=>ve==="number"||ve==="boolean"),Be=Z!=="string";return Be&&Oe&&!$e?BN(O):function(){return Y4(O,Z,pe,arguments)}}ye.init();var tW=[null,Am,Ke,Fm,PN,LN,zN],WN={__emscripten_init_main_thread_js:Rm,__emscripten_thread_cleanup:Pp,__pthread_create_js:Bn,_emscripten_default_pthread_stack_size:Js,_emscripten_get_now_is_monotonic:O4,_emscripten_notify_task_queue:P4,_emscripten_set_offscreencanvas_size:L4,abort:z4,emscripten_check_blocking_allowed:B4,emscripten_date_now:W4,emscripten_get_heap_max:U4,emscripten_get_now:Yv,emscripten_memcpy_big:V4,emscripten_num_logical_cores:j4,emscripten_receive_on_main_thread_js:G4,emscripten_resize_heap:K4,emscripten_unwind_to_js_event_loop:X4,exit:ce,fd_close:PN,fd_seek:LN,fd_write:zN,memory:P||u.wasmMemory};Em(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.__wasm_call_ctors).apply(null,arguments)},u._init=function(){return(u._init=u.asm.init).apply(null,arguments)},u._init_with_threads_count=function(){return(u._init_with_threads_count=u.asm.init_with_threads_count).apply(null,arguments)},u._get_threads_count=function(){return(u._get_threads_count=u.asm.get_threads_count).apply(null,arguments)},u._register_tensor=function(){return(u._register_tensor=u.asm.register_tensor).apply(null,arguments)},u._dispose_data=function(){return(u._dispose_data=u.asm.dispose_data).apply(null,arguments)},u._dispose=function(){return(u._dispose=u.asm.dispose).apply(null,arguments)},u._Abs=function(){return(u._Abs=u.asm.Abs).apply(null,arguments)},u._Acos=function(){return(u._Acos=u.asm.Acos).apply(null,arguments)},u._Acosh=function(){return(u._Acosh=u.asm.Acosh).apply(null,arguments)},u._Add=function(){return(u._Add=u.asm.Add).apply(null,arguments)},u._AddN=function(){return(u._AddN=u.asm.AddN).apply(null,arguments)},u._All=function(){return(u._All=u.asm.All).apply(null,arguments)},u._Any=function(){return(u._Any=u.asm.Any).apply(null,arguments)},u._ArgMax=function(){return(u._ArgMax=u.asm.ArgMax).apply(null,arguments)},u._ArgMin=function(){return(u._ArgMin=u.asm.ArgMin).apply(null,arguments)},u._Asin=function(){return(u._Asin=u.asm.Asin).apply(null,arguments)},u._Asinh=function(){return(u._Asinh=u.asm.Asinh).apply(null,arguments)},u._Atan=function(){return(u._Atan=u.asm.Atan).apply(null,arguments)},u._Atan2=function(){return(u._Atan2=u.asm.Atan2).apply(null,arguments)},u._Atanh=function(){return(u._Atanh=u.asm.Atanh).apply(null,arguments)},u._AvgPool=function(){return(u._AvgPool=u.asm.AvgPool).apply(null,arguments)},u._AvgPool3D=function(){return(u._AvgPool3D=u.asm.AvgPool3D).apply(null,arguments)},u._AvgPool3DGrad=function(){return(u._AvgPool3DGrad=u.asm.AvgPool3DGrad).apply(null,arguments)},u._AvgPoolGrad=function(){return(u._AvgPoolGrad=u.asm.AvgPoolGrad).apply(null,arguments)},u._BatchMatMul=function(){return(u._BatchMatMul=u.asm.BatchMatMul).apply(null,arguments)},u._Bincount=function(){return(u._Bincount=u.asm.Bincount).apply(null,arguments)},u._BitwiseAnd=function(){return(u._BitwiseAnd=u.asm.BitwiseAnd).apply(null,arguments)},u._Ceil=function(){return(u._Ceil=u.asm.Ceil).apply(null,arguments)},u._ClipByValue=function(){return(u._ClipByValue=u.asm.ClipByValue).apply(null,arguments)},u._Conv2D=function(){return(u._Conv2D=u.asm.Conv2D).apply(null,arguments)},u._Conv2DBackpropInput=function(){return(u._Conv2DBackpropInput=u.asm.Conv2DBackpropInput).apply(null,arguments)},u._Conv3D=function(){return(u._Conv3D=u.asm.Conv3D).apply(null,arguments)},u._Conv3DBackpropFilterV2=function(){return(u._Conv3DBackpropFilterV2=u.asm.Conv3DBackpropFilterV2).apply(null,arguments)},u._Conv3DBackpropInputV2=function(){return(u._Conv3DBackpropInputV2=u.asm.Conv3DBackpropInputV2).apply(null,arguments)},u._Cos=function(){return(u._Cos=u.asm.Cos).apply(null,arguments)},u._Cosh=function(){return(u._Cosh=u.asm.Cosh).apply(null,arguments)},u._CropAndResize=function(){return(u._CropAndResize=u.asm.CropAndResize).apply(null,arguments)},u._Cumprod=function(){return(u._Cumprod=u.asm.Cumprod).apply(null,arguments)},u._Cumsum=function(){return(u._Cumsum=u.asm.Cumsum).apply(null,arguments)},u._DenseBincount=function(){return(u._DenseBincount=u.asm.DenseBincount).apply(null,arguments)},u._DepthToSpace=function(){return(u._DepthToSpace=u.asm.DepthToSpace).apply(null,arguments)},u._DepthwiseConv2dNative=function(){return(u._DepthwiseConv2dNative=u.asm.DepthwiseConv2dNative).apply(null,arguments)},u._Diag=function(){return(u._Diag=u.asm.Diag).apply(null,arguments)},u._Dilation2D=function(){return(u._Dilation2D=u.asm.Dilation2D).apply(null,arguments)},u._Dilation2DBackpropFilter=function(){return(u._Dilation2DBackpropFilter=u.asm.Dilation2DBackpropFilter).apply(null,arguments)},u._Dilation2DBackpropInput=function(){return(u._Dilation2DBackpropInput=u.asm.Dilation2DBackpropInput).apply(null,arguments)},u._Elu=function(){return(u._Elu=u.asm.Elu).apply(null,arguments)},u._EluGrad=function(){return(u._EluGrad=u.asm.EluGrad).apply(null,arguments)},u._Equal=function(){return(u._Equal=u.asm.Equal).apply(null,arguments)},u._Erf=function(){return(u._Erf=u.asm.Erf).apply(null,arguments)},u._Exp=function(){return(u._Exp=u.asm.Exp).apply(null,arguments)},u._Expm1=function(){return(u._Expm1=u.asm.Expm1).apply(null,arguments)},u._FlipLeftRight=function(){return(u._FlipLeftRight=u.asm.FlipLeftRight).apply(null,arguments)},u._Floor=function(){return(u._Floor=u.asm.Floor).apply(null,arguments)},u._FloorDiv=function(){return(u._FloorDiv=u.asm.FloorDiv).apply(null,arguments)},u._FusedBatchNorm=function(){return(u._FusedBatchNorm=u.asm.FusedBatchNorm).apply(null,arguments)},u._FusedConv2D=function(){return(u._FusedConv2D=u.asm.FusedConv2D).apply(null,arguments)},u._FusedDepthwiseConv2D=function(){return(u._FusedDepthwiseConv2D=u.asm.FusedDepthwiseConv2D).apply(null,arguments)},u._Gather=function(){return(u._Gather=u.asm.Gather).apply(null,arguments)},u._GatherNd=function(){return(u._GatherNd=u.asm.GatherNd).apply(null,arguments)},u._Greater=function(){return(u._Greater=u.asm.Greater).apply(null,arguments)},u._GreaterEqual=function(){return(u._GreaterEqual=u.asm.GreaterEqual).apply(null,arguments)},u._IsFinite=function(){return(u._IsFinite=u.asm.IsFinite).apply(null,arguments)},u._IsInf=function(){return(u._IsInf=u.asm.IsInf).apply(null,arguments)},u._IsNan=function(){return(u._IsNan=u.asm.IsNan).apply(null,arguments)},u._LRN=function(){return(u._LRN=u.asm.LRN).apply(null,arguments)},u._LRNGrad=function(){return(u._LRNGrad=u.asm.LRNGrad).apply(null,arguments)},u._LeakyRelu=function(){return(u._LeakyRelu=u.asm.LeakyRelu).apply(null,arguments)},u._Less=function(){return(u._Less=u.asm.Less).apply(null,arguments)},u._LessEqual=function(){return(u._LessEqual=u.asm.LessEqual).apply(null,arguments)},u._LinSpace=function(){return(u._LinSpace=u.asm.LinSpace).apply(null,arguments)},u._Log=function(){return(u._Log=u.asm.Log).apply(null,arguments)},u._Log1p=function(){return(u._Log1p=u.asm.Log1p).apply(null,arguments)},u._LogicalAnd=function(){return(u._LogicalAnd=u.asm.LogicalAnd).apply(null,arguments)},u._LogicalNot=function(){return(u._LogicalNot=u.asm.LogicalNot).apply(null,arguments)},u._LogicalOr=function(){return(u._LogicalOr=u.asm.LogicalOr).apply(null,arguments)},u._LogicalXor=function(){return(u._LogicalXor=u.asm.LogicalXor).apply(null,arguments)},u._Max=function(){return(u._Max=u.asm.Max).apply(null,arguments)},u._MaxPool=function(){return(u._MaxPool=u.asm.MaxPool).apply(null,arguments)},u._MaxPool3D=function(){return(u._MaxPool3D=u.asm.MaxPool3D).apply(null,arguments)},u._MaxPool3DGrad=function(){return(u._MaxPool3DGrad=u.asm.MaxPool3DGrad).apply(null,arguments)},u._MaxPoolGrad=function(){return(u._MaxPoolGrad=u.asm.MaxPoolGrad).apply(null,arguments)},u._MaxPoolWithArgmax=function(){return(u._MaxPoolWithArgmax=u.asm.MaxPoolWithArgmax).apply(null,arguments)},u._Maximum=function(){return(u._Maximum=u.asm.Maximum).apply(null,arguments)},u._Mean=function(){return(u._Mean=u.asm.Mean).apply(null,arguments)},u._Min=function(){return(u._Min=u.asm.Min).apply(null,arguments)},u._Minimum=function(){return(u._Minimum=u.asm.Minimum).apply(null,arguments)},u._MirrorPad=function(){return(u._MirrorPad=u.asm.MirrorPad).apply(null,arguments)},u._Mod=function(){return(u._Mod=u.asm.Mod).apply(null,arguments)},u._Multinomial=function(){return(u._Multinomial=u.asm.Multinomial).apply(null,arguments)},u._Multiply=function(){return(u._Multiply=u.asm.Multiply).apply(null,arguments)},u._Neg=function(){return(u._Neg=u.asm.Neg).apply(null,arguments)},u._NonMaxSuppressionV3=function(){return(u._NonMaxSuppressionV3=u.asm.NonMaxSuppressionV3).apply(null,arguments)},u._NonMaxSuppressionV4=function(){return(u._NonMaxSuppressionV4=u.asm.NonMaxSuppressionV4).apply(null,arguments)},u._NonMaxSuppressionV5=function(){return(u._NonMaxSuppressionV5=u.asm.NonMaxSuppressionV5).apply(null,arguments)},u._NotEqual=function(){return(u._NotEqual=u.asm.NotEqual).apply(null,arguments)},u._OneHot=function(){return(u._OneHot=u.asm.OneHot).apply(null,arguments)},u._PadV2=function(){return(u._PadV2=u.asm.PadV2).apply(null,arguments)},u._Pow=function(){return(u._Pow=u.asm.Pow).apply(null,arguments)},u._Prelu=function(){return(u._Prelu=u.asm.Prelu).apply(null,arguments)},u._Prod=function(){return(u._Prod=u.asm.Prod).apply(null,arguments)},u._RealDiv=function(){return(u._RealDiv=u.asm.RealDiv).apply(null,arguments)},u._Reciprocal=function(){return(u._Reciprocal=u.asm.Reciprocal).apply(null,arguments)},u._Relu=function(){return(u._Relu=u.asm.Relu).apply(null,arguments)},u._Relu6=function(){return(u._Relu6=u.asm.Relu6).apply(null,arguments)},u._ResizeBilinear=function(){return(u._ResizeBilinear=u.asm.ResizeBilinear).apply(null,arguments)},u._ResizeBilinearGrad=function(){return(u._ResizeBilinearGrad=u.asm.ResizeBilinearGrad).apply(null,arguments)},u._ResizeNearestNeighbor=function(){return(u._ResizeNearestNeighbor=u.asm.ResizeNearestNeighbor).apply(null,arguments)},u._ResizeNearestNeighborGrad=function(){return(u._ResizeNearestNeighborGrad=u.asm.ResizeNearestNeighborGrad).apply(null,arguments)},u._Reverse=function(){return(u._Reverse=u.asm.Reverse).apply(null,arguments)},u._RotateWithOffset=function(){return(u._RotateWithOffset=u.asm.RotateWithOffset).apply(null,arguments)},u._Round=function(){return(u._Round=u.asm.Round).apply(null,arguments)},u._Rsqrt=function(){return(u._Rsqrt=u.asm.Rsqrt).apply(null,arguments)},u._ScatterNd=function(){return(u._ScatterNd=u.asm.ScatterNd).apply(null,arguments)},u._SearchSorted=function(){return(u._SearchSorted=u.asm.SearchSorted).apply(null,arguments)},u._SelectV2=function(){return(u._SelectV2=u.asm.SelectV2).apply(null,arguments)},u._Selu=function(){return(u._Selu=u.asm.Selu).apply(null,arguments)},u._Sigmoid=function(){return(u._Sigmoid=u.asm.Sigmoid).apply(null,arguments)},u._Sign=function(){return(u._Sign=u.asm.Sign).apply(null,arguments)},u._Sin=function(){return(u._Sin=u.asm.Sin).apply(null,arguments)},u._Sinh=function(){return(u._Sinh=u.asm.Sinh).apply(null,arguments)},u._Softmax=function(){return(u._Softmax=u.asm.Softmax).apply(null,arguments)},u._Softplus=function(){return(u._Softplus=u.asm.Softplus).apply(null,arguments)},u._SparseFillEmptyRows=function(){return(u._SparseFillEmptyRows=u.asm.SparseFillEmptyRows).apply(null,arguments)},u._SparseReshape=function(){return(u._SparseReshape=u.asm.SparseReshape).apply(null,arguments)},u._SparseSegmentReduction=function(){return(u._SparseSegmentReduction=u.asm.SparseSegmentReduction).apply(null,arguments)},u._SparseToDense=function(){return(u._SparseToDense=u.asm.SparseToDense).apply(null,arguments)},u._Sqrt=function(){return(u._Sqrt=u.asm.Sqrt).apply(null,arguments)},u._Square=function(){return(u._Square=u.asm.Square).apply(null,arguments)},u._SquaredDifference=function(){return(u._SquaredDifference=u.asm.SquaredDifference).apply(null,arguments)},u._Step=function(){return(u._Step=u.asm.Step).apply(null,arguments)},u._StridedSlice=function(){return(u._StridedSlice=u.asm.StridedSlice).apply(null,arguments)},u._Sub=function(){return(u._Sub=u.asm.Sub).apply(null,arguments)},u._Sum=function(){return(u._Sum=u.asm.Sum).apply(null,arguments)},u._Tan=function(){return(u._Tan=u.asm.Tan).apply(null,arguments)},u._Tanh=function(){return(u._Tanh=u.asm.Tanh).apply(null,arguments)},u._TensorScatterUpdate=function(){return(u._TensorScatterUpdate=u.asm.TensorScatterUpdate).apply(null,arguments)},u._Tile=function(){return(u._Tile=u.asm.Tile).apply(null,arguments)},u._TopK=function(){return(u._TopK=u.asm.TopK).apply(null,arguments)},u._Transform=function(){return(u._Transform=u.asm.Transform).apply(null,arguments)},u._Transpose=function(){return(u._Transpose=u.asm.Transpose).apply(null,arguments)},u.__FusedMatMul=function(){return(u.__FusedMatMul=u.asm._FusedMatMul).apply(null,arguments)},u._malloc=function(){return(u._malloc=u.asm.malloc).apply(null,arguments)},u._free=function(){return(u._free=u.asm.free).apply(null,arguments)},u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm._emscripten_tls_init).apply(null,arguments)};var Mm=u._pthread_self=function(){return(Mm=u._pthread_self=u.asm.pthread_self).apply(null,arguments)};u.___errno_location=function(){return(u.___errno_location=u.asm.__errno_location).apply(null,arguments)};var UN=u.__emscripten_thread_init=function(){return(UN=u.__emscripten_thread_init=u.asm._emscripten_thread_init).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm._emscripten_thread_crashed).apply(null,arguments)},u._emscripten_main_thread_process_queued_calls=function(){return(u._emscripten_main_thread_process_queued_calls=u.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},u._emscripten_main_browser_thread_id=function(){return(u._emscripten_main_browser_thread_id=u.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var VN=u._emscripten_run_in_main_runtime_thread_js=function(){return(VN=u._emscripten_run_in_main_runtime_thread_js=u.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};u._emscripten_dispatch_to_thread_=function(){return(u._emscripten_dispatch_to_thread_=u.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var jN=u.__emscripten_proxy_execute_task_queue=function(){return(jN=u.__emscripten_proxy_execute_task_queue=u.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},tx=u.__emscripten_thread_free_data=function(){return(tx=u.__emscripten_thread_free_data=u.asm._emscripten_thread_free_data).apply(null,arguments)},HN=u.__emscripten_thread_exit=function(){return(HN=u.__emscripten_thread_exit=u.asm._emscripten_thread_exit).apply(null,arguments)},GN=u._emscripten_stack_set_limits=function(){return(GN=u._emscripten_stack_set_limits=u.asm.emscripten_stack_set_limits).apply(null,arguments)},nx=u.stackSave=function(){return(nx=u.stackSave=u.asm.stackSave).apply(null,arguments)},Om=u.stackRestore=function(){return(Om=u.stackRestore=u.asm.stackRestore).apply(null,arguments)},Pm=u.stackAlloc=function(){return(Pm=u.stackAlloc=u.asm.stackAlloc).apply(null,arguments)};u.dynCall_iijjiiii=function(){return(u.dynCall_iijjiiii=u.asm.dynCall_iijjiiii).apply(null,arguments)},u.dynCall_jiji=function(){return(u.dynCall_jiji=u.asm.dynCall_jiji).apply(null,arguments)},u.keepRuntimeAlive=Pt,u.wasmMemory=P,u.cwrap=eW,u.ExitStatus=vs,u.PThread=ye;var Lm;Wr=function O(){Lm||qN(),Lm||(Wr=O)};function qN(O){if(Nn>0)return;if(v){c(u),In(),startWorker(u);return}if(ar(),Nn>0)return;function Z(){Lm||(Lm=!0,u.calledRun=!0,!Q&&(In(),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),sr()))}u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),Z()},1)):Z()}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();qN();var zm;h&&(zm={uncaughtException:process.listeners("uncaughtException").filter(function(O){return!h.uncaughtException.indexOf(O)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(O){return!h.unhandledRejection.indexOf(O)>-1})});var Bm;if(typeof WasmBackendModule<"u")Bm=WasmBackendModule;else if(typeof a<"u")Bm=a;else throw new Error("Could not find wasm module in post.js");if(zm){var nW=Bm._dispose;Bm._dispose=function(){nW(),zm.uncaughtException.forEach(function(O){process.removeListener("uncaughtException",O)}),zm.unhandledRejection.forEach(function(O){process.removeListener("unhandledRejection",O)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),q6=nn((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),K6=nn((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a){a=a||{};var s=typeof a<"u"?a:{},i,o;s.ready=new Promise(function(se,ce){i=se,o=ce});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d=Object.assign({},s),u=typeof window=="object",c=typeof importScripts=="function",p=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",h="";function f(se){return s.locateFile?s.locateFile(se,h):h+se}var m,g,y;if(p){var b=bk(),v=TR();c?h=v.dirname(h)+"/":h=__dirname+"/",m=(se,ce)=>(se=tt(se)?new URL(se):v.normalize(se),b.readFileSync(se,ce?void 0:"utf8")),y=se=>{var ce=m(se,!0);return ce.buffer||(ce=new Uint8Array(ce)),ce},g=(se,ce,_e)=>{se=tt(se)?new URL(se):v.normalize(se),b.readFile(se,function(ye,wt){ye?_e(ye):ce(wt.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(se){if(!(se instanceof Pt))throw se}),process.on("unhandledRejection",function(se){throw se}),s.inspect=function(){return"[Emscripten Module object]"}}else(u||c)&&(c?h=self.location.href:typeof document<"u"&&document.currentScript&&(h=document.currentScript.src),r&&(h=r),h.indexOf("blob:")!==0?h=h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):h="",m=se=>{var ce=new XMLHttpRequest;return ce.open("GET",se,!1),ce.send(null),ce.responseText},c&&(y=se=>{var ce=new XMLHttpRequest;return ce.open("GET",se,!1),ce.responseType="arraybuffer",ce.send(null),new Uint8Array(ce.response)}),g=(se,ce,_e)=>{var ye=new XMLHttpRequest;ye.open("GET",se,!0),ye.responseType="arraybuffer",ye.onload=()=>{if(ye.status==200||ye.status==0&&ye.response){ce(ye.response);return}_e()},ye.onerror=_e,ye.send(null)});var x=s.print||console.log.bind(console),w=s.printErr||console.warn.bind(console);Object.assign(s,d),d=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit;var I;s.wasmBinary&&(I=s.wasmBinary),s.noExitRuntime,typeof WebAssembly!="object"&&He("no native wasm support detected");var N,T=!1,A=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function R(se,ce,_e){ce>>>=0;for(var ye=ce+_e,wt=ce;se[wt]&&!(wt>=ye);)++wt;if(wt-ce>16&&se.buffer&&A)return A.decode(se.subarray(ce,wt));for(var Ct="";ce<wt;){var Ke=se[ce++];if(!(Ke&128)){Ct+=String.fromCharCode(Ke);continue}var ze=se[ce++]&63;if((Ke&224)==192){Ct+=String.fromCharCode((Ke&31)<<6|ze);continue}var qt=se[ce++]&63;if((Ke&240)==224?Ke=(Ke&15)<<12|ze<<6|qt:Ke=(Ke&7)<<18|ze<<12|qt<<6|se[ce++]&63,Ke<65536)Ct+=String.fromCharCode(Ke);else{var Ur=Ke-65536;Ct+=String.fromCharCode(55296|Ur>>10,56320|Ur&1023)}}return Ct}function F(se,ce){return se>>>=0,se?R(G,se,ce):""}function C(se,ce,_e,ye){if(_e>>>=0,!(ye>0))return 0;for(var wt=_e,Ct=_e+ye-1,Ke=0;Ke<se.length;++Ke){var ze=se.charCodeAt(Ke);if(ze>=55296&&ze<=57343){var qt=se.charCodeAt(++Ke);ze=65536+((ze&1023)<<10)|qt&1023}if(ze<=127){if(_e>=Ct)break;ce[_e++>>>0]=ze}else if(ze<=2047){if(_e+1>=Ct)break;ce[_e++>>>0]=192|ze>>6,ce[_e++>>>0]=128|ze&63}else if(ze<=65535){if(_e+2>=Ct)break;ce[_e++>>>0]=224|ze>>12,ce[_e++>>>0]=128|ze>>6&63,ce[_e++>>>0]=128|ze&63}else{if(_e+3>=Ct)break;ce[_e++>>>0]=240|ze>>18,ce[_e++>>>0]=128|ze>>12&63,ce[_e++>>>0]=128|ze>>6&63,ce[_e++>>>0]=128|ze&63}}return ce[_e>>>0]=0,_e-wt}function M(se,ce,_e){return C(se,G,ce,_e)}var B,U,G,X;function P(se){B=se,s.HEAP8=U=new Int8Array(se),s.HEAP16=new Int16Array(se),s.HEAP32=new Int32Array(se),s.HEAPU8=G=new Uint8Array(se),s.HEAPU16=new Uint16Array(se),s.HEAPU32=X=new Uint32Array(se),s.HEAPF32=new Float32Array(se),s.HEAPF64=new Float64Array(se)}s.INITIAL_MEMORY;var q=[],Q=[],J=[];function re(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)le(s.preRun.shift());ar(q)}function ae(){ar(Q)}function ie(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)we(s.postRun.shift());ar(J)}function le(se){q.unshift(se)}function xe(se){Q.unshift(se)}function we(se){J.unshift(se)}var ge=0,Ee=null;function Ae(se){ge++,s.monitorRunDependencies&&s.monitorRunDependencies(ge)}function Le(se){if(ge--,s.monitorRunDependencies&&s.monitorRunDependencies(ge),ge==0&&Ee){var ce=Ee;Ee=null,ce()}}function He(se){s.onAbort&&s.onAbort(se),se="Aborted("+se+")",w(se),T=!0,se+=". Build with -sASSERTIONS for more info.";var ce=new WebAssembly.RuntimeError(se);throw o(ce),ce}var pt="data:application/octet-stream;base64,";function Qe(se){return se.startsWith(pt)}function tt(se){return se.startsWith("file://")}var Me;Me="tfjs-backend-wasm.wasm",Qe(Me)||(Me=f(Me));function it(se){try{if(se==Me&&I)return new Uint8Array(I);if(y)return y(se);throw"both async and sync fetching of the wasm failed"}catch(ce){He(ce)}}function xt(){if(!I&&(u||c)){if(typeof fetch=="function"&&!tt(Me))return fetch(Me,{credentials:"same-origin"}).then(function(se){if(!se.ok)throw"failed to load wasm binary file at '"+Me+"'";return se.arrayBuffer()}).catch(function(){return it(Me)});if(g)return new Promise(function(se,ce){g(Me,function(_e){se(new Uint8Array(_e))},ce)})}return Promise.resolve().then(function(){return it(Me)})}function vr(){var se={env:Tm,wasi_snapshot_preview1:Tm};function ce(Ke,ze){var qt=Ke.exports;s.asm=qt,N=s.asm.memory,P(N.buffer),s.asm.__indirect_function_table,xe(s.asm.__wasm_call_ctors),Le()}Ae();function _e(Ke){ce(Ke.instance)}function ye(Ke){return xt().then(function(ze){return WebAssembly.instantiate(ze,se)}).then(function(ze){return ze}).then(Ke,function(ze){w("failed to asynchronously prepare wasm: "+ze),He(ze)})}function wt(){return!I&&typeof WebAssembly.instantiateStreaming=="function"&&!Qe(Me)&&!tt(Me)&&!p&&typeof fetch=="function"?fetch(Me,{credentials:"same-origin"}).then(function(Ke){var ze=WebAssembly.instantiateStreaming(Ke,se);return ze.then(_e,function(qt){return w("wasm streaming compile failed: "+qt),w("falling back to ArrayBuffer instantiation"),ye(_e)})}):ye(_e)}if(s.instantiateWasm)try{var Ct=s.instantiateWasm(se,ce);return Ct}catch(Ke){w("Module.instantiateWasm callback failed with error: "+Ke),o(Ke)}return wt().catch(o),{}}function Pt(se){this.name="ExitStatus",this.message="Program terminated with exit("+se+")",this.status=se}function ar(se){for(;se.length>0;)se.shift()(s)}function In(){He("")}function sr(){return 4294901760}function ia(){return sr()}function xr(se,ce,_e){G.copyWithin(se>>>0,ce>>>0,ce+_e>>>0)}function ir(se){try{return N.grow(se-B.byteLength+65535>>>16),P(N.buffer),1}catch{}}function Nn(se){var ce=G.length;se=se>>>0;var _e=sr();if(se>_e)return!1;let ye=(qt,Ur)=>qt+(Ur-qt%Ur)%Ur;for(var wt=1;wt<=4;wt*=2){var Ct=ce*(1+.2/wt);Ct=Math.min(Ct,se+100663296);var Ke=Math.min(_e,ye(Math.max(se,Ct),65536)),ze=ir(Ke);if(ze)return!0}return!1}function Wr(se){return 52}function Xs(se,ce,_e,ye,wt){return 70}var Mp=[null,[],[]];function bs(se,ce){var _e=Mp[se];ce===0||ce===10?((se===1?x:w)(R(_e,0)),_e.length=0):_e.push(ce)}function Op(se,ce,_e,ye){for(var wt=0,Ct=0;Ct<_e;Ct++){var Ke=X[ce>>>2],ze=X[ce+4>>>2];ce+=8;for(var qt=0;qt<ze;qt++)bs(se,G[Ke+qt>>>0]);wt+=ze}return X[ye>>>2]=wt,0}function ja(se){var ce=s["_"+se];return ce}function Qs(se,ce){U.set(se,ce>>>0)}function Cn(se,ce,_e,ye,wt){var Ct={string:Bn=>{var Js=0;if(Bn!=null&&Bn!==0){var Dm=(Bn.length<<2)+1;Js=vs(Dm),M(Bn,Js,Dm)}return Js},array:Bn=>{var Js=vs(Bn.length);return Qs(Bn,Js),Js}};function Ke(Bn){return ce==="string"?F(Bn):ce==="boolean"?!!Bn:Bn}var ze=ja(se),qt=[],Ur=0;if(ye)for(var xs=0;xs<ye.length;xs++){var Rm=Ct[_e[xs]];Rm?(Ur===0&&(Ur=Em()),qt[xs]=Rm(ye[xs])):qt[xs]=ye[xs]}var Pp=ze.apply(null,qt);function Fm(Bn){return Ur!==0&&_m(Ur),Ke(Bn)}return Pp=Fm(Pp),Pp}function Cm(se,ce,_e,ye){_e=_e||[];var wt=_e.every(Ke=>Ke==="number"||Ke==="boolean"),Ct=ce!=="string";return Ct&&wt&&!ye?ja(se):function(){return Cn(se,ce,_e,arguments)}}var Tm={abort:In,emscripten_get_heap_max:ia,emscripten_memcpy_big:xr,emscripten_resize_heap:Nn,fd_close:Wr,fd_seek:Xs,fd_write:Op};vr(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var Em=s.stackSave=function(){return(Em=s.stackSave=s.asm.stackSave).apply(null,arguments)},_m=s.stackRestore=function(){return(_m=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},vs=s.stackAlloc=function(){return(vs=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=Cm;var Qu;Ee=function se(){Qu||$m(),Qu||(Ee=se)};function $m(se){if(ge>0||(re(),ge>0))return;function ce(){Qu||(Qu=!0,s.calledRun=!0,!T&&(ae(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),ie()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),ce()},1)):ce()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();$m();var go;l&&(go={uncaughtException:process.listeners("uncaughtException").filter(function(se){return!l.uncaughtException.indexOf(se)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(se){return!l.unhandledRejection.indexOf(se)>-1})});var yo;if(typeof a<"u")yo=a;else if(typeof WasmBackendModuleThreadedSimd<"u")yo=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(go){var Am=yo._dispose;yo._dispose=function(){Am(),go.uncaughtException.forEach(function(se){process.removeListener("uncaughtException",se)}),go.unhandledRejection.forEach(function(se){process.removeListener("unhandledRejection",se)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),Sb=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},wf=class{refCount(e){return wr("refCount")}incRef(e){return wr("incRef")}timerAvailable(){return!0}time(e){return wr("time")}read(e){return wr("read")}readSync(e){return wr("readSync")}readToGPU(e,t){return wr("readToGPU")}numDataIds(){return wr("numDataIds")}disposeData(e,t){return wr("disposeData")}write(e,t,n){return wr("write")}move(e,t,n,r,a){return wr("move")}createTensorFromGPUData(e,t,n){return wr("createTensorFromGPUData")}memory(){return wr("memory")}floatPrecision(){return wr("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return wr("dispose")}};function wr(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function ER(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,xy(e,t,n)}function X6(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,xy(e,n,r),xy(t,n,r)}function Gh(e,t,n){return Math.max(e,Math.min(t,n))}function Q6(e){return e%2===0?e:e+1}function xy(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function J6(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Z6(e,t){let n=Math.random();return t*n+(1-n)*e}function Y6(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function D(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function er(e,t,n=""){D(Ws(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function vl(e){D(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function dt(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function eH(e){return e.length===0}function _R(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function Ws(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function zd(e){return e%1===0}function tH(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function nH(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function rH(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return ER(t),t}function kh(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function aH(e,t=a=>0,n,r){return new Promise((a,s)=>{let i=0,o=()=>{if(e()){a();return}i++;let l=t(i);if(n!=null&&i>=n){s();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function sH(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function va(e,t){let n=t.length;return e=e==null?t.map((r,a)=>a):[].concat(e),D(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),D(e.every(r=>zd(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function $R(e,t){let n=[],r=[],a=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||a?null:va(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function AR(e,t){return vk(e,t)}function vk(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function RR(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function FR(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function iH(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function wy(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function DR(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function fi(e){return typeof e=="string"||e instanceof String}function MR(e){return typeof e=="boolean"}function OR(e){return typeof e=="number"}function kf(e){return Array.isArray(e)?kf(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":OR(e)?"float32":fi(e)?"string":MR(e)?"bool":"float32"}function Ri(e){return!!(e&&e.constructor&&e.call&&e.apply)}function ky(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function dc(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function PR(e,t,n,r=!1){let a=new Array;if(t.length===1){let s=t[0]*(r?2:1);for(let i=0;i<s;i++)a[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((l,d)=>l*d)*(r?2:1);for(let l=0;l<s;l++)a[l]=PR(e+l*o,i,n,r)}return a}function Cd(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((a,s)=>a*s)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return PR(0,e,t,n)}function oH(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function xk(e,t){let n=Ib(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Ib(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function lH(e,t){let n=e.reduce((r,a)=>r*a,1);if(t==null||t==="float32")return Cd(e,new Float32Array(n));if(t==="int32")return Cd(e,new Int32Array(n));if(t==="bool")return Cd(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Br(e){e.forEach(t=>{D(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function uH(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function dH(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function Nb(e){return e&&e.then&&typeof e.then=="function"}var RT="tfjsflags",LR=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=cH,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(K().getBool("IS_TEST")||K().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];K().getBool("IS_TEST")||K().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Nb(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);RT in e&&e[RT].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=hH(n,r)})}};function cH(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(pH(t,r[0],r[1]),r.join("="))),t}function pH(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function hH(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function K(){return wk}var wk=null;function fH(e){wk=e}var Ox;function zR(){if(Ox==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");Ox=e}return Ox}function mH(){let e=zR();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function kk(e,t){let n=mH();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var cc="Abs",xl="Acos",wl="Acosh",Yi="Add",kl="AddN",pc="All",hc="Any",fc="ArgMax",mc="ArgMin",Sl="Asin",Il="Asinh",Nl="Atan",Cl="Atanh",Tl="Atan2",El="AvgPool",Sf="AvgPoolGrad",gc="AvgPool3D",If="AvgPool3DGrad",_l="BatchMatMul",yc="BatchToSpaceND",bc="Bincount",vc="BitwiseAnd",BR="BroadcastTo",Nf="BroadcastArgs",$l="Cast",Al="Ceil",eo="ClipByValue",Cb="Complex",Cf="ComplexAbs",xc="Concat",Rl="Conv2D",Tb="Conv2DBackpropFilter",Fl="Conv2DBackpropInput",Dl="Conv3D",wc="Conv3DBackpropFilterV2",kc="Conv3DBackpropInputV2",Ml="Cos",Ol="Cosh",Sc="Cumprod",Pl="Cumsum",Ic="CropAndResize",Tf="DenseBincount",Nc="DepthToSpace",Ll="DepthwiseConv2dNative",Eb="DepthwiseConv2dNativeBackpropFilter",_b="DepthwiseConv2dNativeBackpropInput",Ef="Diag",zl="Dilation2D",Bd="Dilation2DBackpropInput",Wd="Dilation2DBackpropFilter",$b="Draw",Bl="RealDiv",Ab="Einsum",Wl="Elu",Cc="EluGrad",Ul="Erf",Tc="Equal",Vl="Exp",Ec="ExpandDims",jl="Expm1",Rb="FFT",_f="Fill",_c="FlipLeftRight",Hl="Floor",Gl="FloorDiv",ql="FusedBatchNorm",$c="GatherV2",Ac="GatherNd",Rc="Greater",Kl="GreaterEqual",Xl="Identity",Fb="IFFT",Db="Imag",Ql="IsFinite",Jl="IsInf",Zl="IsNan",Yl="LeakyRelu",Fc="Less",Dc="LessEqual",Mc="LinSpace",eu="Log",tu="Log1p",Oc="LogicalAnd",Pc="LogicalNot",Lc="LogicalOr",WR="LogicalXor",UR="LogSoftmax",gH="LowerBound",nu="LRN",zc="LRNGrad",yH="MatrixBandPart",ru="Max",au="Maximum",su="MaxPool",$f="MaxPoolGrad",Bc="MaxPool3D",Af="MaxPool3DGrad",Rf="MaxPoolWithArgmax",iu="Mean",ou="Min",lu="Minimum",uu="MirrorPad",du="Mod",Wc="Multinomial",cu="Multiply",Uc="Neg",Vc="NotEqual",jc="NonMaxSuppressionV3",Hc="NonMaxSuppressionV4",Gc="NonMaxSuppressionV5",qc="OnesLike",pu="OneHot",Kc="Pack",hu="PadV2",bH="Pool",fu="Pow",mu="Prelu",gu="Prod",Mb="RaggedGather",Ob="RaggedRange",Pb="RaggedTensorToTensor",Ff="Range",Lb="Real",yu="Reciprocal",bu="Relu",Xc="Reshape",vu="ResizeNearestNeighbor",Qc="ResizeNearestNeighborGrad",xu="ResizeBilinear",Jc="ResizeBilinearGrad",wu="Relu6",ku="Reverse",Su="Round",Iu="Rsqrt",Zc="ScatterNd",Yc="TensorScatterUpdate",ep="SearchSorted",tp="Select",Nu="Selu",np="Slice",Cu="Sin",Tu="Sinh",Eu="Sign",_u="Sigmoid",$u="Softplus",Au="Sqrt",Ru="Sum",rp="SpaceToBatchND",ap="SplitV",Fu="Softmax",Df="SparseFillEmptyRows",sp="SparseReshape",Mf="SparseSegmentMean",Of="SparseSegmentSum",ip="SparseToDense",Du="SquaredDifference",Pf="Square",Lf="StaticRegexReplace",op="StridedSlice",zf="StringNGrams",Bf="StringSplit",Wf="StringToHashBucketFast",Mu="Sub",Ou="Tan",Pu="Tanh",to="Tile",lp="TopK",up="Transform",As="Transpose",Uf="Unique",dp="Unpack",Vf="UnsortedSegmentSum",vH="UpperBound",cp="ZerosLike",no="Step",Sy="FromPixels",pp="RotateWithOffset",Jo="_FusedMatMul",Zo="FusedConv2D",Yo="FusedDepthwiseConv2D";function di(...e){K().getBool("IS_TEST")||K().getBool("PROD")||console.warn(...e)}function xH(...e){K().getBool("IS_TEST")||K().getBool("PROD")||console.log(...e)}var Ud=kk("kernelRegistry",()=>new Map),qh=kk("gradRegistry",()=>new Map);function Kh(e,t){let n=Sk(e,t);return Ud.get(n)}function ow(e){return qh.get(e)}function Iy(e){let t=Ud.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function jf(e){let{kernelName:t,backendName:n}=e,r=Sk(t,n);Ud.has(r)&&di(`The kernel '${t}' for backend '${n}' is already registered`),Ud.set(r,e)}function VR(e){let{kernelName:t}=e;qh.has(t)&&K().getBool("DEBUG")&&di(`Overriding the gradient for '${t}'`),qh.set(t,e)}function wH(e,t){let n=Sk(e,t);if(!Ud.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Ud.delete(n)}function kH(e){if(!qh.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);qh.delete(e)}function SH(e,t){Iy(e).forEach(n=>{let r=Object.assign({},n,{backendName:t});jf(r)})}function Sk(e,t){return`${t}_${e}`}var k={};De(k,{arraysEqual:()=>Ws,arraysEqualWithNull:()=>_R,assert:()=>D,assertNonNegativeIntegerDimensions:()=>Br,assertNonNull:()=>vl,assertShapesMatch:()=>er,bytesFromStringArray:()=>DR,bytesPerElement:()=>wy,checkConversionForErrors:()=>RR,clamp:()=>Gh,computeStrides:()=>dc,convertBackendValuesAndArrayBuffer:()=>oH,createScalarValue:()=>_H,createShuffledIndices:()=>rH,decodeString:()=>Ny,distSquared:()=>Y6,encodeString:()=>Gf,fetch:()=>AH,fingerPrint64:()=>EH,flatten:()=>Fi,getArrayFromDType:()=>vk,getTypedArrayFromDType:()=>AR,hasEncodingLoss:()=>iH,hexToLong:()=>Hf,indexToLoc:()=>dH,inferDtype:()=>kf,inferFromImplicitShape:()=>sH,isBoolean:()=>MR,isFunction:()=>Ri,isInt:()=>zd,isNumber:()=>OR,isPromise:()=>Nb,isScalarShape:()=>eH,isString:()=>fi,isTypedArray:()=>gn,isValidDtype:()=>FR,locToIndex:()=>uH,makeOnesTypedArray:()=>xk,makeZerosNestedTypedArray:()=>lH,makeZerosTypedArray:()=>Ib,nearestDivisor:()=>ky,nearestLargerEven:()=>Q6,now:()=>Xh,parseAxisParam:()=>va,randUniform:()=>Z6,repeatedTry:()=>aH,rightPad:()=>kh,shuffle:()=>ER,shuffleCombo:()=>X6,sizeFromShape:()=>dt,sizeToSquarishShape:()=>nH,squeezeShape:()=>$R,sum:()=>J6,swap:()=>xy,tanh:()=>tH,toNestedArray:()=>Cd,toTypedArray:()=>zb});function jR(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var FT=Zi(R6()),Co=FT.default||FT;function Hf(e){return Co.fromString(e,!0,16)}var HR=Hf("c3a5c85c97cb3127"),So=Hf("b492b66fbe98f273"),jn=Hf("9ae16a3b2f90404f");function lw(e){return e.xor(e.shru(47))}function GR(e,t,n){let r=e.slice(t,t+n);return Co.fromBytes(Array.from(r),!0,!0)}function kt(e,t){return GR(e,t,8)}function DT(e,t){return GR(e,t,4)}function mn(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Ti(e,t,n=Hf("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function IH(e,t,n,r,a,s){a=a.add(e),s=mn(s.add(a).add(r),21);let i=a;return a=a.add(t),a=a.add(n),s=s.add(mn(a,44)),[a.add(r),s.add(i)]}function ig(e,t,n,r){return IH(kt(e,t),kt(e,t+8),kt(e,t+16),kt(e,t+24),n,r)}function NH(e,t=e.length){if(t>=8){let n=jn.add(t*2),r=kt(e,0).add(jn),a=kt(e,t-8),s=mn(a,37).mul(n).add(r),i=mn(r,25).add(a).mul(n);return Ti(s,i,n)}if(t>=4){let n=jn.add(t*2),r=DT(e,0);return Ti(r.shl(3).add(t),DT(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],a=e[t-1],s=n+(r<<8),i=t+(a<<2);return lw(jn.mul(s).xor(HR.mul(i))).mul(jn)}return jn}function CH(e,t=e.length){let n=jn.add(t*2),r=kt(e,0).mul(So),a=kt(e,8),s=kt(e,t-8).mul(n),i=kt(e,t-16).mul(jn);return Ti(mn(r.add(a),43).add(mn(s,30)).add(i),r.add(mn(a.add(jn),18)).add(s),n)}function TH(e,t=e.length){let n=jn.add(t*2),r=kt(e,0).mul(jn),a=kt(e,8),s=kt(e,t-8).mul(n),i=kt(e,t-16).mul(jn),o=mn(r.add(a),43).add(mn(s,30)).add(i),l=Ti(o,r.add(mn(a.add(jn),18)).add(s),n),d=kt(e,16).mul(n),u=kt(e,24),c=o.add(kt(e,t-32)).mul(n),p=l.add(kt(e,t-24)).mul(n);return Ti(mn(d.add(u),43).add(mn(c,30)).add(p),d.add(mn(u.add(r),18)).add(c),n)}function EH(e,t=e.length){let n=Co.fromNumber(81,!0);if(t<=32)return t<=16?NH(e,t):CH(e,t);if(t<=64)return TH(e,t);let r=n,a=n.mul(So).add(113),s=lw(a.mul(jn).add(113)).mul(jn),i=[Co.UZERO,Co.UZERO],o=[Co.UZERO,Co.UZERO];r=r.mul(jn).add(kt(e,0));let l=0,d=(t-1>>6)*64,u=d+(t-1&63)-63;do r=mn(r.add(a).add(i[0]).add(kt(e,l+8)),37).mul(So),a=mn(a.add(i[1]).add(kt(e,l+48)),42).mul(So),r=r.xor(o[1]),a=a.add(i[0]).add(kt(e,l+40)),s=mn(s.add(o[0]),33).mul(So),i=ig(e,l,i[1].mul(So),r.add(o[0])),o=ig(e,l+32,s.add(o[1]),a.add(kt(e,l+16))),[s,r]=[r,s],l+=64;while(l!==d);let c=So.add(s.and(255).shl(1));return l=u,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=mn(r.add(a).add(i[0]).add(kt(e,l+8)),37).mul(c),a=mn(a.add(i[1]).add(kt(e,l+48)),42).mul(c),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(kt(e,l+40))),s=mn(s.add(o[0]),33).mul(c),i=ig(e,l,i[1].mul(c),r.add(o[0])),o=ig(e,l+32,s.add(o[1]),a.add(kt(e,l+16))),[s,r]=[r,s],Ti(Ti(i[0],o[0],c).add(lw(a).mul(HR)).add(s),Ti(i[1],o[1],c).add(r),c)}function _H(e,t){return t==="string"?Gf(e):zb([e],t)}function $H(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function zb(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Fi(e)),K().getBool("DEBUG")&&RR(e,t),$H(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Xh(){return K().platform.now()}function AH(e,t){return K().platform.fetch(e,t)}function Gf(e,t="utf-8"){return t=t||"utf-8",K().platform.encode(e,t)}function Ny(e,t="utf-8"){return t=t||"utf-8",K().platform.decode(e,t)}function gn(e){return K().platform.isTypedArray!=null?K().platform.isTypedArray(e):jR(e)}function Fi(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||Nb(e)||e==null||gn(e)&&n)t.push(e);else if(Array.isArray(e)||gn(e))for(let r=0;r<e.length;++r)Fi(e[r],t,n);else{let r=-1;for(let a of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(a)&&(r=Math.max(r,Number(a)));for(let a=0;a<=r;a++)Fi(e[a],t,n)}return t}var RH=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new DH)}profileKernel(e,t,n){let r,a=()=>{r=n()},s,i=Xh();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(let o of r)o.dataSync();s=Promise.resolve({kernelMs:Xh()-i})}if(K().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(d=>{FH(d,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),r,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],a,o[2])})})}};function FH(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let a=e[r];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${n}'`),!0}return!1}var DH=class{logKernelProfile(e,t,n,r,a,s){let i=typeof r=="number"?kh(`${r}ms`,9):r.error,o=kh(e,25),l=t.rank,d=t.size,u=kh(t.shape.toString(),14),c="";for(let p in a){let h=a[p];if(h!=null){let f=h.shape||t.shape,m=f.length;c+=`${p}: ${m}D ${m>0?f:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${u}	%c${d}	%c${c}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function MH(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let d=e[l],u=d.inputs;for(let c in u){let p=u[c],h=!1;for(let f=0;f<t.length;f++)if(r[p.id]){d.outputs.forEach(m=>r[m.id]=!0),h=!0,a[d.id]=!0;break}if(h)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let d=e[l],u=d.inputs;for(let c=0;c<d.outputs.length;c++)if(s[d.outputs[c].id]){for(let p in u)s[u[p].id]=!0,i[d.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let d=e[l];if(a[d.id]&&i[d.id]){let u={};for(let p in d.inputs){let h=d.inputs[p];r[h.id]&&(u[p]=h)}let c=Object.assign({},d);c.inputs=u,c.outputs=d.outputs,o.push(c)}}return o}function OH(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach(l=>{let d=e[l.id];d!=null?i.push(d):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let d=n(()=>o[l]());if(d.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${d.dtype}'`);let u=s.inputs[l];if(!Ws(d.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${d.shape}', which does not match the shape of the input '${u.shape}'`);if(e[u.id]==null)e[u.id]=d;else{let c=e[u.id];e[u.id]=r(c,d),c.dispose()}}}}var MT=20,Kp=3,Px=7;function PH(e,t,n,r){let a=dc(t),s=LH(e,t,n,a),i=t.length,o=Lg(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(d=>"    "+d).join(`
`)),l.join(`
`)}function LH(e,t,n,r){let a=dt(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l=n==="complex64"?ah(e):e;if(o>1)for(let d=0;d<a/s;d++){let u=d*s;for(let c=0;c<s;c++)i[c]=Math.max(i[c],rh(l[u+c],0,n).length)}return i}function rh(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(Px))} + ${parseFloat(e[1].toFixed(Px))}j`:fi(e)?r=`'${e}'`:n==="bool"?r=qR(e):r=parseFloat(e.toFixed(Px)).toString(),kh(r,t)}function qR(e){return e===0?"false":"true"}function Lg(e,t,n,r,a,s=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let m=ah(e);return[rh(m[0],0,n)]}return n==="bool"?[qR(e[0])]:[e[0].toString()]}if(l===1){if(o>MT){let m=Kp*i,g=Array.from(e.slice(0,m)),y=Array.from(e.slice((o-Kp)*i,o*i));return n==="complex64"&&(g=ah(g),y=ah(y)),["["+g.map((b,v)=>rh(b,a[v],n)).join(", ")+", ..., "+y.map((b,v)=>rh(b,a[o-Kp+v],n)).join(", ")+"]"]}return["["+(n==="complex64"?ah(e):Array.from(e)).map((m,g)=>rh(m,a[g],n)).join(", ")+"]"]}let d=t.slice(1),u=r.slice(1),c=r[0]*i,p=[];if(o>MT){for(let m=0;m<Kp;m++){let g=m*c,y=g+c;p.push(...Lg(e.slice(g,y),d,n,u,a,!1))}p.push("...");for(let m=o-Kp;m<o;m++){let g=m*c,y=g+c;p.push(...Lg(e.slice(g,y),d,n,u,a,m===o-1))}}else for(let m=0;m<o;m++){let g=m*c,y=g+c;p.push(...Lg(e.slice(g,y),d,n,u,a,m===o-1))}let h=l===2?",":"";p[0]="["+(o>0?p[0]+h:"");for(let m=1;m<p.length-1;m++)p[m]=" "+p[m]+h;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(s?"":f),p}function ah(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Yt=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=dt(e),n!=null){let r=n.length;D(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||vk(t,this.size),this.strides=dc(e)}set(e,...t){t.length===0&&(t=[0]),D(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return _a().makeTensor(this.values,this.shape,this.dtype)}},_a=null,rd=null;function zH(e){_a=e}function BH(e){rd=e}var Pe=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=dt(e),this.strides=dc(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return rd.buffer(this.shape,this.dtype,e)}bufferSync(){return rd.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Cd(this.shape,e,this.dtype==="complex64")}arraySync(){return Cd(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=_a().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>Ny(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),_a().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=_a().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Ny(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await _a().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),_a().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return rd.print(this,e)}clone(){return this.throwIfDisposed(),rd.clone(this)}toString(e=!1){let t=this.dataSync();return PH(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),rd.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),_a().makeVariable(this,e,t,n)}};Object.defineProperty(Pe,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function ne(){return kk("Tensor",()=>Pe)}ne();var el=class extends Pe{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ws(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);_a().disposeTensor(this),this.dataId=e.dataId,_a().incRef(this,null)}dispose(){_a().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(el,Symbol.hasInstance,{value:e=>e instanceof Pe&&e.assign!=null&&e.assign instanceof Function});var Ra={};De(Ra,{assertTypesMatch:()=>QR,getTensorsInContainer:()=>Ik,isTensorInList:()=>UH,makeTypesMatch:()=>Ot});var uw;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(uw||(uw={}));var dw;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(dw||(dw={}));var cw;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(cw||(cw={}));var pw;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(pw||(pw={}));var hw;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(hw||(hw={}));var WH={float32:pw,int32:dw,bool:cw,complex64:hw};function ea(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return WH[e][t]}function Bb(e){return ea(e,"int32")}function KR(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function XR(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Ot(e,t){if(e.dtype===t.dtype)return[e,t];let n=ea(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function QR(e,t){D(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function UH(e,t){return t.some(n=>n.id===e.id)}function Ik(e){let t=[];return JR(e,t,new Set),t}function JR(e,t,n){if(e==null)return;if(e instanceof Pe){t.push(e);return}if(!VH(e))return;let r=e;for(let a in r){let s=r[a];n.has(s)||(n.add(s),JR(s,t,n))}}function VH(e){return Array.isArray(e)||typeof e=="object"}function Lx(e){return e.kernelName!=null}var OT=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Nk=class fw{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new OT}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(di(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new RH(this.backendInstance),!0}setupRegisteredKernels(){Iy(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Iy(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=n.factory();if(r&&!(r instanceof wf)&&typeof r.then=="function"){let a=++this.pendingBackendInitId,s=r.then(i=>a<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(a<this.pendingBackendInitId||(this.pendingBackendInit=null,di(`Initialization of backend ${t} failed`),di(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return di(`Initialization of backend ${t} failed`),di(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n],{success:a,asyncInit:s}=this.initializeBackend(r);if(s||a)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let r=this.state.tensorInfo.get(n),a=r.backend,s=this.readSync(n),i=a.refCount(n);a.disposeData(n,!0),r.backend=t,t.move(n,s,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let a;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(a),()=>(a=n(),a instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),a))}scopedRun(t,n,r){t();try{let a=r();return n(),a}catch(a){throw n(),a}}nextTensorId(){return fw.nextTensorId++}nextVariableId(){return fw.nextVariableId++}clone(t){let n=L.runKernel(Xl,{x:t}),r={x:t},a=i=>({x:()=>{let o="float32",l={x:i},d={dtype:o};return L.runKernel($l,l,d)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[n],a,s,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,Kh(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){let a=this.backend.numDataIds(),s=0;r.forEach(l=>{s+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=a-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,d=Lx(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Lx(t)){let{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;let y=Kh(f,this.backendName);D(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{let b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});let v=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,v);let x=v.map(w=>w.rank!=null?w:this.makeTensorFromTensorInfo(w));if(a){let w=this.getTensorsForGradient(f,m,x);r=this.saveTensorsForBackwardMode(w)}return x}}else{let{forwardFunc:f}=t,m=g=>{a&&(r=g.map(y=>this.keep(this.clone(y))))};o=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));let y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,g,y),y}}let{inputs:u,attrs:c}=t,p=Lx(t)?null:t.backwardsFunc,h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(h=this.profiler.profileKernel(d,u,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),n=h.outputs)}),a&&this.addTapeNode(d,u,n,p,r,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,r){let a=ow(t);if(a!=null){let s=a.inputsToSave||[],i=a.outputsToSave||[],o;a.saveAllInputs?(D(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(d=>n[d])):o=s.map(d=>n[d]);let l=r.filter((d,u)=>i[u]);return o.concat(l)}return[]}makeTensor(t,n,r,a){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",a=a||this.backend;let s=t;r==="string"&&fi(t[0])&&(s=t.map(l=>Gf(l)));let i=a.write(s,n,r),o=new Pe(n,r,i,this.nextTensorId());if(this.trackTensor(o,a),r==="string"){let l=this.state.tensorInfo.get(i),d=DR(s);this.state.numBytes+=d-l.bytes,l.bytes=d}return o}makeTensorFromDataId(t,n,r,a){r=r||"float32";let s={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(s,a)}makeTensorFromTensorInfo(t,n){let{dataId:r,shape:a,dtype:s}=t,i=new Pe(a,s,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,a){r=r||this.nextVariableId().toString(),a!=null&&a!==t.dtype&&(t=t.cast(a));let s=new el(t,n,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*wy(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof el||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let r=t.size*wy(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(a=>a.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,a,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:s},l=ow(t);l!=null&&(a=l.gradFunc),a!=null&&(o.gradient=d=>(d=d.map((u,c)=>{if(u==null){let p=r[c],h=Ib(p.size,p.dtype);return this.makeTensor(h,p.shape,p.dtype)}return u}),a(d.length>1?d:d[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=Ik(t),r=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!r.has(i.id)&&i.dispose()}let a=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===a.id&&this.track(s)})}gradients(t,n,r,a=!1){if(D(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));D(s instanceof Pe,()=>"The result y returned by f() must be a tensor.");let i=MH(this.state.activeTape,n,s);if(!a&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=r??jH(s.shape),OH(o,i,d=>this.tidy(d),HH);let l=n.map(d=>o[d.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(d=>{for(let u of d.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return D(Ri(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{D(n.every(o=>o instanceof Pe),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,a={};n.forEach((o,l)=>{a[l]=o});let s=(o,l)=>(r=t(...n,l),D(r.value instanceof Pe,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(Ri(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{let d=r.gradFunc(o,l),u=Array.isArray(d)?d:[d];D(u.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(u.every(p=>p instanceof Pe),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let c={};return u.forEach((p,h)=>{c[h]=()=>p}),c};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:a})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=Xh(),r=await this.backend.time(t);return r.wallMs=Xh()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new OT;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Nk.nextTensorId=0;Nk.nextVariableId=0;function jH(e){let t=xk(dt(e),"float32");return L.makeTensor(t,e,"float32")}function ZR(){let e=zR();if(e._tfengine==null){let t=new LR(e);e._tfengine=new Nk(t)}return fH(e._tfengine.ENV),zH(()=>e._tfengine),e._tfengine}var L=ZR();function HH(e,t){let n={a:e,b:t};return L.runKernel(Yi,n)}var qf={};De(qf,{isBrowser:()=>YR,isMobile:()=>KH,mockIsMobile:()=>qH});function GH(){return typeof navigator<"u"&&navigator!=null}var mw;function qH(e){mw=e}function KH(e){if(mw!==void 0)return mw;if(e||GH()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function YR(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var hr=K();hr.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});hr.registerFlag("IS_BROWSER",()=>YR());hr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");hr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));hr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));hr.registerFlag("PROD",()=>!1);hr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>hr.getBool("DEBUG"));hr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);hr.registerFlag("IS_TEST",()=>!1);hr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>hr.getBool("DEBUG"));hr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);hr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);hr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function us(e,t){let n=e;if(gn(e))return t==="string"?[]:[e.length];if(KR(e)){let a=e.channels||"RGBA";return[e.height,e.width*a.length]}else if(XR(e))return[e.buffer.size/(t==null?4:wy(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||gn(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&K().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&eF(e,r,[]),r}function eF(e,t,n){if(n=n||[],!Array.isArray(e)&&!gn(e)){D(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}D(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),D(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let a=0;a<e.length;++a)eF(e[a],r,n.concat(a))}function PT(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function _(e,t,n,r="numeric"){if(e instanceof ne())return PT(r,e.dtype,t,n),e;let a=kf(e);if(a!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),PT(r,a,t,n),e==null||!gn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=us(e,a);!gn(e)&&!Array.isArray(e)&&(e=[e]);let i=a!=="string"?zb(e,a):Fi(e,[],!0);return L.makeTensor(i,s,a)}function Qh(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,s)=>_(a,`${t}[${s}]`,n,r))}var Ck="__op";function z(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+Ck;let a=(...s)=>{L.startScope(n);try{let i=r(...s);return Nb(i)&&console.error("Cannot return a Promise inside of tidy."),L.endScope(i),i}catch(i){throw L.endScope(null),i}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}function XH(e,t){let n=_(e,"real","complex"),r=_(t,"imag","complex");er(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return L.runKernel(Cb,a)}var Ls=z({complex_:XH});function ro(e,t,n,r){if(r==null)r=kf(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(XR(e)||KR(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return L.backend.createTensorFromGPUData(e,t||n,r)}if(!gn(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Br(t);let a=dt(t),s=dt(n);D(a===s,()=>`Based on the provided shape, [${t}], the tensor should have ${a} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==dt(t.slice(i)):!0;D(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!gn(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?zb(e,r):Fi(e,[],!0),L.makeTensor(e,t,r)}function Xn(e,t,n){let r=us(e,n);return ro(e,t,r,n)}var tl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Us=class tF{static join(t){return new tF(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>gn(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){let a=t[r];r!==t.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+a.byteLength;this.shards.push({buffer:a,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);let a=n-t,s=new ArrayBuffer(a),i=new Uint8Array(s),o=0;for(let l=r;l<this.shards.length;l++){let d=this.shards[l],u=t+o-d.start,c=o,p=Math.min(n,d.end)-d.start,h=new Uint8Array(d.buffer,u,p-u);if(i.set(h,c),o+=h.length,n<d.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(a){return t<a.start?-1:t>=a.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=QH(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function QH(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,s=t(e[a]);if(s===0)return a;s<0?r=a:n=a+1}return-1}function JH(){K().set("PROD",!0)}function ZH(){K().set("DEBUG",!0)}function YH(){K().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function nF(e){K().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function eG(){L.disposeVariables()}function ua(){return L}function gw(){return L.memory()}function tG(e){return L.profile(e)}function j(e,t){return L.tidy(e,t)}function Fe(e){Ik(e).forEach(t=>t.dispose())}function sn(e){return L.keep(e)}function nG(e){return L.time(e)}function rG(e){return L.setBackend(e)}function aG(){return L.ready()}function rF(){return L.backendName}function sG(e){L.removeBackend(e)}function iG(e){return L.findBackend(e)}function oG(e){return L.findBackendFactory(e)}function Wb(e,t,n=1){return L.registerBackend(e,t,n)}function Tk(){return L.backend}function lG(e,t){K().setPlatform(e,t)}var Di=4;async function uG(e,t){let n=[],r=[],a=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<a.length;++i){let o=a[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let d={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let u=new Promise(async c=>{let p=await l.bytes(),h=p.reduce((g,y)=>g+y.length,0)+Di*p.length,f=new Uint8Array(h),m=0;for(let g=0;g<p.length;g++){let y=p[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=Di,f.set(y,m),m+=y.length}c(f)});r.push(u)}else r.push(l.data());t!=null&&(d.group=t),n.push(d)}let s=await Promise.all(r);return{data:pG(s),specs:n}}function aF(e,t){let n=new Us(e),r={},a=0;for(let s of t){let i=dG(s,(o,l)=>n.slice(a+o,a+l));r[s.name]=sF(s,n.slice(a,a+i)),a+=i}return r}function dG(e,t){let n=dt(e.shape),r;if("quantization"in e){let a=e.quantization;r=tl[a.dtype]}else if(e.dtype==="string"){let a=0;for(let s=0;s<n;s++)a+=Di+new Uint32Array(t(a,a+Di))[0];return a}else r=tl[e.dtype];return n*r}async function cG(e,t){let n=dt(e.shape),r;if("quantization"in e){let a=e.quantization;r=tl[a.dtype]}else if(e.dtype==="string"){let a=0;for(let s=0;s<n;s++)a+=Di+new Uint32Array(await t(a,a+Di))[0];return a}else r=tl[e.dtype];return n*r}function sF(e,t){let n=e.name,r=e.dtype,a=e.shape,s=dt(a),i,o=0;if("quantization"in e){let l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let d=tl[l.dtype],u=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(u.length);for(let c=0;c<u.length;c++){let p=u[c];i[c]=p*l.scale+l.min}}else if(l.dtype==="float16")i=vG()(u);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let c=0;c<u.length;c++){let p=u[c];i[c]=Math.round(p*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*d}else if(r==="string"){let l=dt(e.shape);i=[];for(let d=0;d<l;d++){let u=new Uint32Array(t.slice(o,o+Di))[0];o+=Di;let c=new Uint8Array(t.slice(o,o+u));i.push(c),o+=u}}else{let l=tl[r];if(r==="float32")i=new Float32Array(t);else if(r==="int32")i=new Int32Array(t);else if(r==="bool")i=new Uint8Array(t);else if(r==="complex64"){i=new Float32Array(t);let d=new Float32Array(i.length/2),u=new Float32Array(i.length/2);for(let f=0;f<d.length;f++)d[f]=i[f*2],u[f]=i[f*2+1];let c=Xn(d,a,"float32"),p=Xn(u,a,"float32"),h=Ls(c,p);return c.dispose(),p.dispose(),h}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*l}return Xn(i,a,r)}async function LT(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:a,value:s}=await e.read();if(a&&s==null){let o=n-r.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer}async function iF(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let s of t){let i=await cG(s,async(d,u)=>(a=await LT(r,a,u),a.slice(d,u)));a=await LT(r,a,i);let o=a.slice(0,i);a=a.slice(i);let l=sF(s,o);if(n[s.name]=l,rF()==="webgpu"){let d=Tk();"uploadToGPU"in d&&dt(l.shape)>=K().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&d.uploadToGPU(l.dataId)}}return n}function pG(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(t),a=0;return n.forEach(s=>{r.set(new Uint8Array(s.buffer),a),a+=s.byteLength}),r.buffer}var Ek=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function zT(e){return Ek?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function hG(e){if(Ek)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function fG(e){if(Ek){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function mG(e){return Us.join(e)}function BT(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function oF(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function lF(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function _k(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),lF(e,n,r)}function Kf(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:zT(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:zT(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Us(e.weightData).byteLength}}function yw(e){let t=[];for(let n of e)t.push(...n.weights);return t}function gG(){let e=n=>{let r=n<<13,a=0;for(;!(r&8388608);)a-=8388608,r<<=1;return r&=-8388609,a+=947912704,r|a},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function yG(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function bG(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function vG(){let e=gG(),t=yG(),n=bG();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(a)}}var ta=class Ia{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ia.instance==null&&(Ia.instance=new Ia),Ia.instance}static registerSaveRouter(t){Ia.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Ia.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Ia.getHandlers(t,"save")}static getLoadHandlers(t,n){return Ia.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return(n==="load"?Ia.getInstance().loadRouters:Ia.getInstance().saveRouters).forEach(s=>{let i=s(t,r);i!==null&&a.push(i)}),a}},xG=e=>ta.registerSaveRouter(e),wG=e=>ta.registerLoadRouter(e),kG=e=>ta.getSaveHandlers(e),SG=(e,t)=>ta.getLoadHandlers(e,t),bw="tensorflowjs",vw=1,Mo="models_store",mi="model_info_store";function uF(){if(!K().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function xw(e){let t=e.result;t.createObjectStore(Mo,{keyPath:"modelPath"}),t.createObjectStore(mi,{keyPath:"modelPath"})}var nl=class{constructor(e){if(this.indexedDB=uF(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let a=this.indexedDB.open(bw,vw);a.onupgradeneeded=()=>xw(a),a.onsuccess=()=>{let s=a.result;if(t==null){let i=s.transaction(Mo,"readonly"),o=i.objectStore(Mo).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),r(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=Us.join(t.weightData);let i=Kf(t),o=s.transaction(mi,"readwrite"),l=o.objectStore(mi),d;try{d=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(c){return r(c)}let u;d.onsuccess=()=>{u=s.transaction(Mo,"readwrite");let c=u.objectStore(Mo),p;try{p=c.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(h){return r(h)}p.onsuccess=()=>n({modelArtifactsInfo:i}),p.onerror=h=>{l=o.objectStore(mi);let f=l.delete(this.modelPath);f.onsuccess=()=>(s.close(),r(p.error)),f.onerror=m=>(s.close(),r(p.error))}},d.onerror=c=>(s.close(),r(d.error)),o.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}}},a.onerror=s=>r(a.error)})}};nl.URL_SCHEME="indexeddb://";var dF=e=>K().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(nl.URL_SCHEME)?IG(e.slice(nl.URL_SCHEME.length)):null;ta.registerSaveRouter(dF);ta.registerLoadRouter(dF);function IG(e){return new nl(e)}function NG(e){return e.startsWith(nl.URL_SCHEME)?e.slice(nl.URL_SCHEME.length):e}var CG=class{constructor(){this.indexedDB=uF()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(bw,vw);n.onupgradeneeded=()=>xw(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(mi,"readonly"),s=a.objectStore(mi).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=NG(e),new Promise((t,n)=>{let r=this.indexedDB.open(bw,vw);r.onupgradeneeded=()=>xw(r),r.onsuccess=()=>{let a=r.result,s=a.transaction(mi,"readwrite"),i=s.objectStore(mi),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let d=i.delete(e),u=()=>{l=a.transaction(Mo,"readwrite");let c=l.objectStore(Mo).delete(e);c.onsuccess=()=>t(o.result.modelArtifactsInfo),c.onerror=p=>n(o.error)};d.onsuccess=u,d.onerror=c=>(u(),a.close(),n(o.error))}},o.onerror=d=>(a.close(),n(o.error)),s.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},r.onerror=a=>n(r.error)})}},Ts="/",ad="tensorflowjs_models",cF="info",TG="model_topology",EG="weight_specs",_G="weight_data",$G="model_metadata";function pF(e){return{info:[ad,e,cF].join(Ts),topology:[ad,e,TG].join(Ts),weightSpecs:[ad,e,EG].join(Ts),weightData:[ad,e,_G].join(Ts),modelMetadata:[ad,e,$G].join(Ts)}}function hF(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function AG(e){let t=e.split(Ts);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Ts)}function RG(e){return e.startsWith(rl.URL_SCHEME)?e.slice(rl.URL_SCHEME.length):e}var rl=class{constructor(e){if(!K().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=pF(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Kf(e),a=Us.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,hG(a));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch{throw hF(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){let i=JSON.parse(a);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=fG(s),t}};rl.URL_SCHEME="localstorage://";var fF=e=>K().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(rl.URL_SCHEME)?FG(e.slice(rl.URL_SCHEME.length)):null;ta.registerSaveRouter(fF);ta.registerLoadRouter(fF);function FG(e){return new rl(e)}var DG=class{constructor(){D(K().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=ad+Ts,n=Ts+cF;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){let s=AG(a);e[s]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=RG(e);let t=pF(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return hF(t),n}},Td="://",Mi=class ti{constructor(){this.managers={}}static getInstance(){return ti.instance==null&&(ti.instance=new ti),ti.instance}static registerManager(t,n){D(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Td)&&(t=t.slice(0,t.indexOf(Td))),D(t.length>0,()=>"scheme must not be an empty string.");let r=ti.getInstance();D(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=ti.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(ti.getInstance().managers)}};function zg(e){if(e.indexOf(Td)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Mi.getSchemes().join(",")}`);return{scheme:e.split(Td)[0],path:e.split(Td)[1]}}async function mF(e,t,n=!1){D(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=ta.getLoadHandlers(e);D(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),D(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let a=r[0],s=ta.getSaveHandlers(t);D(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),D(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=s[0],o=zg(e).scheme,l=zg(e).path,d=o===zg(e).scheme,u=await a.load();n&&d&&await Mi.getManager(o).removeModel(l);let c=await i.save(u);return n&&!d&&await Mi.getManager(o).removeModel(l),c.modelArtifactsInfo}async function MG(){let e=Mi.getSchemes(),t={};for(let n of e){let r=await Mi.getManager(n).listModels();for(let a in r){let s=n+Td+a;t[s]=r[a]}}return t}async function OG(e){let t=zg(e);return Mi.getManager(t.scheme).removeModel(t.path)}async function PG(e,t){return mF(e,t,!1)}async function LG(e,t){return mF(e,t,!0)}var zG=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!K().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return jR(e)}};if(K().get("IS_BROWSER")){K().setPlatform("browser",new zG);try{Mi.registerManager(rl.URL_SCHEME,new DG)}catch{}try{Mi.registerManager(nl.URL_SCHEME,new CG)}catch{}}var BG={importFetch:()=>F6()},zx,WG=class{constructor(){this.util=D6(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return K().global.fetch!=null?K().global.fetch(e,t):(zx==null&&(zx=BG.importFetch()),zx(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};K().get("IS_NODE")&&!K().get("IS_BROWSER")&&K().setPlatform("node",new WG);function Ve(e,t="float32",n){return t=t||"float32",Br(e),new Yt(e,t,n)}function UG(e,t){let n=_(e,"x","cast");if(!FR(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return L.runKernel($l,r,a)}var ue=z({cast_:UG});function VG(e){let t={x:_(e,"x","clone","string_or_numeric")};return L.runKernel(Xl,t)}var is=z({clone_:VG});function $k(e,t=!1){console.log(e.toString(t))}ZR();var jG={buffer:Ve,cast:ue,clone:is,print:$k};BH(jG);function HG(e,t){let n=_(e,"a","add"),r=_(t,"b","add");[n,r]=Ot(n,r);let a={a:n,b:r};return L.runKernel(Yi,a)}var te=z({add_:HG});function GG(e,t){let n=_(e,"a","floorDiv"),r=_(t,"b","floorDiv");[n,r]=Ot(n,r);let a={a:n,b:r};return L.runKernel(Gl,a)}var Ub=z({floorDiv_:GG});function qG(e,t){let n=_(e,"a","div"),r=_(t,"b","div");if([n,r]=Ot(n,r),n.dtype==="int32"&&r.dtype==="int32")return Ub(n,r);let a={a:n,b:r},s={};return L.runKernel(Bl,a,s)}var be=z({div_:qG});function KG(e,t){let n=_(e,"a","mul"),r=_(t,"b","mul");[n,r]=Ot(n,r);let a={a:n,b:r};return L.runKernel(cu,a)}var W=z({mul_:KG});function XG(e){let t=_(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return L.runKernel(Cf,n)}else{let n={x:t};return L.runKernel(cc,n)}}var Xt=z({abs_:XG});function QG(e){let t={x:_(e,"x","acos")};return L.runKernel(xl,t)}var Ak=z({acos_:QG});function JG(e){let t={x:_(e,"x","acosh")};return L.runKernel(wl,t)}var Rk=z({acosh_:JG});function ZG(e){D(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),D(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((a,s)=>_(a,`tensors${s}`,"addN")),n=t[0];t.forEach(a=>{if(a.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(a=>{if(!Ws(a.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return L.runKernel(kl,r)}var gF=z({addN_:ZG});function YG(e,t=null,n=!1){let r={x:_(e,"x","all","bool")},a={axis:t,keepDims:n};return L.runKernel(pc,r,a)}var Vb=z({all_:YG});function e8(e,t=null,n=!1){let r={x:_(e,"x","any","bool")},a={axis:t,keepDims:n};return L.runKernel(hc,r,a)}var Jh=z({any_:e8});function t8(e,t=0){let n={x:_(e,"x","argMax")},r={axis:t};return L.runKernel(fc,n,r)}var al=z({argMax_:t8});function n8(e,t=0){let n={x:_(e,"x","argMin")},r={axis:t};return L.runKernel(mc,n,r)}var Fk=z({argMin_:n8});function r8(e){let t={x:_(e,"x","asin")};return L.runKernel(Sl,t)}var Dk=z({asin_:r8});function a8(e){let t={x:_(e,"x","asinh")};return L.runKernel(Il,t)}var Mk=z({asinh_:a8});function s8(e){let t={x:_(e,"x","atan")};return L.runKernel(Nl,t)}var Ok=z({atan_:s8});function i8(e,t){let n=_(e,"a","atan2"),r=_(t,"b","atan2");[n,r]=Ot(n,r);let a={a:n,b:r};return L.runKernel(Tl,a)}var Pk=z({atan2_:i8});function o8(e){let t={x:_(e,"x","atanh")};return L.runKernel(Cl,t)}var Lk=z({atanh_:o8});function l8(e,t,n,r,a="NHWC",s){let i=e[3],o=[...t,i],l=vF(a);return Xf(e,o,n,s,r,null,null,l)}function yF(e,t,n,r,a,s,i="channelsLast"){let[o,l]=Zh(t),d;if(i==="channelsLast")d=[o,l,e[3],e[3]];else if(i==="channelsFirst")d=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Xf(e,d,n,r,a,s,!1,i)}function u8(e,t,n,r,a,s,i="NDHWC"){let[o,l,d]=ww(t),u,c;if(i==="NDHWC")c="channelsLast",u=[o,l,d,e[4],e[4]];else if(i==="NCDHW")c="channelsFirst",u=[o,l,d,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return bF(e,u,n,r,a,!1,c,s)}function Xf(e,t,n,r,a,s,i=!1,o="channelsLast"){let[l,d,u,c]=[-1,-1,-1,-1];if(o==="channelsLast")[l,d,u,c]=e;else if(o==="channelsFirst")[l,c,d,u]=e;else throw new Error(`Unknown dataFormat ${o}`);let[p,h,,f]=t,[m,g]=Zh(n),[y,b]=Zh(r),v=Ed(p,y),x=Ed(h,b),{padInfo:w,outHeight:I,outWidth:N}=p8(a,d,u,m,g,v,x,s,o),T=i?f*c:f,A;return o==="channelsFirst"?A=[l,T,I,N]:o==="channelsLast"&&(A=[l,I,N,T]),{batchSize:l,dataFormat:o,inHeight:d,inWidth:u,inChannels:c,outHeight:I,outWidth:N,outChannels:T,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:p,filterWidth:h,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:A,filterShape:t}}function bF(e,t,n,r,a,s=!1,i="channelsLast",o){let[l,d,u,c,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,d,u,c,p]=e;else if(i==="channelsFirst")[l,p,d,u,c]=e;else throw new Error(`Unknown dataFormat ${i}`);let[h,f,m,,g]=t,[y,b,v]=ww(n),[x,w,I]=ww(r),N=Ed(h,x),T=Ed(f,w),A=Ed(m,I),{padInfo:R,outDepth:F,outHeight:C,outWidth:M}=h8(a,d,u,c,y,b,v,N,T,A,o),B=s?g*p:g,U;return i==="channelsFirst"?U=[l,B,F,C,M]:i==="channelsLast"&&(U=[l,F,C,M,B]),{batchSize:l,dataFormat:i,inDepth:d,inHeight:u,inWidth:c,inChannels:p,outDepth:F,outHeight:C,outWidth:M,outChannels:B,padInfo:R,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:N,effectiveFilterHeight:T,effectiveFilterWidth:A,dilationDepth:x,dilationHeight:w,dilationWidth:I,inShape:e,outShape:U,filterShape:t}}function d8(e,t,n,r,a){r==null&&(r=zk(e,t,n));let s=e[0],i=e[1],o=Yh((s-t+2*r)/n+1,a),l=Yh((i-t+2*r)/n+1,a);return[o,l]}function c8(e,t,n,r,a,s){a==null&&(a=zk(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=Yh((e[o]-t[o]+2*a)/r[o]+1,s));return i}function zk(e,t,n,r=1){let a=Ed(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function Zh(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function ww(e){return typeof e=="number"?[e,e,e]:e}function Ed(e,t){return t<=1?e:e+(e-1)*(t-1)}function p8(e,t,n,r,a,s,i,o,l){let d,u,c;if(typeof e=="number"){d={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let p=d8([t,n],s,r,e,o);u=p[0],c=p[1]}else if(e==="same"){u=Math.ceil(t/r),c=Math.ceil(n/a);let p=Math.max(0,(u-1)*r+s-t),h=Math.max(0,(c-1)*a+i-n),f=Math.floor(p/2),m=p-f,g=Math.floor(h/2),y=h-g;d={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(e==="valid")d={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-s+1)/r),c=Math.ceil((n-i+1)/a);else if(typeof e=="object"){let p=l==="channelsLast"?e[1][0]:e[2][0],h=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];d={top:p,bottom:h,left:f,right:m,type:p===0&&h===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=Yh((t-s+p+h)/r+1,o),c=Yh((n-i+f+m)/a+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outHeight:u,outWidth:c}}function h8(e,t,n,r,a,s,i,o,l,d,u){let c,p,h,f;if(e==="valid"&&(e=0),typeof e=="number"){c={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let m=c8([t,n,r,1],[o,l,d],1,[a,s,i],e,u);p=m[0],h=m[1],f=m[2]}else if(e==="same"){p=Math.ceil(t/a),h=Math.ceil(n/s),f=Math.ceil(r/i);let m=(p-1)*a+o-t,g=(h-1)*s+l-n,y=(f-1)*i+d-r,b=Math.floor(m/2),v=m-b,x=Math.floor(g/2),w=g-x,I=Math.floor(y/2),N=y-I;c={top:x,bottom:w,left:I,right:N,front:b,back:v,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outDepth:p,outHeight:h,outWidth:f}}function Yh(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Oi(e){let[t,n,r]=Zh(e);return t===1&&n===1&&r===1}function fs(e,t){return Oi(e)||Oi(t)}function sl(e){return Zh(e).every(t=>t>0)}function vF(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function tr(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")D(zd(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(a=>{D(zd(a),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${a}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function f8(e,t){let n={x:_(e,"x","reshape","string_or_numeric")},r={shape:t};return L.runKernel(Xc,n,r)}var V=z({reshape_:f8});function m8(e,t,n,r,a){let s=_(e,"x","avgPool","float32"),i=1;D(fs(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=V(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),tr("avgPool",r,a);let d={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=L.runKernel(El,d,u);return c=ue(c,s.dtype),l?V(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Vs=z({avgPool_:m8});function g8(e,t,n,r,a,s="NDHWC"){let i=_(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),D(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),D(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),tr("avgPool3d",r,a);let d={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},c=L.runKernel(gc,d,u);return c=ue(c,o.dtype),l?V(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var Bk=z({avgPool3d_:g8});function y8(e,t=0){D(e.length>=1,()=>"Pass at least one tensor to concat");let n=Qh(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return is(n[0]);let r=n,a={axis:t};return L.runKernel(xc,r,a)}var gt=z({concat_:y8});function b8(e,t,n=!1,r=!1){let a=_(e,"a","matMul"),s=_(t,"b","matMul");[a,s]=Ot(a,s);let i={a,b:s},o={transposeA:n,transposeB:r};return L.runKernel(_l,i,o)}var We=z({matMul_:b8});function v8(e){let t={x:_(e,"x","sigmoid","float32")};return L.runKernel(_u,t)}var ma=z({sigmoid_:v8});function x8(e,t,n){let r=_(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return L.runKernel(np,a,s)}var Xe=z({slice_:x8});function w8(e){let t={x:_(e,"x","tanh","float32")};return L.runKernel(Pu,t)}var Pi=z({tanh_:w8});function k8(e,t,n,r,a,s){let i=_(e,"forgetBias","basicLSTMCell"),o=_(t,"lstmKernel","basicLSTMCell"),l=_(n,"lstmBias","basicLSTMCell"),d=_(r,"data","basicLSTMCell"),u=_(a,"c","basicLSTMCell"),c=_(s,"h","basicLSTMCell"),p=gt([d,c],1),h=We(p,o),f=te(h,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Xe(f,[0,0],y),v=Xe(f,[0,g],y),x=Xe(f,[0,g*2],y),w=Xe(f,[0,g*3],y),I=te(W(ma(b),Pi(v)),W(u,ma(te(i,x)))),N=W(Pi(I),ma(w));return[I,N]}var xF=z({basicLSTMCell_:k8});function S8(e,t,n){let r=_(e,"x","batchToSpaceND"),a=t.reduce((o,l)=>o*l);D(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),D(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),D(r.shape[0]%a===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`);let s={x:r},i={blockShape:t,crops:n};return L.runKernel(yc,s,i)}var Qf=z({batchToSpaceND_:S8});function I8(e){let t;return e.rank===0||e.rank===1?t=V(e,[1,1,1,e.size]):e.rank===2?t=V(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=V(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function N8(e,t,n,r,a,s){s==null&&(s=.001);let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),d;a!=null&&(d=_(a,"scale","batchNorm"));let u;r!=null&&(u=_(r,"offset","batchNorm")),D(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let c={x:I8(i),scale:d,offset:u,mean:o,variance:l},p={varianceEpsilon:s},h=L.runKernel(ql,c,p);return V(h,i.shape)}var Lu=z({batchNorm_:N8});function C8(e,t,n,r,a,s){let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),d;a!=null&&(d=_(a,"scale","batchNorm"));let u;return r!=null&&(u=_(r,"offset","batchNorm")),D(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),D(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),d!=null&&D(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${d.rank}.`),u!=null&&D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),Lu(i,o,l,u,d,s)}var Wk=z({batchNorm2d_:C8});function T8(e,t,n,r,a,s){let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),d;a!=null&&(d=_(a,"scale","batchNorm"));let u;return r!=null&&(u=_(r,"offset","batchNorm")),D(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),D(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),d!=null&&D(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${d.rank}.`),u!=null&&D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),Lu(i,o,l,u,d,s)}var Uk=z({batchNorm3d_:T8});function E8(e,t,n,r,a,s){let i=_(e,"x","batchNorm"),o=_(t,"mean","batchNorm"),l=_(n,"variance","batchNorm"),d;a!=null&&(d=_(a,"scale","batchNorm"));let u;return r!=null&&(u=_(r,"offset","batchNorm")),D(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),D(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),d!=null&&D(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${d.rank}.`),u!=null&&D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),Lu(i,o,l,u,d,s)}var Vk=z({batchNorm4d_:E8});function _8(e,t,n){let r=_(e,"x","bincount"),a=_(t,"weights","bincount");D(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),D(n>=0,()=>`size must be non-negative, but got ${n}.`),D(a.size===r.size||a.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`);let s={x:r,weights:a},i={size:n};return L.runKernel(bc,s,i)}var jk=z({bincount_:_8});function $8(e,t){let n=_(e,"x","bitwiseAnd"),r=_(t,"y","bitwiseAnd");if(!Ws(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return L.runKernel(vc,a)}var wF=z({bitwiseAnd_:$8});function A8(e,t){let n=_(e,"s0","broadcastArgs","int32"),r=_(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return L.runKernel(Nf,a)}var kF=z({broadcastArgs_:A8});function R8(e,t){let n=_(e,"broadcastTo","x"),r=n.shape;if(Br(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=V(n,l)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(s.map((l,d)=>l>1?d:-1).filter(l=>l>=0).length===0)return is(n);let i={x:n},o={reps:s};return L.runKernel(to,i,o)}var Bo=z({broadcastTo_:R8});function F8(e){let t={x:_(e,"x","ceil","float32")};return L.runKernel(Al,t)}var Hk=z({ceil_:F8});function Dr(e,t,n){Br(e),n=n||kf(t);let r={shape:e,value:t,dtype:n};return L.runKernel(_f,{},r)}function D8(e,t,n){let r=_(e,"x","clipByValue");if(D(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Dr(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return L.runKernel(eo,a,s)}var On=z({clipByValue_:D8});function M8(e){return gt(e,0)}var Gk=z({concat1d_:M8});function O8(e,t){return gt(e,t)}var qk=z({concat2d_:O8});function P8(e,t){return gt(e,t)}var Kk=z({concat3d_:P8});function L8(e,t){return gt(e,t)}var Xk=z({concat4d_:L8});function z8(e,t,n,r,a="NHWC",s=[1,1],i){let o=_(e,"x","conv2d","float32"),l=_(t,"filter","conv2d","float32"),d=o,u=!1;o.rank===3&&(u=!0,d=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(d.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${d.rank}.`),D(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),tr("conv2d",r,i);let c=a==="NHWC"?d.shape[3]:d.shape[1];D(c===l.shape[2],()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${l.shape[2]}.`),D(fs(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),D(sl(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),D(sl(n),()=>"Error in conv2D: Strides should be larger than 0.");let p={x:d,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=L.runKernel(Rl,p,h);return u?V(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Jn=z({conv2d_:z8});function B8(e,t,n,r,a="NWC",s=1,i){let o=_(e,"x","conv1d"),l=_(t,"filter","conv1d"),d=o,u=!1;o.rank===2&&(u=!0,d=V(o,[1,o.shape[0],o.shape[1]])),D(d.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${d.rank}.`),D(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),tr("conv1d",r,i),D(d.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${d.shape[2]}) must match input depth for filter ${l.shape[1]}.`),D(fs(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),D(sl(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),D(sl(n),()=>"Error in conv1D: Stride should be larger than 0."),D(a==="NWC",()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);let c=V(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=V(d,[d.shape[0],1,d.shape[1],d.shape[2]]),h=Jn(p,c,[1,n],r,"NHWC",[1,s],i);return u?V(h,[h.shape[2],h.shape[3]]):V(h,[h.shape[0],h.shape[2],h.shape[3]])}var jb=z({conv1d_:B8});function W8(e,t,n,r,a,s="NHWC",i){D(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,d=!1;t.rank===3&&(d=!0,l=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),D(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),D(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),D(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let u=s==="NHWC"?o[3]:o[1],c=s==="NHWC"?l.shape[3]:l.shape[1];D(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),D(c===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[3]}.`),tr("conv2dDerInput",a,i);let p={dy:l,filter:n},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=L.runKernel(Fl,p,h);return d?V(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Qk=z({conv2DBackpropInput_:W8});function U8(e,t,n,r,a,s){let i=_(e,"x","conv2dTranspose"),o=_(t,"filter","conv2dTranspose");return Qk(n,i,o,r,a,"NHWC",s)}var Hb=z({conv2dTranspose_:U8});function V8(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=_(e,"x","conv3d"),o=_(t,"filter","conv3d"),l=i,d=!1;i.rank===4&&(d=!0,l=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),D(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),D(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),D(fs(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),D(a==="NDHWC",()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`),D(sl(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),D(sl(n),()=>"Error in conv3D: Strides should be larger than 0.");let u={x:l,filter:o},c={strides:n,pad:r,dataFormat:a,dilations:s},p=L.runKernel(Dl,u,c);return d?V(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Jk=z({conv3d_:V8});function j8(e,t,n,r,a){D(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=V(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],d=i.shape[4];D(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),D(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),D(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),D(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),D(d===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[4]}.`);let u={dy:i,filter:n},c={pad:a,strides:r,inputShape:s},p=L.runKernel(kc,u,c);return o?V(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var SF=z({conv3DBackpropInput_:j8});function H8(e,t,n,r,a){let s=_(e,"x","conv3dTranspose"),i=_(t,"filter","conv3dTranspose");return SF(n,s,i,r,a)}var Zk=z({conv3dTranspose_:H8});function G8(e){let t={x:_(e,"x","cos","float32")};return L.runKernel(Ml,t)}var Jf=z({cos_:G8});function q8(e){let t={x:_(e,"x","cosh","float32")};return L.runKernel(Ol,t)}var Gb=z({cosh_:q8});function K8(e,t=0,n=!1,r=!1){let a={x:_(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return L.runKernel(Sc,a,s)}var ef=z({cumprod_:K8});function X8(e,t=0,n=!1,r=!1){let a={x:_(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return L.runKernel(Pl,a,s)}var qb=z({cumsum_:X8});function Q8(e,t,n,r=!1){let a=_(e,"x","denseBincount"),s=_(t,"weights","denseBincount");D(a.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),D(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),D(n>=0,()=>`size must be non-negative, but got ${n}.`),D(s.size===a.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`);let i={x:a,weights:s},o={size:n,binaryOutput:r};return L.runKernel(Tf,i,o)}var Cy=z({denseBincount_:Q8});function J8(e,t,n="NHWC"){let r=_(e,"x","depthToSpace","float32"),a=n==="NHWC"?r.shape[1]:r.shape[2],s=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];D(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),D(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t}  for depthToSpace with input shape
    ${r.shape}`),D(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${r.shape}`),D(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let o={x:r},l={blockSize:t,dataFormat:n};return L.runKernel(Nc,o,l)}var Yk=z({depthToSpace_:J8});function Z8(e,t,n,r,a="NHWC",s=[1,1],i){let o=_(e,"x","depthwiseConv2d","float32"),l=_(t,"filter","depthwiseConv2d","float32"),d=o,u=!1;o.rank===3&&(u=!0,d=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(d.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),D(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let c=a==="NHWC"?d.shape[3]:d.shape[1];D(c===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c}) must match the inChannels dimension in filter ${l.shape[2]}.`),tr("depthwiseConv2d",r,i);let p={x:d,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=L.runKernel(Ll,p,h);return u?V(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var zu=z({depthwiseConv2d_:Z8});function Y8(e){let t={x:_(e,"x","diag")};return L.runKernel(Ef,t)}var IF=z({diag_:Y8});function eq(e,t,n,r,a=[1,1],s="NHWC"){let i=_(e,"x","dilation2d"),o=_(t,"filter","dilation2d");D(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),D(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),D(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,d=!1;i.rank===3&&(l=V(i,[1,i.shape[0],i.shape[1],i.shape[2]]),d=!0),D(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let u={x:l,filter:o},c={strides:n,pad:r,dilations:a},p=L.runKernel(zl,u,c);return d?V(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var eS=z({dilation2d_:eq}),hp={};De(hp,{assertAndGetBroadcastShape:()=>yt,getBroadcastDims:()=>NF,getReductionAxes:()=>tn});function NF(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&i===1&&r.unshift(s)}return r}function tn(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(a==null||a===1&&i>1)&&n.unshift(s)}return n}function yt(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];s==null&&(s=1);let i=t[t.length-a-1];if(i==null&&(i=1),s===1)r[n-a-1]=i;else if(i===1)r[n-a-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-a-1]=s}return r}function tq(e,t){let n=_(e,"a","equal","string_or_numeric"),r=_(t,"b","equal","string_or_numeric");[n,r]=Ot(n,r),yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(Tc,a)}var Or=z({equal_:tq});function nq(e,t,n){let r=_(t,"a","where"),a=_(n,"b","where"),s=_(e,"condition","where","bool"),i=yt(yt(s.shape,r.shape),a.shape),o=Bo(s,i),l=Bo(r,i),d=Bo(a,i),u={condition:o,t:l,e:d};return L.runKernel(tp,u)}var xn=z({where_:nq});function rq(e){let t={x:_(e,"x","zerosLike")};return L.runKernel(cp,t)}var Ze=z({zerosLike_:rq});function aq(e,t){let n=_(e,"a","div"),r=_(t,"b","div");[n,r]=Ot(n,r);let a=be(n,r),s=Ze(a),i=Or(r,s);return xn(i,s,a)}var tS=z({divNoNan_:aq});function sq(e,t){let n=_(e,"t1","dot"),r=_(t,"t2","dot");D((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let a=n.rank===1?n.size:n.shape[1],s=r.rank===1?r.size:r.shape[0];if(D(a===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`),n.rank===1&&r.rank===1){let i=V(n,[1,-1]),o=V(r,[-1,1]),l=We(i,o);return V(l,[])}else if(n.rank===1&&r.rank===2){let i=V(n,[1,-1]),o=V(r,[r.shape[0],r.shape[1]]),l=We(i,o);return V(l,[l.size])}else if(n.rank===2&&r.rank===1){let i=V(r,[-1,1]),o=We(n,i);return V(o,[o.size])}else{let i=V(r,[r.shape[0],r.shape[1]]);return We(n,i)}}var nS=z({dot_:sq});function iq(e,...t){let n=t.map((a,s)=>_(a,`tensors${s}`,"einsum")),r={equation:e};return L.runKernel(Ab,n,r)}var To=z({einsum_:iq});function oq(e){let t={x:_(e,"x","elu","float32")};return L.runKernel(Wl,t)}var fp=z({elu_:oq});function lq(e,t){let n=_(e,"x","ensureShape","string_or_numeric");if(!_R(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var CF=z({ensureShape_:lq});function uq(e){let t=_(e,"x","erf");D(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=ue(t,"float32"));let n={x:t};return L.runKernel(Ul,n)}var Kb=z({erf_:uq});function rS(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function TF(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?a.push(e[s++]):a.push(t[i++]);return a}function EF(e,t){let n=[],r=e.length;for(let s=0;s<r;s++)t.indexOf(s)===-1&&n.push(e[s]);let a=t.map(s=>e[s]);return[n,a]}function il(e,t){let n=t.map(r=>1);return TF(e,n,t)}function dq(e,t,n){D(rS(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function _F(e,t){if(rS(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function aS(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function cq(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function pq(e,t=null,n=!1){let r={x:_(e,"x","max")},a={reductionIndices:t,keepDims:n};return L.runKernel(ru,r,a)}var Zr=z({max_:pq});function hq(e,t=null,n=!1){let r={x:_(e,"x","min")},a={axis:t,keepDims:n};return L.runKernel(ou,r,a)}var Vd=z({min_:hq});function fq(e,t){let n=_(e,"base","pow"),r=_(t,"exp","pow");[n,r]=Ot(n,r);let a={a:n,b:r};return L.runKernel(fu,a)}var ds=z({pow_:fq});function Ce(e,t){if((gn(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&gn(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ro(e,[],[],t)}function mq(e){let t={x:_(e,"x","sqrt","float32")};return L.runKernel(Au,t)}var wn=z({sqrt_:mq});function gq(e){let t=_(e,"x","square"),n={};return L.runKernel("Square",{x:t},n)}var ft=z({square_:gq});function yq(e,t=null,n=!1){let r=_(e,"x","sum");r.dtype==="bool"&&(r=ue(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return L.runKernel(Ru,a,s)}var ke=z({sum_:yq});function bq(e,t="euclidean",n=null,r=!1){e=_(e,"x","norm");let a=$F(e,t,n),s=a.shape;if(r){let i=va(n,e.shape);s=il(a.shape,i)}return V(a,s)}function $F(e,t,n=null){if(e.rank===0)return Xt(e);if(e.rank!==1&&n===null)return $F(V(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ke(Xt(e),n);if(t===1/0)return Zr(Xt(e),n);if(t===-1/0)return Vd(Xt(e),n);if(t==="euclidean"||t===2)return wn(ke(ds(Xt(e),Ce(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Zr(ke(Xt(e),n[0]),n[1]-1);if(t===1/0)return Zr(ke(Xt(e),n[1]),n[0]);if(t===-1/0)return Vd(ke(Xt(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return wn(ke(ft(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var mp=z({norm_:bq});function vq(e,t=null,n=!1){return mp(e,"euclidean",t,n)}var sS=z({euclideanNorm_:vq});function xq(e){let t={x:_(e,"x","exp")};return L.runKernel(Vl,t)}var Pn=z({exp_:xq});function wq(e,t=0){let n=_(e,"x","expandDims","string_or_numeric");D(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},a={dim:t};return L.runKernel(Ec,r,a)}var yn=z({expandDims_:wq});function kq(e){let t={x:_(e,"x","expm1")};return L.runKernel(jl,t)}var iS=z({expm1_:kq});function Sq(e,t){let n=_(e,"x","tile","string_or_numeric");D(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},a={reps:t};return L.runKernel(to,r,a)}var Er=z({tile_:Sq});function Iq(e,t,n,r="float32"){t==null&&(t=e);let a=Ve([e,t],r),s=e<=t?e:t;for(let o=0;o<s;++o)a.set(1,o,o);let i=V(a.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Er(yn(i,0),[n[0],1,1]);if(n.length===2)return Er(yn(yn(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Er(yn(yn(yn(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var Xb=z({eye_:Iq});function Nq(e){let t={x:_(e,"x","floor","float32")};return L.runKernel(Hl,t)}var gp=z({floor_:Nq});function Cq(e,t,n=0,r=0){let a=_(e,"x","gather"),s=_(t,"indices","gather","int32"),i={x:a,indices:s},o={axis:n,batchDims:r};return L.runKernel($c,i,o)}var yp=z({gather_:Cq});function Tq(e,t){let n=_(e,"a","greater","string_or_numeric"),r=_(t,"b","greater","string_or_numeric");[n,r]=Ot(n,r),yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(Rc,a)}var nr=z({greater_:Tq});function Eq(e,t){let n=_(e,"a","greaterEqual","string_or_numeric"),r=_(t,"b","greaterEqual","string_or_numeric");[n,r]=Ot(n,r),yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(Kl,a)}var js=z({greaterEqual_:Eq});function _q(e){let t={input:_(e,"input","imag")};return L.runKernel(Db,t)}var Zf=z({imag_:_q});function $q(e){let t={x:_(e,"x","isFinite")};return L.runKernel(Ql,t)}var oS=z({isFinite_:$q});function Aq(e){let t={x:_(e,"x","isInf")};return L.runKernel(Jl,t)}var lS=z({isInf_:Aq});function Rq(e){let t={x:_(e,"x","isNaN")};return L.runKernel(Zl,t)}var uS=z({isNaN_:Rq});function Fq(e,t=.2){let n={x:_(e,"x","leakyRelu")},r={alpha:t};return L.runKernel(Yl,n,r)}var Yf=z({leakyRelu_:Fq});function Dq(e,t){let n=_(e,"a","less","string_or_numeric"),r=_(t,"b","less","string_or_numeric");[n,r]=Ot(n,r),yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(Fc,a)}var jd=z({less_:Dq});function Mq(e,t){let n=_(e,"a","lessEqual","string_or_numeric"),r=_(t,"b","lessEqual","string_or_numeric");[n,r]=Ot(n,r),yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(Dc,a)}var ao=z({lessEqual_:Mq});function AF(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return L.runKernel(Mc,{},r)}function Oq(e,t=5,n=1,r=1,a=.5){let s=_(e,"x","localResponseNormalization");D(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),D(zd(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=V(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},d={depthRadius:t,bias:n,alpha:r,beta:a},u=L.runKernel(nu,l,d);return o?V(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var dS=z({localResponseNormalization_:Oq});function Pq(e){let t={x:_(e,"x","log","float32")};return L.runKernel(eu,t)}var Pr=z({log_:Pq});function Lq(e){let t={x:_(e,"x","log1p")};return L.runKernel(tu,t)}var em=z({log1p_:Lq});function zq(e){return D(Ri(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=_(t,"x","tf.grad","string_or_numeric"),a=n!=null?_(n,"dy","tf.grad"):null;return L.tidy(()=>{let{value:s,grads:i}=L.gradients(()=>e(r),[r],a);return a!=null&&er(s.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Qb(i),i[0]})}}function Bq(e){return D(Ri(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{D(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=Qh(t,"args","tf.grads","string_or_numeric"),a=n!=null?_(n,"dy","tf.grads"):null;return L.tidy(()=>{let{value:s,grads:i}=L.gradients(()=>e(...r),r,a);return a!=null&&er(s.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Qb(i),i})}}function Wq(e){return D(Ri(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{D(t instanceof Pe,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),D(n==null||n instanceof Pe,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:a}=L.gradients(()=>e(t),[t],n);return Qb(r),{grad:r[0],value:a}}}function Uq(e){return D(Ri(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{D(Array.isArray(t)&&t.every(a=>a instanceof Pe),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),D(n==null||n instanceof Pe,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=L.gradients(()=>e(...t),t,n);return n!=null&&er(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Qb(r.grads),r}}function RF(e,t){D(Ri(e),()=>"The f passed in variableGrads(f) must be a function"),D(t==null||Array.isArray(t)&&t.every(d=>d instanceof el),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let d in L.registeredVariables)t.push(L.registeredVariables[d])}let r=n?t.filter(d=>!d.trainable):null,a=t.length;t=t.filter(d=>d.trainable),D(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);let s=!0,{value:i,grads:o}=L.gradients(e,t,null,s);D(o.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((d,u)=>{o[u]!=null&&(l[d.name]=o[u])}),r!=null&&r.forEach(d=>l[d.name]=null),{value:i,grads:l}}function cs(e){return L.customGrad(e)}function Qb(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Vq(e){let t={x:_(e,"x","neg")};return L.runKernel(Uc,t)}var St=z({neg_:Vq});function jq(e){let t={x:_(e,"x","softplus")};return L.runKernel($u,t)}var Bu=z({softplus_:jq});function Hq(e){let t=_(e,"x","logSigmoid");return cs(n=>({value:St(Bu(St(n))),gradFunc:r=>W(r,ma(St(n)))}))(t)}var cS=z({logSigmoid_:Hq});function Gq(e,t){let n=_(e,"a","sub"),r=_(t,"b","sub");[n,r]=Ot(n,r);let a={a:n,b:r};return L.runKernel(Mu,a)}var me=z({sub_:Gq});function qq(e,t=-1){let n=_(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return cs((r,a)=>{let s=Zr(r,t,!0),i=me(r,s),o=me(ue(i,"float32"),Pr(ke(Pn(i),t,!0)));return a([o]),{value:o,gradFunc:(l,d)=>{let[u]=d,c=!0,p=Pn(u);return me(l,W(ke(l,t,c),p))}}})(n)}var Jb=z({logSoftmax_:qq});function Kq(e,t=null,n=!1){let r=_(e,"x","logSumExp"),a=va(t,r.shape),s=Zr(r,a,!0),i=me(r,s),o=Pn(i),l=ke(o,a),d=Pr(l),u=te(V(s,d.shape),d);if(n){let c=il(u.shape,a);return V(u,c)}return u}var tm=z({logSumExp_:Kq});function Xq(e,t){let n=_(e,"a","logicalAnd","bool"),r=_(t,"b","logicalAnd","bool");yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(Oc,a)}var ba=z({logicalAnd_:Xq});function Qq(e){let t={x:_(e,"x","logicalNot","bool")};return L.runKernel(Pc,t)}var nm=z({logicalNot_:Qq});function Jq(e,t){let n=_(e,"a","logicalOr","bool"),r=_(t,"b","logicalOr","bool");yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(Lc,a)}var Zb=z({logicalOr_:Jq});function Zq(e,t){let n=_(e,"a","logicalXor","bool"),r=_(t,"b","logicalXor","bool");return yt(n.shape,r.shape),ba(Zb(e,t),nm(ba(e,t)))}var pS=z({logicalXor_:Zq}),og=2147483648;function Yq(e,t,n="left"){let r=_(e,"sortedSequence","searchSorted"),a=_(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=V(r,[-1,s]),l=V(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(dt(l.shape)>=og)throw new Error(`values tensor size must less than ${og}`);if(o.shape[1]>=og)throw new Error(`trailing dim_size must less than ${og} for int32 output type, was ${o.shape[1]}`);let d={sortedSequence:o,values:l},u={side:n};return L.runKernel(ep,d,u)}var Yb=z({searchSorted_:Yq});function FF(e,t){return Yb(e,t,"left")}function eK(e,t,n,r,a){let s=_(e,"x","maxPool"),i=1,o=s,l=!1;s.rank===3&&(l=!0,o=V(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),D(fs(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),tr("maxPool",r,a);let d={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=L.runKernel(su,d,u);return l?V(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var hn=z({maxPool_:eK});function tK(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=_(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),D(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),tr("maxPool3d",r,a);let d={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},c=L.runKernel(Bc,d,u);return l?V(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var hS=z({maxPool3d_:tK});function nK(e,t,n,r,a=!1){let s={x:_(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=L.runKernel(Rf,s,i);return{result:o[0],indexes:o[1]}}var DF=z({maxPoolWithArgmax_:nK});function rK(e,t){let n=_(e,"a","maximum"),r=_(t,"b","maximum");[n,r]=Ot(n,r),n.dtype==="bool"&&(n=ue(n,"int32"),r=ue(r,"int32")),yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(au,a)}var ms=z({maximum_:rK});function aK(e,t=null,n=!1){let r={x:_(e,"x","mean")},a={axis:t,keepDims:n};return L.runKernel(iu,r,a)}var Ft=z({mean_:aK});function Dt(e,t="float32"){if(Br(e),t==="complex64"){let r=Dt(e,"float32"),a=Dt(e,"float32");return Ls(r,a)}let n=Ib(dt(e),t);return L.makeTensor(n,e,t)}function ur(e,t="float32"){if(Br(e),t==="complex64"){let r=ur(e,"float32"),a=Dt(e,"float32");return Ls(r,a)}let n=xk(dt(e),t);return L.makeTensor(n,e,t)}function MF(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=_(e,"x","meshgrid",e instanceof Pe?e.dtype:"float32");if(t===void 0)return[r];let a=_(t,"y","meshgrid",t instanceof Pe?t.dtype:"float32"),s=dt(r.shape),i=dt(a.shape);return n==="xy"?(r=V(r,[1,-1]),a=V(a,[-1,1]),[We(ur([i,1],r.dtype),r),We(a,ur([1,s],a.dtype))]):(r=V(r,[-1,1]),a=V(a,[1,-1]),[We(r,ur([1,i],r.dtype)),We(ur([s,1],a.dtype),a)])}function sK(e,t){let n=_(e,"a","minimum"),r=_(t,"b","minimum");[n,r]=Ot(n,r),n.dtype==="bool"&&(n=ue(n,"int32"),r=ue(r,"int32")),yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(lu,a)}var Li=z({minimum_:sK});function iK(e,t,n){D(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=_(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let a=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)D(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`);let s={paddings:t,mode:n},i={x:r};return L.runKernel(uu,i,s)}var fS=z({mirrorPad_:iK});function oK(e,t){let n=_(e,"a","mod"),r=_(t,"b","mod");[n,r]=Ot(n,r);let a={a:n,b:r};return L.runKernel(du,a)}var mS=z({mod_:oK});function lK(e,t=null,n=!1){e=_(e,"x","moments");let r=va(t,e.shape),a=Ft(e,r,n),s=a.shape;n||(s=il(a.shape,r));let i=ft(me(ue(e,"float32"),V(a,s))),o=Ft(i,r,n);return{mean:a,variance:o}}var rm=z({moments_:lK});function uK(e,t,n,r){let a=_(t,"data","multiRNNCell"),s=Qh(n,"c","multiRNNCell"),i=Qh(r,"h","multiRNNCell"),o=a,l=[];for(let c=0;c<e.length;c++){let p=e[c](o,s[c],i[c]);l.push(p[0]),l.push(p[1]),o=p[1]}let d=[],u=[];for(let c=0;c<l.length;c+=2)d.push(l[c]),u.push(l[c+1]);return[d,u]}var OF=z({multiRNNCell_:uK});function dK(e,t,n,r=!1){let a=_(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?V(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},d=L.runKernel(Wc,o,l);return i===1?V(d,[d.size]):d}var PF=z({multinomial_:dK});function cK(e,t){let n=_(e,"a","notEqual","string_or_numeric"),r=_(t,"b","notEqual","string_or_numeric");[n,r]=Ot(n,r),yt(n.shape,r.shape);let a={a:n,b:r};return L.runKernel(Vc,a)}var ol=z({notEqual_:cK});function pK(e,t,n=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:_(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return L.runKernel(pu,s,i)}var Hd=z({oneHot_:pK});function hK(e){let t={x:_(e,"x","onesLike")};return L.runKernel(qc,t)}var Lr=z({onesLike_:hK});function fK(e,t){let n=_(e,"v1","outerProduct"),r=_(t,"v2","outerProduct");D(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let a=V(n,[-1,1]),s=V(r,[1,-1]);return We(a,s)}var LF=z({outerProduct_:fK});function mK(e,t,n=0){let r=_(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return L.runKernel(hu,s,a)}var Ua=z({pad_:mK});function gK(e,t,n=0){return D(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ua(e,[t],n)}var zF=z({pad1d_:gK});function yK(e,t,n=0){return D(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ua(e,t,n)}var BF=z({pad2d_:yK});function bK(e,t,n=0){return D(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ua(e,t,n)}var WF=z({pad3d_:bK});function vK(e,t,n=0){return D(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ua(e,t,n)}var UF=z({pad4d_:vK});function xK(e,t,n){let r=_(e,"x","spaceToBatchND");D(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),D(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),D(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let a={x:r},s={blockShape:t,paddings:n};return L.runKernel(rp,a,s)}var am=z({spaceToBatchND_:xK});function wK(e,t,n,r,a,s,i){a==null&&(a=[1,1]),s==null&&(s=1),r===0&&(r="valid");let o=_(e,"x","maxPool"),l=o,d=!1;o.rank===3&&(d=!0,l=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(fs(s,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);let u=yF(l.shape,t,s,a,r),c=[u.dilationHeight,u.dilationWidth],p;r==="same"?p=SK([u.filterHeight,u.filterWidth],c):p=[[0,0],[0,0]];let h=c[0]===1&&c[1]===1,[f,m]=kK([u.inHeight,u.inWidth],c,p),g=h?r:"valid",y=h?l:am(l,c,f),b=(n==="avg"?()=>Vs(y,t,s,g,i):()=>hn(y,t,s,g,i))(),v=h?b:Qf(b,c,m);return d?V(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function kK(e,t,n){let r=n.map(u=>u[0]),a=n.map(u=>u[1]),s=e.concat(r,a),i=t.map((u,c)=>(u-s[c]%u)%u),o=a.map((u,c)=>u+i[c]),l=t.map((u,c)=>[r[c],o[c]]),d=t.map((u,c)=>[0,i[c]]);return[l,d]}function SK(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),r=n.map(s=>Math.floor(s/2)),a=n.map((s,i)=>s-r[i]);return n.map((s,i)=>[r[i],a[i]])}var gS=z({pool_:wK});function IK(e,t){let n=_(e,"x","prelu"),r=_(t,"alpha","prelu"),a={x:n,alpha:r};return L.runKernel(mu,a)}var sm=z({prelu_:IK});function NK(e,t=null,n=!1){let r=_(e,"x","prod");r.dtype==="bool"&&(r=ue(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return L.runKernel(gu,a,s)}var yS=z({prod_:NK});function CK(e,t,n,r){let a=e.map((u,c)=>_(u,`tensors${c}`,"raggedGather","int32")),s=_(t,"paramsDenseValues","raggedGather"),i=_(n,"indices","raggedGather","int32"),o={paramsNestedSplits:a,paramsDenseValues:s,indices:i},l={outputRaggedRank:r},d=L.runKernel(Mb,o,l);return{outputNestedSplits:d.slice(0,d.length-1),outputDenseValues:d[d.length-1]}}var VF=z({raggedGather_:CK});function TK(e,t,n){let r=_(e,"starts","raggedRange"),a=_(t,"limits","raggedRange",r.dtype),s=_(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:a,deltas:s},o=L.runKernel(Ob,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var jF=z({raggedRange_:TK});function EK(e,t,n,r,a){let s=_(e,"shape","raggedTensorToTensor","int32"),i=_(t,"values","raggedTensorToTensor"),o=_(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((c,p)=>_(c,`tensors${p}`,"raggedTensorToTensor","int32")),d={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},u={rowPartitionTypes:a};return L.runKernel(Pb,d,u)}var HF=z({raggedTensorToTensor_:EK});function _K(e,t,n){Br(e);let r=dt(e),a=null;if(n==null||n==="float32")a=new Float32Array(r);else if(n==="int32")a=new Int32Array(r);else if(n==="bool")a=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<r;s++)a[s]=t();return L.makeTensor(a,e,n)}var GF=z({rand_:_K}),bS=Zi(kb()),qF={};De(qF,{TEST_EPSILON_FLOAT16:()=>KF,createVideoElement:()=>PK,encodeStrings:()=>XF,expectArrayBuffersEqual:()=>OK,expectArraysClose:()=>AK,expectArraysEqual:()=>FK,expectNumbersClose:()=>DK,expectPromiseToFail:()=>RK,expectValuesInRange:()=>MK,play:()=>LK,testEpsilon:()=>vS});var $K=.001,KF=.1;function AK(e,t,n){return n==null&&(n=vS()),kw(e,t,(r,a)=>xS(r,a,n))}function vS(){return L.backend.floatPrecision()===32?$K:KF}function kw(e,t,n){let r=!0;if((gn(e)||gn(t))&&(r=!1),gn(e)&&gn(t)&&(r=!0),r){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=us(e),o=us(t);if(!Ws(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let a=gn(e)?e:Fi(e),s=gn(t)?t:Fi(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.
Actual:   ${a}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let o=a[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${a}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function RK(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function FK(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return fi(e)||fi(e[0])||fi(t)||fi(t[0])?kw(e,n,(r,a)=>r==a):kw(e,t,(r,a)=>xS(r,a,0))}function DK(e,t,n){if(n==null&&(n=vS()),!xS(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function xS(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function MK(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function OK(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function XF(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?XF(n):e[t]=Gf(n)}return e}function PK(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function LK(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var wS=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=a||Math.random();this.random=bS.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,a,s;do r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},zK=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=bS.alea(a.toString()),this.randn=new wS(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do r=this.randn.nextValue(),s=1+this.c*r;while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},BK=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=bS.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function WK(e,t,n=1,r="float32",a){if(Br(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new zK(t,n,r,a),i=Ve(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var QF=z({randomGamma_:WK});function UK(e,t=0,n=1,r,a){if(Br(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new wS(t,n,r,!1,a),i=Ve(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var ev=z({randomNormal_:UK});function VK(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return ev(e,0,1,t,n)}var JF=z({randomStandardNormal_:VK});function jK(e,t=0,n=1,r="float32",a){Br(e);let s=Ve(e,r),i=new BK(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var so=z({randomUniform_:jK});function HK(e,t,n,r){return so(e,t,n,"int32",r)}var ZF=z({randomUniformInt_:HK});function ll(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return L.runKernel(Ff,{},a)}function GK(e){let t={input:_(e,"input","real")};return L.runKernel(Lb,t)}var Gd=z({real_:GK});function qK(e){let t={x:_(e,"x","reciprocal")};return L.runKernel(yu,t)}var kS=z({reciprocal_:qK});function KK(e){let t={x:_(e,"x","relu")};return L.runKernel(bu,t)}var ut=z({relu_:KK});function XK(e){let t={x:_(e,"x","relu6")};return L.runKernel(wu,t)}var tv=z({relu6_:XK});function QK(e,t){let n={x:_(e,"x","reverse")},r={dims:t};return L.runKernel(ku,n,r)}var na=z({reverse_:QK});function JK(e){let t=_(e,"x","reverse");return D(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),na(t,0)}var YF=z({reverse1d_:JK});function ZK(e,t){let n=_(e,"x","reverse");return D(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),na(n,t)}var eD=z({reverse2d_:ZK});function YK(e,t){let n=_(e,"x","reverse");return D(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),na(n,t)}var tD=z({reverse3d_:YK});function e7(e,t){let n=_(e,"x","reverse");return D(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),na(n,t)}var nD=z({reverse4d_:e7});function t7(e){let t={x:_(e,"x","round")};return L.runKernel(Su,t)}var nv=z({round_:t7});function n7(e){let t={x:_(e,"x","rsqrt","float32")};return L.runKernel(Iu,t)}var rv=z({rsqrt_:n7});function r7(e){let t={x:_(e,"x","selu")};return L.runKernel(Nu,t)}var av=z({selu_:r7});function a7(e,t,n,r,a,s=[1,1],i="NHWC"){let o=_(e,"x","separableConv2d"),l=_(t,"depthwiseFilter","separableConv2d"),d=_(n,"pointwiseFilter","separableConv2d"),u=o,c=!1;if(o.rank===3&&(c=!0,u=V(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),D(d.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),D(d.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${d.shape[0]}.`),D(d.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${d.shape[1]}.`);let p=l.shape[2],h=l.shape[3];D(d.shape[2]===p*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${d.shape[2]}.`);let f=zu(u,l,r,a,i,s),m=Jn(f,d,1,"valid",i);return c?V(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var bp=z({separableConv2d_:a7});async function s7(e,t){let n=_(e,"x","setdiff1d"),r=_(t,"y","setdiff1d");D(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),D(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),D(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let u=0;u<a.length;u++)i.has(a[u])||o++;let l=new Yt([o],n.dtype),d=new Yt([o],"int32");for(let u=0,c=0;u<a.length;u++)i.has(a[u])||(l.values[c]=a[u],d.values[c]=u,c++);return[l.toTensor(),d.toTensor()]}var rD=s7;function i7(e){let t={x:_(e,"x","sign")};return L.runKernel(Eu,t)}var SS=z({sign_:i7});function o7(e){let t={x:_(e,"x","sin","float32")};return L.runKernel(Cu,t)}var sv=z({sin_:o7});function l7(e){let t={x:_(e,"x","sinh")};return L.runKernel(Tu,t)}var iv=z({sinh_:l7});function u7(e,t,n){let r=_(e,"x","slice1d");return D(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Xe(r,[t],[n])}var im=z({slice1d_:u7});function d7(e,t,n){let r=_(e,"x","slice2d");return D(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Xe(r,t,n)}var ov=z({slice2d_:d7});function c7(e,t,n){let r=_(e,"x","slice3d");return D(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Xe(r,t,n)}var vp=z({slice3d_:c7});function p7(e,t,n){let r=_(e,"x","slice4d");return D(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Xe(r,t,n)}var qd=z({slice4d_:p7});function h7(e,t=-1){let n=_(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return L.runKernel(Fu,r,a)}var io=z({softmax_:h7});function f7(e){D(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return L.runKernel(Rb,t)}var om=z({fft_:f7});function m7(e){D(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return L.runKernel(Fb,t)}var Kd=z({ifft_:m7});function g7(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let a=V(e,[n,t]);r=Kd(a)}else{let a=[n,2*(t-1)],s=V(Gd(e),[n,t]),i=V(Zf(e),[n,t]),o=na(Xe(s,[0,1],[n,t-2]),1),l=W(na(Xe(i,[0,1],[n,t-2]),1),Ce(-1)),d=gt([s,o],1),u=gt([i,l],1),c=V(Ls(d,u),[a[0],a[1]]);r=Kd(c)}if(r=Gd(r),e.rank===3&&e.shape[0]!==0){let a=r,s=e.shape[0];r=V(r,[s,r.shape[0]/s,r.shape[1]]),a.dispose()}return r}var lv=z({irfft_:g7});function y7(e,t,n=0){let r={x:_(e,"x","split")},a={numOrSizeSplits:t,axis:n};return L.runKernel(ap,r,a)}var cr=z({split_:y7});function b7(e,t){D(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,a;if(t!=null&&t<n){let f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,a=Xe(e,f,m),n=t}else if(t!=null&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,a=gt([e,Dt(f)],e.shape.length-1),n=t}else a=e;let s=Ze(a),i=V(Ls(a,s),[r,n]),o=om(i),l=Math.floor(n/2)+1,d=Gd(o),u=Zf(o),c=cr(d,[l,n-l],d.shape.length-1),p=cr(u,[l,n-l],u.shape.length-1),h=a.shape.slice();return h[a.shape.length-1]=l,V(Ls(c[0],p[0]),h)}var lm=z({rfft_:b7});function v7(e,t){let n=_(e,"a","squaredDifference"),r=_(t,"b","squaredDifference");[n,r]=Ot(n,r),yt(n.shape,r.shape);let a={a:n,b:r},s={};return L.runKernel(Du,a,s)}var uv=z({squaredDifference_:v7});function x7(e,t){let n=_(e,"x","squeeze","string_or_numeric");return V(n,$R(n.shape,t).newShape)}var oo=z({squeeze_:x7});function w7(e,t=0){let n=Qh(e,"tensors","stack","string_or_numeric");D(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&D(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,a={axis:t};return L.runKernel(Kc,r,a)}var en=z({stack_:w7});function k7(e,t=0){let n={x:_(e,"x","step")},r={alpha:t};return L.runKernel(no,n,r)}var Wu=z({step_:k7});function S7(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let d={x:_(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return L.runKernel(op,d,u)}var IS=z({stridedSlice_:S7});function I7(e){let t={x:_(e,"x","tan","float32")};return L.runKernel(Ou,t)}var NS=z({tan_:I7});function ot(e,t){vl(e);let n=us(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ro(e,null,n,t)}function os(e,t,n){if(vl(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=us(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ro(e,t,r,n)}function dv(e,t,n){if(vl(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=us(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ro(e,t,r,n)}function zi(e,t,n){if(vl(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=us(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ro(e,t,r,n)}function aD(e,t,n){if(vl(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=us(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ro(e,t,r,n)}function sD(e,t,n){if(vl(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=us(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,ro(e,t,r,n)}var cv={};De(cv,{calculateShapes:()=>iD,validateInput:()=>pv,validateUpdateShape:()=>CS});function CS(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+` update.rank != ${a+e.length-r}`);for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function pv(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}CS(n,t,e)}function iD(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let c=a;c<s;++c)i*=n[c];let o=a<1?1:a,l=dt(t.shape)/o,d=[...dc(n.slice(0,a)),1],u=dt(n);return{sliceRank:a,numUpdates:l,sliceSize:i,strides:d,outputSize:u}}function N7(e,t,n){let r=_(e,"tensor","tensorScatterupdate"),a=_(t,"indices","tensorScatterupdate","int32"),s=_(n,"updates","tensorScatterupdate");if(pv(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:a,updates:s},o={};return L.runKernel(Yc,i,o)}var oD=z({tensorScatterUpdate_:N7});function C7(e,t=1,n=!0){let r=_(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=L.runKernel(lp,s,i);return{values:o,indices:l}}var TS=z({topk_:C7});function T7(e,t=0,n=1,r,a){if(Br(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new wS(t,n,r,!0,a),i=Ve(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var hv=z({truncatedNormal_:T7});function E7(e,t=0){let n=_(e,"x","unique","string_or_numeric");D(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},a={axis:t},[s,i]=L.runKernel(Uf,r,a);return{values:s,indices:i}}var ES=z({unique_:E7});function _7(e,t,n){let r=_(e,"x","unsortedSegmentSum"),a=_(t,"segmentIds","unsortedSegmentSum","int32");D(zd(n),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:a},i={numSegments:n};return L.runKernel(Vf,s,i)}var fv=z({unsortedSegmentSum_:_7});function $7(e,t=0){let n=_(e,"x","unstack","string_or_numeric");D(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},a={axis:t};return L.runKernel(dp,r,a)}var Ut=z({unstack_:$7});function lD(e,t){return Yb(e,t,"right")}function _S(e,t=!0,n,r){return L.makeVariable(e,t,n,r)}function uD(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=Ve(e,"int32"),a=Ve([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let i=r.indexToLoc(n[s]),o=s*e.length;a.values.set(i,o)}return a.toTensor()}async function A7(e){let t=_(e,"condition","whereAsync","bool"),n=await t.data(),r=uD(t.shape,n);return e!==t&&t.dispose(),r}var $S=A7;async function R7(e,t,n){let r=_(e,"tensor","boolMask"),a=_(t,"mask","boolMask","bool"),s=n??0,i=a.rank,o=r.shape;D(i>0,()=>"mask cannot be scalar"),er(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let d=o.slice(0,s).concat([l],o.slice(s+i)),u=V(r,d),c=V(a,[-1]),p=await $S(c),h=oo(p,[1]),f=yp(u,h,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),h.dispose(),u.dispose(),c.dispose(),p.dispose(),f}var dD=R7;function F7(e,t,n){let r=_(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),D(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{D(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return r.dtype==="complex64"?j(()=>{let i=Gd(r),o=Zf(r);return i=L.runKernel(As,{x:i},s),o=L.runKernel(As,{x:o},s),n&&(o=St(o)),Ls(i,o)}):L.runKernel(As,a,s)}var Ue=z({transpose_:F7});function D7(e,t,n,r,a=!0){let s=_(e,"v","movingAverage"),i=_(t,"x","movingAverage"),o=_(n,"decay","movingAverage");QR(s,i),D(Ws(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=Ce(1),d=me(l,o),u=W(me(i,s),d);if(a){D(r!=null,()=>"When using zeroDebias: true, step is required.");let c=_(r,"step","movingAverage");u=be(u,me(l,ds(o,c)))}return te(s,u)}var cD=z({movingAverage_:D7});function M7(e,t,n){Br(n);let r=_(e,"indices","scatterND","int32"),a=_(t,"updates","scatterND");pv(a,r,n);let s={indices:r,updates:a},i={shape:n};return L.runKernel(Zc,s,i)}var pD=z({scatterND_:M7});function O7(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function P7(e,t,n,r=0){Br(n);let a=_(e,"sparseIndices","sparseToDense","int32"),s=_(t,"sparseValues","sparseToDense","string_or_numeric"),i=_(r,"defaultValue","sparseToDense",s.dtype);O7(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return L.runKernel(ip,o,l)}var hD=z({sparseToDense_:P7});function L7(e,t){let n=_(t,"indices","gatherND","int32"),r={params:_(e,"x","gatherND","string_or_numeric"),indices:n};return L.runKernel(Ac,r)}var fD=z({gatherND_:L7});function z7(e,t){if(t==null)return e.shape.slice();if(Ws(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function B7(e,t,n,r){let a=_(e,"x","dropout");if(D(a.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),D(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Pe?a.clone():a;let s=z7(a,n),i=1-t,o=be(gp(te(so(s,0,1,"float32",r),i)),i);return W(a,o)}var AS=z({dropout_:B7});function RS(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function mv(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return ot(a,"float32")}async function W7(e,t,n=1){let r=_(e,"predictions","inTopK"),a=_(t,"targets","inTopK");D(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),D(r.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`),er(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];D(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await r.data(),o=await a.data(),[l,d]=[i.length/s,s],u=AR("bool",l);for(let c=0;c<l;c++){let p=c*d,h=i.subarray(p,p+d),f=[];for(let m=0;m<h.length;m++)f.push({value:h[m],index:m});f.sort((m,g)=>g.value-m.value),u[c]=0;for(let m=0;m<n;m++)if(f[m].index===o[c]){u[c]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),Xn(u,a.shape,"bool")}var mD=W7,Xd={};De(Xd,{conv2d:()=>j7,depthwiseConv2d:()=>K7,matMul:()=>Q7});function U7(e,t,n,r,a,s="NHWC",i){let o=e;e.rank===3&&(o=V(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=V(t,[1,t.shape[0],t.shape[1],t.shape[2]])),D(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),D(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),D(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let d=s==="NHWC"?o.shape[3]:o.shape[1],u=s==="NHWC"?l.shape[3]:l.shape[1];D(d===n[2],()=>`Error in conv2dDerFilter: depth of input ${d}) must match input depth in filter (${n[2]}.`),D(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),tr("conv2dDerFilter",a,i);let c={x:o,dy:l},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return L.runKernel(Tb,c,p)}var FS=z({conv2DBackpropFilter_:U7});function gv(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return W(e,Wu(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function yv(e,t){let n=t,r=tn(e.shape,t.shape);return r.length>0&&(n=ke(n,r)),V(n,e.shape)}function bv(e,t,n,r){if(t==="linear")return e;if(t==="relu")return ut(e);if(t==="elu")return fp(e);if(t==="relu6")return tv(e);if(t==="prelu")return sm(e,n);if(t==="leakyrelu")return Yf(e,r);if(t==="sigmoid")return ma(e);throw new Error(`Unknown fused activation ${t}.`)}var vv=(e,t)=>!(e>0)||t==="linear";function V7({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:d,leakyreluAlpha:u}){if(l=l||"linear",vv(L.state.gradientDepth,l)===!1){D(a==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=Jn(e,t,n,r,a,s,i);return o!=null&&(I=te(I,o)),bv(I,l,d,u)}let c=_(e,"x","conv2d","float32"),p=_(t,"filter","conv2d","float32"),h=c,f=!1;c.rank===3&&(f=!0,h=V(c,[1,c.shape[0],c.shape[1],c.shape[2]])),D(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),D(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),tr("fused conv2d",r,i);let m=a==="NHWC"?h.shape[3]:h.shape[1];D(p.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${p.shape[2]}.`),D(fs(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let g=Xf(h.shape,p.shape,n,s,r,i),y;o!=null&&(y=_(o,"bias","fused conv2d"),[y]=Ot(y,c),a==="NHWC"?yt(g.outShape,y.shape):(D(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),D(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(d!=null){let I=d.shape;if(D(I.length<=1||I.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),I.length===1)D(I[0]===1||I[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${g.outChannels}).`);else if(I.length===3)try{yt(I,g.outShape)}catch{let T=`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(T)}b=_(d,"prelu weights","fused conv2d")}let v=(I,N)=>{D(a==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);let[T,A,R,F]=N,C=gv(I,R,l);D(Oi(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let M=Qk(A.shape,C,T,n,r),B=FS(A,C,T.shape,n,r),U=[M,B];if(F!=null){let G=yv(F,C);U.push(G)}return U},x={x:h,filter:p,bias:y,preluActivationWeights:b},w={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?cs((I,N,T)=>{let A=L.runKernel(Zo,x,w);return T([N,I,A]),f&&(A=V(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:v}})(h,p):cs((I,N,T,A)=>{let R=L.runKernel(Zo,x,w);return A([N,I,R,T]),f&&(R=V(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:v}})(h,p,y)}var j7=z({fusedConv2d_:V7});function H7(e,t,n,r,a,s=[1,1],i){let o=e;e.rank===3&&(o=V(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d={x:o,dy:l},u={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return L.runKernel(Eb,d,u)}var gD=z({depthwiseConv2dNativeBackpropFilter_:H7});function G7(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=V(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d={dy:o,filter:n},u={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},c=L.runKernel(_b,d,u);return l?V(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var yD=z({depthwiseConv2dNativeBackpropInput_:G7});function q7({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:d,leakyreluAlpha:u}){if(vv(L.state.gradientDepth,l)===!1){let w=zu(e,t,n,r,a,s,i);return o!=null&&(w=te(w,o)),bv(w,l,d,u)}let c=_(e,"x","depthwiseConv2d","float32"),p=_(t,"filter","depthwiseConv2d","float32"),h=c,f=!1;c.rank===3&&(f=!0,h=V(c,[1,c.shape[0],c.shape[1],c.shape[2]])),D(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),D(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),D(h.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),s==null&&(s=[1,1]),D(fs(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),tr("fused depthwiseConv2d",r,i);let m=Xf(h.shape,p.shape,n,s,r,i,!0),g;o!=null&&(g=_(o,"bias","fused conv2d"),[g]=Ot(g,c),yt(m.outShape,g.shape));let y;d!=null&&(y=_(d,"prelu weights","fused depthwiseConv2d"));let b=(w,I)=>{D(Oi(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[N,T,A,R]=I,F=gv(w,A,l),C=yD(T.shape,F,N,n,r,s,i),M=gD(T,F,N.shape,n,r,s,i);if(R!=null){let B=yv(g,F);return[C,M,B]}return[C,M]},v={x:h,filter:p,bias:g,preluActivationWeights:y},x={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?cs((w,I,N)=>{let T=L.runKernel(Yo,v,x);return N([I,w,T]),f&&(T=V(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:b}})(h,p):cs((w,I,N,T)=>{let A=L.runKernel(Yo,v,x);return T([I,w,A,N]),f&&(A=V(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(h,p,g)}var K7=z({fusedDepthwiseConv2d_:q7});function X7({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(vv(L.state.gradientDepth,s)===!1){let R=We(e,t,n,r);return a!=null&&(R=te(R,a)),bv(R,s,i,o)}let l=_(e,"a","fused matMul"),d=_(t,"b","fused matMul");[l,d]=Ot(l,d);let u=n?l.shape[l.rank-2]:l.shape[l.rank-1],c=r?d.shape[d.rank-1]:d.shape[d.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=r?d.shape[d.rank-2]:d.shape[d.rank-1],f=l.shape.slice(0,-2),m=d.shape.slice(0,-2),g=dt(f),y=dt(m);D(u===c,()=>`Error in fused matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${l.shape} and ${d.shape} and transposeA=${n} and transposeB=${r} must match.`);let b=yt(l.shape.slice(0,-2),d.shape.slice(0,-2)).concat([p,h]),v=n?V(l,[g,u,p]):V(l,[g,p,u]),x=r?V(d,[y,h,c]):V(d,[y,c,h]),w;a!=null&&(w=_(a,"bias","fused matMul"),[w]=Ot(w,l),yt(b,w.shape));let I;i!=null&&(I=_(i,"prelu weights","fused matMul"));let N=(R,F)=>{let[C,M,B,U]=F,G=gv(V(R,B.shape),B,s),X,P;if(!n&&!r?(X=We(G,M,!1,!0),P=We(C,G,!0,!1)):!n&&r?(X=We(G,M,!1,!1),P=We(G,C,!0,!1)):n&&!r?(X=We(M,G,!1,!0),P=We(C,G,!1,!1)):(X=We(M,G,!0,!0),P=We(G,C,!0,!0)),a!=null){let q=yv(U,G);return[X,P,q]}else return[X,P]},T={a:v,b:x,bias:w,preluActivationWeights:I},A={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return a==null?cs((R,F,C)=>{let M=L.runKernel(Jo,T,A);return C([R,F,M]),{value:V(M,b),gradFunc:N}})(v,x):cs((R,F,C,M)=>{let B=L.runKernel(Jo,T,A);return M([R,F,B,C]),{value:V(B,b),gradFunc:N}})(v,x,w)}var Q7=z({fusedMatMul_:X7});function J7(e){return mv(e,.54,.46)}var Z7=z({hammingWindow_:J7});function Y7(e){return mv(e,.5,.5)}var bD=z({hannWindow_:Y7});function e9(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(Xe(e,s,t)),s+=n;if(r)for(;s<e.size;){let o=s+t-e.size,l=gt([Xe(e,s,t-o),Dr([o],a)]);i.push(l),s+=n}return i.length===0?os([],[0,t]):V(gt(i),[i.length,t])}var vD=z({frame_:e9});function t9(e,t,n,r,a=bD){r==null&&(r=RS(t));let s=vD(e,t,n),i=W(s,a(t));return lm(i,r)}var n9=z({stft_:t9});function r9(e,t,n,r,a="bilinear",s=0){let i=_(e,"image","cropAndResize"),o=_(t,"boxes","cropAndResize","float32"),l=_(n,"boxInd","cropAndResize","int32"),d=o.shape[0];D(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),D(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${d},4] but had shape ${o.shape}.`),D(l.rank===1&&l.shape[0]===d,()=>`Error in cropAndResize: boxInd must be have size [${d}] but had shape ${o.shape}.`),D(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),D(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),D(a==="bilinear"||a==="nearest",()=>`method must be bilinear or nearest, but was ${a}`);let u={image:i,boxes:o,boxInd:l},c={method:a,extrapolationValue:s,cropSize:r};return L.runKernel(Ic,u,c)}var a9=z({cropAndResize_:r9});function s9(e){let t=_(e,"image","flipLeftRight","float32");D(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return L.runKernel(_c,n,{})}var i9=z({flipLeftRight_:s9});function o9(e){let t=_(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];D(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),D(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Er(t,a)}var l9=z({grayscaleToRGB_:o9});function u9(e){let t=_(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];D(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),D(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let a=t.dtype,s=ue(t,"float32"),i=ot([.2989,.587,.114]),o;switch(t.rank){case 2:o=To("ij,j->i",s,i);break;case 3:o=To("ijk,k->ij",s,i);break;case 4:o=To("ijkl,l->ijk",s,i);break;case 5:o=To("ijklm,m->ijkl",s,i);break;case 6:o=To("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=yn(o,-1),ue(o,a)}var d9=z({rgbToGrayscale_:u9});function c9(e,t,n=0,r=.5){let a=_(e,"image","rotateWithOffset","float32");D(a.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`);let s={image:a},i={radians:t,fillValue:n,center:r};return L.runKernel(pp,s,i)}var p9=z({rotateWithOffset_:c9});function xp(e,t,n,r,a,s){r==null&&(r=.5),a==null&&(a=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),D(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),D(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),D(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),D(t.rank===1,()=>"scores must be a 1D tensor"),D(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),D(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function h9(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=_(e,"boxes","nonMaxSuppression","float32"),i=_(t,"scores","nonMaxSuppression","float32"),o=xp(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return L.runKernel(jc,{boxes:s,scores:i},l)}var f9=z({nonMaxSuppression_:h9});function m9(e,t,n){let r=g9(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function g9(e,t,n){return b9(e,t,n||y9)}function y9(e,t){return e>t?1:e<t?-1:0}function b9(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}function xD(e,t,n,r,a){return DS(e,t,n,r,a,0)}function wD(e,t,n,r,a,s){return DS(e,t,n,r,a,0,!1,s,!0)}function kD(e,t,n,r,a,s){return DS(e,t,n,r,a,s,!0)}function DS(e,t,n,r,a,s,i=!1,o=!1,l=!1){let d=[];for(let g=0;g<t.length;g++)t[g]>a&&d.push({score:t[g],boxIndex:g,suppressBeginIndex:0});d.sort(WT);let u=s>0?-.5/s:0,c=[],p=[];for(;c.length<n&&d.length>0;){let g=d.pop(),{score:y,boxIndex:b,suppressBeginIndex:v}=g;if(y<a)break;let x=!1;for(let w=c.length-1;w>=v;--w){let I=v9(e,b,c[w]);if(I>=r){x=!0;break}if(g.score=g.score*x9(r,u,I),g.score<=a)break}g.suppressBeginIndex=c.length,x||(g.score===y?(c.push(b),p.push(g.score)):g.score>a&&m9(d,g,WT))}let h=c.length,f=n-h;o&&f>0&&(c.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));let m={selectedIndices:c};return i&&(m.selectedScores=p),l&&(m.validOutputs=h),m}function v9(e,t,n){let r=e.subarray(t*4,t*4+4),a=e.subarray(n*4,n*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),d=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),c=Math.max(a[0],a[2]),p=Math.max(a[1],a[3]),h=(o-s)*(l-i),f=(c-d)*(p-u);if(h<=0||f<=0)return 0;let m=Math.max(s,d),g=Math.max(i,u),y=Math.min(o,c),b=Math.min(l,p),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(h+f-v)}function x9(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function WT(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function w9(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=_(e,"boxes","nonMaxSuppressionAsync"),i=_(t,"scores","nonMaxSuppressionAsync"),o=xp(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),d=l[0],u=l[1],{selectedIndices:c}=xD(d,u,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),ot(c,"int32")}var k9=w9;function S9(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=_(e,"boxes","nonMaxSuppression"),o=_(t,"scores","nonMaxSuppression"),l=xp(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let d={boxes:i,scores:o},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},c=L.runKernel(Gc,d,u);return{selectedIndices:c[0],selectedScores:c[1]}}var I9=z({nonMaxSuppressionWithScore_:S9});async function N9(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=_(e,"boxes","nonMaxSuppressionAsync"),o=_(t,"scores","nonMaxSuppressionAsync"),l=xp(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let d=await Promise.all([i.data(),o.data()]),u=d[0],c=d[1],{selectedIndices:p,selectedScores:h}=kD(u,c,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ot(p,"int32"),selectedScores:ot(h)}}var C9=N9;function T9(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=_(e,"boxes","nonMaxSuppression"),o=_(t,"scores","nonMaxSuppression"),l=xp(i,o,n,r,a,null),d=l.maxOutputSize,u=l.iouThreshold,c=l.scoreThreshold,p={boxes:i,scores:o},h={maxOutputSize:d,iouThreshold:u,scoreThreshold:c,padToMaxOutputSize:s},f=L.runKernel(Hc,p,h);return{selectedIndices:f[0],validOutputs:f[1]}}var E9=z({nonMaxSuppressionPadded_:T9});async function _9(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=_(e,"boxes","nonMaxSuppressionAsync"),o=_(t,"scores","nonMaxSuppressionAsync"),l=xp(i,o,n,r,a,null),d=l.maxOutputSize,u=l.iouThreshold,c=l.scoreThreshold,[p,h]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=wD(p,h,d,u,c,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ot(f,"int32"),validOutputs:Ce(m,"int32")}}var $9=_9;function A9(e,t,n=!1,r=!1){let a=_(e,"images","resizeBilinear");D(a.rank===3||a.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),D(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),D(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=V(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},d=L.runKernel(xu,o,l);return i?V(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var SD=z({resizeBilinear_:A9});function R9(e,t,n=!1,r=!1){let a=_(e,"images","resizeNearestNeighbor");D(a.rank===3||a.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),D(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),D(a.dtype==="float32"||a.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=V(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},d=L.runKernel(vu,o,l);return i?V(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var ID=z({resizeNearestNeighbor_:R9});function F9(e,t="binary",n=!1,r=.5){let a=_(e,"image","threshold"),s=.2989,i=.587,o=.114,l=a.shape[0]*a.shape[1],d=W(ot([r]),255),u,c,p,h;if(D(a.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`),D(a.shape[2]===3||a.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`),D(a.dtype==="int32"||a.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`),D(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),a.shape[2]===3){[u,c,p]=cr(a,[1,1,1],-1);let m=W(u,s),g=W(c,i),y=W(p,o);h=te(te(m,g),y)}else h=e;if(t==="otsu"){let m=jk(ue(nv(h),"int32"),Xn([]),256);d=D9(m,l)}let f=n?ao(h,d):nr(h,d);return ue(W(f,255),"int32")}function D9(e,t){let n=ot([-1]),r=ot([0]),a=ot([0]),s,i,o,l,d,u;for(let c=0;c<e.size-1;c++){s=Xe(e,0,c+1),i=Xe(e,c+1),d=be(ke(s),t),u=be(ke(i),t);let p=ke(W(s,ll(0,s.size)));o=be(p,ke(s));let h=Dr(i.shape,s.size),f=te(ll(0,i.size),h),m=W(i,f);l=be(ke(m),ke(i));let g=me(o,l),y=me(o,l),b=W(d,u);a=W(W(b,g),y);let v=nr(a,r);r=xn(v,a,r),n=xn(v,ot([c]),n)}return n}var M9=z({threshold_:F9});function O9(e,t,n="nearest",r="constant",a=0,s){let i=_(e,"image","transform","float32"),o=_(t,"transforms","transform","float32");D(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),D(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:o},d={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return L.runKernel(up,l,d)}var P9=z({transform_:O9});function L9(e,t,n){let r=_(e,"a","bandPart");D(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let a=r.shape,[s,i]=r.shape.slice(-2),o,l;typeof t=="number"?(D(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),D(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=_(t<0?s:t,"numLower","bandPart")):(D(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=xn(jd(t,0),s,Li(t,s))),typeof n=="number"?(D(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),D(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=_(n<0?i:n,"numUpper","bandPart")):(D(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=xn(jd(n,0),i,Li(n,i)));let d=V(ll(0,s,1,"int32"),[-1,1]),u=ll(0,i,1,"int32"),c=me(d,u),p=ba(ao(c,o),js(c,St(l))),h=Dt([s,i],r.dtype);return V(en(Ut(V(r,[-1,s,i])).map(f=>xn(p,f,h))),a)}var z9=z({bandPart_:L9});function B9(e){let t;if(Array.isArray(e)){t=!1,D(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let a=e[0].shape[0];for(let s=1;s<e.length;++s)D(e[s].shape[0]===a,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${a})`)}else t=!0,e=cr(e,e.shape[0],0).map(a=>oo(a,[0]));D(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let a=0;a<e.length;++a)n.push(L.tidy(()=>{let s=r[a];if(a>0)for(let i=0;i<a;++i){let o=W(ke(W(n[i],s)),n[i]);s=me(s,o)}return be(s,mp(s,"euclidean"))}));return t?en(n,0):n}var W9=z({gramSchmidt_:B9});function U9(e,t=!1){if(D(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return UT(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,d)=>l*d),r=Ut(V(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach(l=>{let[d,u]=UT(l,t);a.push(d),s.push(u)});let i=V(en(a,0),e.shape),o=V(en(s,0),e.shape);return[i,o]}}function UT(e,t=!1){return L.tidy(()=>{D(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],a=Xb(n),s=is(e),i=os([[1]],[1,1]),o=is(i),l=n>=r?r:n;for(let d=0;d<l;++d){let u=s,c=o,p=a;[o,s,a]=L.tidy(()=>{let h=Xe(s,[d,d],[n-d,1]),f=mp(h),m=Xe(s,[d,d],[1,1]),g=xn(nr(m,0),os([[-1]]),os([[1]])),y=me(m,W(g,f)),b=be(h,y);b.shape[0]===1?o=is(i):o=gt([i,Xe(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let v=St(be(We(g,y),f)),x=Xe(s,[d,0],[n-d,r]),w=W(v,o),I=Ue(o);if(d===0)s=me(x,We(w,We(I,x)));else{let A=me(x,We(w,We(I,x)));s=gt([Xe(s,[0,0],[d,r]),A],0)}let N=Ue(w),T=Xe(a,[0,d],[n,a.shape[1]-d]);if(d===0)a=me(T,We(We(T,o),N));else{let A=me(T,We(We(T,o),N));a=gt([Xe(a,[0,0],[n,d]),A],1)}return[o,s,a]}),Fe([u,c,p])}return!t&&n>r&&(a=Xe(a,[0,0],[n,r]),s=Xe(s,[0,0],[r,r])),[a,s]})}var V9=z({qr_:U9}),Gn;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Gn||(Gn={}));function j9(e,t,n=Gn.SUM_BY_NONZERO_WEIGHTS){let r=_(e,"losses","computeWeightedLoss"),a=null;t!=null&&(a=_(t,"weights","computeWeightedLoss"));let s=a==null?r:W(r,a);if(n===Gn.NONE)return s;if(n===Gn.SUM)return ke(s);if(n===Gn.MEAN){if(a==null)return Ft(s);{let i=r.size/a.size,o=be(ke(s),ke(a));return i>1?be(o,Ce(i)):o}}if(n===Gn.SUM_BY_NONZERO_WEIGHTS){if(a==null)return be(ke(s),Ce(r.size));{let i=W(a,ur(r.shape)),o=ue(ke(ol(i,Ce(0))),"float32");return be(ke(s),o)}}throw Error(`Unknown reduction: ${n}`)}var Hs=z({computeWeightedLoss_:j9});function H9(e,t,n,r=Gn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","absoluteDifference"),s=_(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=_(n,"weights","absoluteDifference")),er(a.shape,s.shape,"Error in absoluteDifference: ");let o=Xt(me(a,s));return Hs(o,i,r)}var G9=z({absoluteDifference_:H9});function q9(e,t,n,r,a=Gn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","cosineDistance"),i=_(t,"predictions","cosineDistance"),o=null;r!=null&&(o=_(r,"weights","cosineDistance")),er(s.shape,i.shape,"Error in cosineDistance: ");let l=Ce(1),d=me(l,ke(W(s,i),n,!0));return Hs(d,o,a)}var K9=z({cosineDistance_:q9});function X9(e,t,n,r=Gn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","hingeLoss"),s=_(t,"predictions","hingeLoss"),i=null;n!=null&&(i=_(n,"weights","hingeLoss")),er(a.shape,s.shape,"Error in hingeLoss: ");let o=Ce(1);a=me(W(Ce(2),a),o);let l=ut(me(o,W(a,s)));return Hs(l,i,r)}var Q9=z({hingeLoss_:X9});function J9(e,t,n,r=1,a=Gn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","huberLoss"),i=_(t,"predictions","huberLoss"),o=null;n!=null&&(o=_(n,"weights","huberLoss")),er(s.shape,i.shape,"Error in huberLoss: ");let l=Ce(r),d=Xt(me(i,s)),u=Li(d,l),c=me(d,u),p=te(W(Ce(.5),ft(u)),W(l,c));return Hs(p,o,a)}var Z9=z({huberLoss_:J9});function Y9(e,t,n,r=1e-7,a=Gn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"labels","logLoss"),i=_(t,"predictions","logLoss"),o=null;n!=null&&(o=_(n,"weights","logLoss")),er(s.shape,i.shape,"Error in logLoss: ");let l=Ce(1),d=Ce(r),u=St(W(s,Pr(te(i,d)))),c=W(me(l,s),Pr(te(me(l,i),d))),p=me(u,c);return Hs(p,o,a)}var eX=z({logLoss_:Y9});function tX(e,t,n,r=Gn.SUM_BY_NONZERO_WEIGHTS){let a=_(e,"labels","meanSquaredError"),s=_(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=_(n,"weights","meanSquaredError")),er(a.shape,s.shape,"Error in meanSquaredError: ");let o=uv(a,s);return Hs(o,i,r)}var nX=z({meanSquaredError_:tX});function rX(e,t){let n=_(e,"labels","sigmoidCrossEntropyWithLogits"),r=_(t,"logits","sigmoidCrossEntropyWithLogits");er(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=ut(r),s=W(r,n),i=em(Pn(St(Xt(r))));return te(me(a,s),i)}function aX(e,t,n,r=0,a=Gn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"multiClassLabels","sigmoidCrossEntropy"),i=_(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=_(n,"weights","sigmoidCrossEntropy")),er(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let d=Ce(r),u=Ce(1),c=Ce(.5);s=te(W(s,me(u,d)),W(c,d))}let l=rX(s,i);return Hs(l,o,a)}var sX=z({sigmoidCrossEntropy_:aX});function iX(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return cs((r,a,s)=>{let i=tm(a,[n],!0),o=me(ue(a,"float32"),i);s([r,o]);let l=St(W(o,r));return{value:ke(l,[n]),gradFunc:(d,u)=>{let[c,p]=u,h=il(d.shape,[n]);return[W(V(d,h),me(ue(c,"float32"),Pn(p))),W(V(d,h),me(Pn(p),ue(c,"float32")))]}}})(e,t)}function oX(e,t,n,r=0,a=Gn.SUM_BY_NONZERO_WEIGHTS){let s=_(e,"onehotLabels","softmaxCrossEntropy"),i=_(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=_(n,"weights","softmaxCrossEntropy")),er(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let d=Ce(r),u=Ce(1),c=Ce(s.shape[1]);s=te(W(s,me(u,d)),be(d,c))}let l=iX(s,i);return Hs(l,o,a)}var lX=z({softmaxCrossEntropy_:oX});function uX(e,t,n,r){let a=_(e,"indices","sparseFillEmptyRows","int32"),s=_(t,"values","sparseFillEmptyRows"),i=_(n,"denseShape","sparseFillEmptyRows","int32"),o=_(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(a.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},d=L.runKernel(Df,l);return{outputIndices:d[0],outputValues:d[1],emptyRowIndicator:d[2],reverseIndexMap:d[3]}}var dX=z({sparseFillEmptyRows_:uX});function cX(e,t,n){let r=_(e,"inputIndices","sparseReshape","int32"),a=_(t,"inputShape","sparseReshape","int32"),s=_(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=L.runKernel(sp,i);return{outputIndices:o[0],outputShape:o[1]}}var pX=z({sparseReshape_:cX});function hX(e,t,n){let r=_(e,"data","sparseSegmentMean"),a=_(t,"indices","sparseSegmentMean","int32"),s=_(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return L.runKernel(Mf,i)}var fX=z({sparseSegmentMean_:hX});function mX(e,t,n){let r=_(e,"data","sparseSegmentSum"),a=_(t,"indices","sparseSegmentSum","int32"),s=_(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return L.runKernel(Of,i)}var gX=z({sparseSegmentSum_:mX});function yX(e,t,n,r,a,s,i,o){let l=_(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let d=_(t,"dataSplits","stringNGrams");if(d.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let u={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},c={data:l,dataSplits:d},p=L.runKernel(zf,c,u);return{nGrams:p[0],nGramsSplits:p[1]}}var bX=z({stringNGrams_:yX});function vX(e,t,n=!0){let r=_(e,"input","stringSplit","string"),a=_(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(a.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=L.runKernel(Bf,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var xX=z({stringSplit_:vX});function wX(e,t){let n=_(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return L.runKernel(Wf,a,r)}var kX=z({stringToHashBucketFast_:wX});function SX(e,t,n,r=!0){let a=_(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return L.runKernel(Lf,{x:a},s)}var IX=z({staticRegexReplace_:SX}),ND={fft:om,ifft:Kd,rfft:lm,irfft:lv},CD={hammingWindow:Z7,hannWindow:bD,frame:vD,stft:n9},qr={flipLeftRight:i9,grayscaleToRGB:l9,resizeNearestNeighbor:ID,resizeBilinear:SD,rgbToGrayscale:d9,rotateWithOffset:p9,cropAndResize:a9,nonMaxSuppression:f9,nonMaxSuppressionAsync:k9,nonMaxSuppressionWithScore:I9,nonMaxSuppressionWithScoreAsync:C9,nonMaxSuppressionPadded:E9,nonMaxSuppressionPaddedAsync:$9,threshold:M9,transform:P9},MS={bandPart:z9,gramSchmidt:W9,qr:V9},TD={absoluteDifference:G9,computeWeightedLoss:Hs,cosineDistance:K9,hingeLoss:Q9,huberLoss:Z9,logLoss:eX,meanSquaredError:nX,sigmoidCrossEntropy:sX,softmaxCrossEntropy:lX},ED={sparseFillEmptyRows:dX,sparseReshape:pX,sparseSegmentMean:fX,sparseSegmentSum:gX},_D={stringNGrams:bX,stringSplit:xX,stringToHashBucketFast:kX,staticRegexReplace:IX},oe={};De(oe,{Serializable:()=>$D,SerializationMap:()=>AD,getRegisteredName:()=>CX,registerClass:()=>RD});var NX=new Map,Sw=new Map,$D=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},AD=class sd{constructor(){this.classNameMap={}}static getMap(){return sd.instance==null&&(sd.instance=new sd),sd.instance}static register(t){sd.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function RD(e,t,n){D(e.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),D(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let r=n,a=t+">"+r;return AD.register(e),NX.set(a,e),Sw.set(e,a),e}function CX(e){return Sw.has(e)?Sw.get(e):e.className}var Gs=class extends $D{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(s)}else this.applyGradients(a);return Fe(a),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return RF(e,t)}dispose(){this.iterations_!=null&&Fe(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ce(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Gs,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var OS=class extends Gs{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=L.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=L.registeredVariables[t],a=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:j(()=>Ze(r).variable(a))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:j(()=>Ze(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;j(()=>{let l=te(W(i,this.rho),W(ft(s),1-this.rho)),d=W(be(wn(te(o,this.epsilon)),wn(te(i,this.epsilon))),s),u=te(W(o,this.rho),W(ft(d),1-this.rho));i.assign(l),o.assign(u);let c=te(W(d,-this.learningRate),r);r.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Fe(this.accumulatedGrads.map(e=>e.variable)),Fe(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},PS=class extends Gs{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=L.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:j(()=>Dr(r.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let s=this.accumulatedGrads[n].variable;j(()=>{let i=te(s,ft(a));s.assign(i);let o=te(W(be(a,wn(te(i,L.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Fe(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},LS=class extends Gs{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],j(()=>{this.accBeta1=Ce(t).variable(),this.accBeta2=Ce(n).variable()}),r==null&&(this.epsilon=L.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);j(()=>{let n=me(1,this.accBeta1),r=me(1,this.accBeta2);t.forEach((a,s)=>{let i=L.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:j(()=>Ze(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${a}/v`,variable:j(()=>Ze(i).variable(o))});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let d=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,c=te(W(d,this.beta1),W(l,1-this.beta1)),p=te(W(u,this.beta2),W(ft(l),1-this.beta2)),h=be(c,n),f=be(p,r);d.assign(c),u.assign(p);let m=te(W(be(h,te(wn(f),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(W(this.accBeta1,this.beta1)),this.accBeta2.assign(W(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Fe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Fe(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),j(()=>{this.accBeta1.assign(ds(this.beta1,this.iterations_+1)),this.accBeta2.assign(ds(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},zS=class extends Gs{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],j(()=>{this.iteration=Ce(0).variable(),this.accBeta1=Ce(t).variable()}),r==null&&(this.epsilon=L.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);j(()=>{let n=me(1,this.accBeta1),r=be(-this.learningRate,te(W(this.iteration,this.decay),1));t.forEach((a,s)=>{let i=L.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:Ze(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${a}/v`,variable:Ze(i).variable(o)});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let d=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,c=te(W(d,this.beta1),W(l,1-this.beta1)),p=W(u,this.beta2),h=Xt(l),f=ms(p,h);d.assign(c),u.assign(f);let m=te(W(be(r,n),be(c,te(f,this.epsilon))),i);i.assign(m)}),this.iteration.assign(te(this.iteration,1)),this.accBeta1.assign(W(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Fe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Fe(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},xv=class extends Gs{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let a=L.registeredVariables[t];j(()=>{let s=te(W(this.c,r),a);a.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=sn(Ce(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},BS=class extends xv{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Ce(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=L.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:j(()=>Ze(r).variable(!1))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&j(()=>{let i,o=te(W(this.m,a),s);this.useNesterov?i=te(W(this.c,te(s,W(o,this.m))),r):i=te(W(this.c,o),r),a.assign(o),r.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Fe(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},WS=class extends Gs{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=L.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=L.registeredVariables[t],a=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:j(()=>Ze(r).variable(a))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:j(()=>Ze(r).variable(a))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:j(()=>Ze(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;j(()=>{let l=te(W(i,this.decay),W(ft(s),1-this.decay));if(this.centered){let d=this.accumulatedMeanGrads[n].variable,u=te(W(d,this.decay),W(s,1-this.decay)),c=be(W(s,this.learningRate),wn(me(l,te(ft(u),this.epsilon)))),p=te(W(o,this.momentum),c);i.assign(l),d.assign(u),o.assign(p);let h=me(r,p);r.assign(h)}else{let d=te(W(i,this.decay),W(ft(s),1-this.decay)),u=te(W(o,this.momentum),be(W(s,this.learningRate),wn(te(d,this.epsilon))));i.assign(d),o.assign(u);let c=me(r,u);r.assign(c)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Fe(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Fe(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Fe(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},TX=[OS,PS,LS,zS,BS,WS,xv];function EX(){for(let e of TX)RD(e)}var $n={};De($n,{CompositeArrayBuffer:()=>Us,browserFiles:()=>MX,browserHTTPRequest:()=>WX,concatenateArrayBuffers:()=>mG,copyModel:()=>PG,decodeWeights:()=>aF,decodeWeightsStream:()=>iF,encodeWeights:()=>uG,fromMemory:()=>VX,fromMemorySync:()=>PD,getLoadHandlers:()=>SG,getModelArtifactsForJSON:()=>_k,getModelArtifactsForJSONSync:()=>lF,getModelArtifactsInfoForJSON:()=>Kf,getSaveHandlers:()=>kG,getWeightSpecs:()=>yw,http:()=>VS,isHTTPScheme:()=>Nw,listModels:()=>MG,loadWeights:()=>PX,moveModel:()=>LG,registerLoadRouter:()=>wG,registerSaveRouter:()=>xG,removeModel:()=>OG,weightsLoaderFactory:()=>DD,withSaveHandler:()=>jX,withSaveHandlerSync:()=>HX});var _X="model",$X=".json",AX=".weights.bin";function VT(e){return new Promise(t=>setTimeout(t)).then(e)}var Ty=class Iw{constructor(t){if(!K().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Iw.URL_SCHEME)&&(t=t.slice(Iw.URL_SCHEME.length)),(t==null||t.length===0)&&(t=_X),this.modelJsonFileName=t+$X,this.weightDataFileName=t+AX}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=Us.join(t.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let a=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=oF(t,a),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await VT(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await VT(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Kf(t)}}}};Ty.URL_SCHEME="downloads://";var RX=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let a=JSON.parse(r.target.result),s=a.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=_k(a,o=>this.loadWeights(o));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map(s=>this.loadWeightsFile(s,r[s]));return Promise.all(a).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((n,r)=>{let a=new FileReader;a.onload=s=>{let i=s.target.result;n(i)},a.onerror=s=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(a=>BT(a.name)),r={};for(let a of e)a.paths.forEach(s=>{let i=BT(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},FX=e=>K().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ty.URL_SCHEME)?DX(e.slice(Ty.URL_SCHEME.length)):null;ta.registerSaveRouter(FX);function DX(e="model"){return new Ty(e)}function MX(e){return new RX(e)}function jT(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let a=0,s=l=>(l.then(d=>{let u=n+ ++a/e.length*(r-n);return t(u),d}),l);function i(l){D(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,d){D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),D(d>=0&&d<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${d}`),D(d>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${d}`)}return Promise.all(e.map(s))}async function FD(e,t){t==null&&(t={});let n=t.fetchFunc==null?K().platform.fetch:t.fetchFunc,r=e.map(s=>n(s,t.requestInit,{isBinary:!0})),a=(t.onProgress==null?await Promise.all(r):await jT(r,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(a):await jT(a,t.onProgress,.5,1)}function OX(e,t){var n;let r=t.fetchFunc==null?K().platform.fetch:t.fetchFunc,a=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;a<e.length;){s||(s=(await r(e[a],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:d}=await s.read();if(l){a++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,a/e.length);continue}i.enqueue(d);return}i.close()}})}async function PX(e,t="",n,r){return DD(a=>FD(a,{requestInit:r}))(e,t,n)}function DD(e){return async(t,n="",r)=>{let a=t.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((h,f)=>{let m=0;h.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=tl[y]*dt(g.shape),v=()=>{a[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((x,w)=>{x===g.name&&(v(),i[w]=!0)}):v(),o.push(g.name),m+=b})}),!i.every(h=>h)){let h=r.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce((h,f,m)=>(f&&h.push(m),h),[]),d=[];l.forEach(h=>{t[h].paths.forEach(f=>{let m=n+(n.endsWith("/")?"":"/")+f;d.push(m)})});let u=await e(d),c={},p=0;return l.forEach(h=>{let f=t[h].paths.length,m=new Us(u.slice(p,p+f));s[h].forEach(g=>{let y=m.slice(g.groupOffset,g.groupOffset+g.sizeBytes),b=aF(y,[g.manifestEntry]);for(let v in b)c[v]=b[v]}),p+=f}),c}}var LX="application/octet-stream",zX="application/json",US=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(D(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=K().platform.fetch,D(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=oF(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:zX}),"model.json"),e.weightData!=null){let s=Us.join(e.weightData);t.body.append("model.weights.bin",new Blob([s],{type:LX}),"model.weights.bin")}let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Kf(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return _k(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=yw(e.weightsManifest),r=()=>OX(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=BX(t),a=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):s.push(a+l+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),n=yw(e),r=await FD(t,this.loadOptions);return[n,r]}};US.URL_SCHEME_REGEX=/^https?:\/\//;function BX(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}function Nw(e){return e.match(US.URL_SCHEME_REGEX)!=null}var MD=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>Nw(r)):n=Nw(e),n)return VS(e,t)}return null};ta.registerSaveRouter(MD);ta.registerLoadRouter(MD);function VS(e,t){return new US(e,t)}function WX(e,t){return VS(e,t)}var Bx=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},OD=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},UX=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function VX(e,t,n,r){let a=arguments;return new UX(PD(...a))}function PD(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new Bx(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Bx({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Bx({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function jX(e){return new OD(e)}function HX(e){return new OD(e)}var LD={};De(LD,{confusionMatrix:()=>qX});function GX(e,t,n){let r=_(e,"labels","confusionMatrix"),a=_(t,"predictions","confusionMatrix");D(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),D(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),D(a.rank===1,()=>`Expected the rank of predictions to be 1, but got ${a.rank}`),D(r.shape[0]===a.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`),D(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=Hd(ue(r,"int32"),n),i=Hd(ue(a,"int32"),n),o=Ue(s),l=We(o,i);return ue(l,"int32")}var qX=z({confusionMatrix_:GX}),um={};De(um,{draw:()=>tQ,fromPixels:()=>nQ,fromPixelsAsync:()=>ZX,toPixels:()=>eQ});var bo,HT=!1;function zD(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(Kh(Sy,L.backendName)!=null){let p={pixels:e},h={numChannels:t};return L.runKernel(Sy,p,h)}let[l,d]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height],u;if(i)u=e.getContext("2d").getImageData(0,0,l,d).data;else if(r||n)u=e.data;else if(s||a||o){if(bo==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")bo=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else bo=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});bo.canvas.width=l,bo.canvas.height=d,bo.drawImage(e,0,0,l,d),u=bo.getImageData(0,0,l,d).data}let c;if(t===4)c=new Int32Array(u);else{let p=l*d;c=new Int32Array(p*t);for(let h=0;h<p;h++)for(let f=0;f<t;++f)c[h*t+f]=u[h*4+f]}return dv(c,[d,l,t],"int32")}function KX(e){return e!=null&&e.data instanceof Uint8Array}function XX(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function QX(e){return e!=null&&e.width!==0&&e.height!==0}function JX(e){return XX()&&!(e instanceof ImageBitmap)&&QX(e)&&!KX(e)}async function ZX(e,t=3){let n=null;if(K().getBool("WRAP_TO_IMAGEBITMAP")&&JX(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return zD(n,t)}function BD(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function YX(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function eQ(e,t){let n=_(e,"img","toPixels");if(!(e instanceof Pe)){let d=n;n=ue(d,"int32"),d.dispose()}BD(n);let[r,a]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(a*r*4);for(let d=0;d<r*a;++d){let u=[0,0,0,255];for(let p=0;p<s;p++){let h=i[d*s+p];if(n.dtype==="float32"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(n.dtype==="int32"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);s===1?(u[0]=h*o,u[1]=h*o,u[2]=h*o):u[p]=h*o}let c=d*4;l[c+0]=Math.round(u[0]),l[c+1]=Math.round(u[1]),l[c+2]=Math.round(u[2]),l[c+3]=Math.round(u[3])}if(t!=null){HT||Kh($b,L.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),HT=!0),t.width=a,t.height=r;let d=t.getContext("2d"),u=new ImageData(l,a,r);d.putImageData(u,0,0)}return n!==e&&n.dispose(),l}function tQ(e,t,n){let r=_(e,"img","draw");if(!(e instanceof Pe)){let i=r;r=ue(i,"int32"),i.dispose()}BD(r),YX(n==null?void 0:n.imageOptions);let a={image:r},s={canvas:t,options:n};L.runKernel($b,a,s)}var nQ=z({fromPixels_:zD}),jS={};De(jS,{prepareAndValidate:()=>WD});function WD(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(dt(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let c=0;c<a.length-1;++c)i*=a[c];let o=e.shape,l=a.slice();l.pop();let d=1;for(let c=s;c<n;++c)d*=o[c],l.push(o[c]);let u=[...dc(e.shape).map(c=>c/d),1].slice(0,s);return[l,i,d,u]}var ln={};De(ln,{assertParamsValid:()=>aQ,computeFlatOffset:()=>uQ,computeOutShape:()=>iQ,getNormalizedAxes:()=>oQ,isSliceContinous:()=>lQ,maskToAxes:()=>sQ,parseSliceParams:()=>QD,sliceInfo:()=>dQ,startForAxis:()=>KD,startIndicesWithElidedDims:()=>HD,stopForAxis:()=>XD,stopIndicesWithElidedDims:()=>GD,stridesForAxis:()=>qD,stridesWithElidedDims:()=>UD});var Cw=-2,rQ=-1;function aQ(e,t,n){let r=e.shape.length;D(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),D(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let a=0;a<r;++a)D(t[a]+n[a]<=e.shape[a],()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function sQ(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function iQ(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function UD(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)s===0?a[t]=1:(a.splice(t,0,1),a.pop());return a}function VD(e,t,n){return n<=e?n:n-(t-1)}function jD(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function oQ(e,t,n,r,a,s,i,o,l){let d=e.length,u=new Array(d),c=new Array(d),p=new Array(d);if(t.length&&n>0){let h=t[0],f=n+1;u=HD(i,h,f,r,e),c=GD(o,h,f,a,e),p=UD(s,h,f,e)}else for(let h=0;h<d;h++)u[h]=KD(i,r,s,e,h,l),c[h]=XD(o,a,s,e,h,l),p[h]=qD(s,h,l);return{begin:u,end:c,strides:p}}function HD(e,t,n,r,a){let s=[...a],i=jD(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let l=VD(t,n,o),d=r[l];e&1<<l&&(d=0),s[o]=d}return s}function GD(e,t,n,r,a){let s=[...a],i=jD(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=VD(t,n,o),d=r[l];e&1<<l&&(d=Number.MAX_SAFE_INTEGER),s[o]=d}for(let o=0;o<s.length;o++){let l=a[o];s[o]<0&&(s[o]+=l),s[o]=Gh(0,s[o],a[o])}return s}function qD(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function KD(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=Gh(0,i,l-1),i}function XD(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),o>0?i=Gh(0,i,l):i=Gh(-1,i,l-1),i}function lQ(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function uQ(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function QD(e,t,n){let r,a=e.shape.length;typeof t=="number"?r=[t,...new Array(a-1).fill(0)]:t.length<a?r=t.concat(new Array(a-t.length).fill(0)):r=t.slice(),r.forEach(i=>{D(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(a).fill(-1):typeof n=="number"?s=[n,...new Array(a-1).fill(-1)]:n.length<a?s=n.concat(new Array(a-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:(D(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,s]}function dQ(e,t,n,r,a,s,i,o,l){let d;if(r==null?(d=new Array(t.length),d.fill(1)):d=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1,c={dims:d.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:d.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<c.dims;b++)u&&1<<b&o&&c.numAddAxisAfterEllipsis++,1<<b&i&&(u=!0);u||(c.ellipsisMask|=1<<c.dims,c.dims++);let p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};cQ(c,p);let h=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(p.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);let v=!!(p.shrinkAxisMask&1<<b),x=e[b];if(x===-1){g.push(v?1:-1);continue}let w=[p.beginMask&1<<b,p.endMask&1<<b],I=[p.strides[b]>0?0:-1,p.strides[b]>0?x:x-1];if(v&&p.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&p.strides[b]===1;let N=!!(p.beginMask&1<<b&&p.endMask&1<<b);if(p.beginValid&&p.endValid){if(v){let F=p.begin[b]<0?x+p.begin[b]:p.begin[b];if(p.begin[b]=F,p.end[b]=p.begin[b]+1,F<0||F>=x)throw Error(`slice index ${p.begin[b]} of dimension ${b} out of bounds.`)}else p.begin[b]=GT(p.begin[b],0,p.strides[b],x,w,I),p.end[b]=GT(p.end[b],1,p.strides[b],x,w,I);let R=p.strides[b]===1&&p.begin[b]===0&&p.end[b]===x;h=h&&R,f=f&&(b===0&&p.strides[b]===1||R)}else h=h&&p.strides[b]===1&&N,f=f&&(b===0&&p.strides[b]===1||N);let T,A=!1;if(p.beginValid&&p.endValid?(T=p.end[b]-p.begin[b],A=!0):v?(T=1,A=!0):N&&x>=0&&(p.strides[b]<0?T=-x:T=x,A=!0),A){let R;T===0||T<0!=p.strides[b]<0?R=0:R=Math.trunc(T/p.strides[b])+(T%p.strides[b]!==0?1:0),g.push(R)}else g.push(-1)}for(let b=0;b<p.finalShapeGatherIndices.length;++b){let v=p.finalShapeGatherIndices[b];v>=0?y.push(g[v]):v===Cw&&y.push(1)}return{finalShapeSparse:y.filter((b,v)=>p.finalShapeGatherIndices[v]!==Cw),finalShape:y,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:p.begin,end:p.end,strides:p.strides}}function cQ(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Cw),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(rQ),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function GT(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let i=e<0?r+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var pQ="4.22.0",JD=class{static sgd(e){return new xv(e)}static momentum(e,t,n=!1){return new BS(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new WS(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new LS(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new OS(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new zS(e,t,n,r,a)}static adagrad(e,t=.1){return new PS(e,t)}},Io=JD,hQ=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function HS(){return new Promise(e=>hQ(()=>e()))}var E={};De(E,{ERF_A1:()=>EQ,ERF_A2:()=>_Q,ERF_A3:()=>$Q,ERF_A4:()=>AQ,ERF_A5:()=>RQ,ERF_P:()=>TQ,PARALLELIZE_THRESHOLD:()=>GS,RowPartitionType:()=>Za,SELU_SCALE:()=>YD,SELU_SCALEALPHA:()=>ZD,applyActivation:()=>bv,assertAndGetBroadcastShape:()=>yt,assertAxesAreInnerMostDims:()=>dq,assertParamsConsistent:()=>fQ,assignToTypedArray:()=>LQ,axesAreInnerMostDims:()=>rS,calculateShapes:()=>iD,checkEinsumDimSizes:()=>jQ,checkPadOnDimRoundingMode:()=>tr,combineLocations:()=>TF,combineRaggedTensorToTensorShapes:()=>gQ,complexWithEvenIndex:()=>MQ,complexWithOddIndex:()=>OQ,computeConv2DInfo:()=>Xf,computeConv3DInfo:()=>bF,computeDefaultPad:()=>zk,computeDilation2DInfo:()=>l8,computeOptimalWindowSize:()=>xQ,computeOutAndReduceShapes:()=>EF,computeOutShape:()=>mQ,computePool2DInfo:()=>yF,computePool3DInfo:()=>u8,convertConv2DDataFormat:()=>vF,decodeEinsumEquation:()=>UQ,eitherStridesOrDilationsAreOne:()=>fs,expandShapeToKeepDim:()=>il,exponent:()=>BQ,exponents:()=>zQ,fromStringArrayToUint8:()=>cJ,fromUint8ToStringArray:()=>dJ,getAxesPermutation:()=>_F,getBroadcastDims:()=>NF,getComplexWithIndex:()=>PQ,getEinsumComputePath:()=>HQ,getEinsumPermutation:()=>VQ,getFusedBiasGradient:()=>yv,getFusedDyActivation:()=>gv,getImageCenter:()=>wQ,getInnerMostAxes:()=>cq,getPermuted:()=>SQ,getRaggedRank:()=>bQ,getReductionAxes:()=>tn,getReshaped:()=>kQ,getReshapedPermuted:()=>IQ,getRowPartitionTypesHelper:()=>yQ,getSliceBeginCoords:()=>NQ,getSliceSize:()=>CQ,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>XQ,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>QQ,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>JQ,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>eJ,getSparseReshapeInputOutputMismatchErrorMessage:()=>nJ,getSparseReshapeInputOutputMultipleErrorMessage:()=>tJ,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>ZQ,getSparseReshapeNegativeOutputDimErrorMessage:()=>YQ,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>iJ,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>rJ,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>aJ,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>sJ,getUndoAxesPermutation:()=>aS,isIdentityPermutation:()=>GQ,log:()=>xH,mergeRealAndImagArrays:()=>FQ,prepareAndValidate:()=>WD,prepareSplitSize:()=>KQ,segment_util:()=>eM,shouldFuse:()=>vv,slice_util:()=>ln,splitRealAndImagArrays:()=>DQ,stridesOrDilationsArePositive:()=>sl,tupleValuesAreOne:()=>Oi,upcastType:()=>ea,validateDefaultValueShape:()=>vQ,validateInput:()=>pv,validateUpdateShape:()=>CS,warn:()=>di});function fQ(e,t){let n=e[0].length;e.forEach((a,s)=>{D(a.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),D(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((a,s)=>{for(let i=0;i<n;i++)D(i===t||a[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${a}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function mQ(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var Za;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Za||(Za={}));function gQ(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function yQ(e){let t={FIRST_DIM_SIZE:Za.FIRST_DIM_SIZE,VALUE_ROWIDS:Za.VALUE_ROWIDS,ROW_LENGTHS:Za.ROW_LENGTHS,ROW_SPLITS:Za.ROW_SPLITS,ROW_LIMITS:Za.ROW_LIMITS,ROW_STARTS:Za.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function bQ(e){return e.length===0?0:e[0]===Za.FIRST_DIM_SIZE?e.length-1:e.length}function vQ(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let s=e[a],i=t[a+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${s} but ragged tensor input.flatValues.shape[${a-e.length}] = ${i}`)}}var GS=30;function xQ(e){return e<=GS?e:ky(e,Math.floor(Math.sqrt(e)))}function wQ(e,t,n){let r=n*(typeof e=="number"?e:e[0]),a=t*(typeof e=="number"?e:e[1]);return[r,a]}function kQ(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)a=a.concat([e[i+1]/t[i],t[i]]);a=a.concat(e.slice(s+1))}return a}function SQ(e,t,n=!0){let r=[];if(n){r.push(t);for(let a=t+1;a<e;++a)a<=2*t?(r.push(a),r.push(a-(t+1))):r.push(a)}else{let a=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):a.push(i);r.push(...a),r.push(0),r.push(...s)}return r}function IQ(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function NQ(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function CQ(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var ZD=1.7580993408473768,YD=1.0507009873554805,TQ=.3275911,EQ=.254829592,_Q=-.284496736,$Q=1.421413741,AQ=-1.453152027,RQ=1.061405429;function FQ(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function DQ(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function MQ(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function OQ(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function PQ(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function LQ(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function zQ(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function BQ(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}var Wx="->",WQ=/->/g,qT=",",KT="...";function UQ(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(WQ,"").length)/Wx.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Wx}").`);let[r,a]=e.split(Wx);D(r.indexOf(KT)===-1,()=>`The ellipsis notation ("${KT}") is not supported yet.`);let s=r.split(qT),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let p=0;p<a.length;++p){let h=a[p];if(!s.some(f=>f.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);o.indexOf(h)===-1&&o.push(h)}for(let p=0;p<r.length;++p){let h=r[p];o.indexOf(h)===-1&&h!==qT&&o.push(h)}let l=new Array(s.length);for(let p=0;p<i;++p){if(new Set(s[p].split("")).size!==s[p].length)throw new Error(`Found duplicate axes in input component ${s[p]}. Support for duplicate axes in input is not implemented yet.`);l[p]=[];for(let h=0;h<s[p].length;++h)l[p].push(o.indexOf(s[p][h]))}let d=o.length,u=a.length,c=[];for(let p=u;p<d;++p)c.push(p);return{allDims:o,summedDims:c,idDims:l}}function VQ(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)n[a]===-1&&r.push(a);return n=n.filter(a=>a!==-1),{permutationIndices:n,expandDims:r}}function jQ(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let s=n[a].shape;for(let i=0;i<t[a].length;++i)r[t[a][i]]===void 0?r[t[a][i]]=s[i]:D(r[t[a][i]]===s[i],()=>`Expected dimension ${r[t[a][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function HQ(e,t){let n=e,r=[],a=0;e.length===0&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],l=qQ(t,o);for(let d of l)s.indexOf(d)===-1&&(r[i].push(d),s.push(d))}return{path:n,steps:r}}function GQ(e){return e.every((t,n)=>t===n)}function qQ(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function KQ(e,t,n=0){let r=[];if(typeof t=="number")D(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let a=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);D(a<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}D(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function XQ(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function QQ(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function JQ(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function ZQ(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function YQ(e,t){return`size ${e} must be non-negative, not ${t}`}function eJ(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function tJ(e,t){let n=dt(e),r=dt(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function nJ(e,t){let n=dt(e),r=dt(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function rJ(){return"segment ids must be >= 0"}function aJ(){return"segment ids are not increasing"}function sJ(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function iJ(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var eM={};De(eM,{collectGatherOpShapeInfo:()=>uJ,computeOutShape:()=>lJ,segOpComputeOptimalWindowSize:()=>oJ});function oJ(e,t){let n=!1,r;for(e<=GS?(r=e,n=!0):r=ky(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=ky(e,r+1);return r}function lJ(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function uJ(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(r!==0&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let c=0;c<r;++c)if(e.shape[c]!==t.shape[c])throw new Error(`x.shape[${c}]: ${e.shape[c]} should be equal to indices.shape[${c}]: ${t.shape[c]}.`);let i=e.shape[n],o=[],l=1,d=1,u=1;for(let c=0;c<r;++c)o.push(e.shape[c]),l*=e.shape[c];for(let c=r;c<n;c++)o.push(e.shape[c]),d*=e.shape[c];for(let c=r;c<a;c++)o.push(t.shape[c]);for(let c=n+1;c<s;c++)o.push(e.shape[c]),u*=e.shape[c];return{batchSize:l,sliceSize:u,outerSize:d,dimSize:i,outputShape:o}}function dJ(e){try{return e.map(t=>Ny(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function cJ(e){return e.map(t=>Gf(t))}var gs={};De(gs,{nonMaxSuppressionV3Impl:()=>xD,nonMaxSuppressionV4Impl:()=>wD,nonMaxSuppressionV5Impl:()=>kD,whereImpl:()=>uD});EX();var tM={kernelName:cc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,Wu(ue(n,"float32"),-1))}}},pJ={kernelName:xl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=ft(ue(n,"float32")),a=wn(me(Ce(1),r));return St(be(e,a))}}}},hJ={kernelName:wl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=wn(me(ft(ue(n,"float32")),1));return be(e,r)}}}},fJ={kernelName:Yi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=yt(n.shape,r.shape);return{a:()=>{let s=e,i=tn(n.shape,a);return i.length>0&&(s=ke(s,i)),V(s,n.shape)},b:()=>{let s=e,i=tn(r.shape,a);return i.length>0&&(s=ke(s,i)),V(s,r.shape)}}}},mJ={kernelName:kl,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,a)=>{n[a]=()=>e.clone()}),n}},gJ={kernelName:fc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ze(n)}}},yJ={kernelName:mc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ze(n)}}},bJ={kernelName:Sl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>be(e,wn(me(Ce(1),ft(ue(n,"float32")))))}}},vJ={kernelName:Il,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=wn(te(Ce(1),ft(ue(n,"float32"))));return be(e,r)}}}},xJ={kernelName:Tl,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=yt(n.shape,r.shape);return{a:()=>{let s=te(ft(n),ft(r)),i=W(e,be(r,s)),o=tn(n.shape,a);return o.length>0&&(i=ke(i,o)),V(i,n.shape)},b:()=>{let s=te(ft(n),ft(r)),i=St(W(e,be(n,s))),o=tn(r.shape,a);return o.length>0&&(i=ke(i,o)),V(i,r.shape)}}}},wJ={kernelName:Nl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>be(e,te(ft(ue(n,"float32")),1))}}},kJ={kernelName:Cl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>be(e,me(Ce(1),ft(ue(n,"float32"))))}}};function SJ(e,t,n,r,a,s){let i=_(e,"dy","avgPool3dGrad"),o=_(t,"input","avgPool3dGrad"),l=i,d=o,u=!1;o.rank===4&&(u=!0,l=V(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=V(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),D(d.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),tr("avgPool3dGrad",a,s);let c={dy:l,input:d},p={filterSize:n,strides:r,pad:a,dimRoundingMode:s},h=L.runKernel(If,c,p);return u?V(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var IJ=z({avgPool3dGrad_:SJ}),NJ={kernelName:gc,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>IJ(e,r,a,s,i,o)}}};function CJ(e,t,n,r,a){let s=_(e,"dy","avgPoolGrad"),i=_(t,"input","avgPoolGrad");D(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,d=!1;i.rank===3&&(d=!0,o=V(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=V(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),D(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let u={dy:l,input:o},c={filterSize:n,strides:r,pad:a},p=L.runKernel(Sf,u,c);return d?V(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var TJ=z({avgPoolGrad_:CJ}),EJ={kernelName:El,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>TJ(e,r,a,s,i)}}},_J={kernelName:_l,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>We(e,a,!1,!0),b:()=>We(r,e,!0,!1)}:!s&&i?{a:()=>We(e,a,!1,!1),b:()=>We(e,r,!0,!1)}:s&&!i?{a:()=>We(a,e,!1,!0),b:()=>We(r,e,!1,!1)}:{a:()=>We(a,e,!0,!0),b:()=>We(e,r,!0,!0)}}},$J={kernelName:yc,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>am(e,r,a)}}},AJ={kernelName:BR,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(a[l]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>ke(e,o,!0)}}},RJ={kernelName:$l,gradFunc:e=>({x:()=>e.clone()})},FJ={kernelName:Al,gradFunc:e=>({x:()=>Ze(e)})},DJ={kernelName:eo,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>xn(ba(js(r,a),ao(r,s)),e,Ze(e))}}},MJ={kernelName:Cf,inputsToSave:["x"],gradFunc:tM.gradFunc},OJ={kernelName:xc,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:a}=n,s=va(a,t[0].shape)[0],i=r.map(o=>o[s]);return cr(e,i,s).map(o=>()=>o)}},PJ={kernelName:Rl,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return D(Oi(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>Qk(r.shape,e,a,i,o,l),filter:()=>FS(r,e,a.shape,i,o,l)}}},LJ={kernelName:Fl,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Jn(e,a,s,i,o,1,l),filter:()=>FS(e,r,a.shape,s,i,o,l)}}};function zJ(e,t,n,r,a){let s=e;e.rank===4&&(s=V(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=V(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),D(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),D(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),D(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),D(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),D(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return L.runKernel(wc,o,l)}var BJ=z({conv3DBackpropFilter_:zJ}),WJ={kernelName:Dl,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;D(Oi(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>SF(i.shape,e,o,a,s),filter:()=>BJ(i,e,o.shape,a,s)}}},UJ={kernelName:Ml,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(St(sv(ue(n,"float32"))),e)}}},VJ={kernelName:Ol,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(iv(ue(n,"float32")),e)}}},jJ={kernelName:Pl,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let o=_F([a],r.rank),l=qb(e,a,s,!i);return o!=null&&(l=Ue(l,o)),l}}}},HJ={kernelName:Ll,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=r??[1,1];D(Oi(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,d]=t;return D(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),D(d.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${d.rank}.`),D(l.shape[3]===d.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),D(fs(a,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`),tr("depthwiseConv2d",s,i),{x:()=>yD(l.shape,e,d,a,s,o,i),filter:()=>gD(l,e,d.shape,a,s,o,i)}}},GJ={kernelName:zl,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>L.runKernel(Bd,s,n),filter:()=>L.runKernel(Wd,i,n)}}},qJ={kernelName:Wl,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>L.runKernel(Cc,r)}}},KJ={kernelName:Ul,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=W(Pn(St(ft(n))),2/Math.sqrt(Math.PI));return{x:()=>W(e,r)}}},XJ={kernelName:Vl,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,n)}}},QJ={kernelName:Ec,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>V(e,n.shape)}}},JJ={kernelName:jl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,Pn(n))}}},ZJ={kernelName:Hl,gradFunc:e=>({x:()=>Ze(e)})},YJ={kernelName:Gl,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=yt(n.shape,r.shape);return{a:()=>{let s=be(e,ue(r,"float32")),i=tn(n.shape,a);return i.length>0?V(ke(s,i),n.shape):s},b:()=>{let s=W(e,ue(n,"float32")),i=tn(r.shape,a);i.length>0&&(s=V(ke(s,i),r.shape));let o=ft(r);return St(be(s,ue(o,"float32")))}}}},eZ={kernelName:ql,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=o??Ce(1),d=tn(s.shape,a.shape),u=[];if(s.rank===1){for(let m=0;m<a.shape.length-1;++m)u.push(a.shape[m]);u.push(1)}let c=me(a,s),p=W(e,l),h=rv(te(i,Ce(r))),f=W(W(W(h,h),h),Ce(-.5));return{x:()=>s.rank===1?V(W(W(e,Er(V(h,[1,1,1,s.shape[0]]),u)),l),a.shape):V(W(W(e,h),l),a.shape),mean:()=>{let m=W(W(h,Ce(-1)),p);return s.rank===1&&(m=ke(m,d)),V(m,s.shape)},variance:()=>{let m=W(W(f,c),p);return s.rank===1&&(m=ke(m,d)),V(m,s.shape)},scale:()=>{let m=W(c,h),g=W(e,m);return s.rank===1&&(g=ke(g,d)),V(g,s.shape)},offset:()=>{let m=e;return s.rank===1&&(m=ke(m,d)),V(m,s.shape)}}}},tZ={kernelName:$c,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s,batchDims:i}=n,o=va(s,r.shape)[0],l=(d,u,c)=>()=>{let p=d.shape,h=u.size,f=p.slice(0,o),m=f.length,g=p.slice(s,p.length).slice(1),y=g.length,b=XT(0,m),v=XT(m+1,m+1+y),x=QT([f,[h],g]),w=V(c,x),I=V(u,[h]),N=QT([[m],b,v]),T=Ue(w,N),A=fv(T,I,d.shape[o]),R=aS(N);return A=Ue(A,R),A};if(i===1){let d=r.shape[0],u=r.split(d,0);return{x:()=>en(u.map((c,p)=>l(c,a.slice(p,1),e.slice(p,1))())).reshape(r.shape),indices:()=>a}}else return{x:l(r,a,e),indices:()=>a}}};function XT(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function QT(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var nZ={kernelName:Kl,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Ze(n),b:()=>Ze(r)}}},rZ={kernelName:Xl,gradFunc:e=>({x:()=>ue(e,"float32")})},aZ={kernelName:Ql,gradFunc:e=>({x:()=>Ze(e)})},sZ={kernelName:Jl,gradFunc:e=>({x:()=>Ze(e)})},iZ={kernelName:Zl,gradFunc:e=>({x:()=>Ze(e)})},oZ={kernelName:Yl,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=nr(r,0);return{x:()=>xn(s,e,W(e,a))}}},lZ={kernelName:tu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>be(e,te(n,1))}}},uZ={kernelName:eu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>be(e,ue(n,"float32"))}}},dZ={kernelName:UR,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let s=Pn(r);return me(e,W(ke(e,a,!0),s))}}}};function cZ(e,t,n,r=5,a=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:i};return L.runKernel(zc,o,l)}var pZ=z({localResponseNormalizationBackprop_:cZ}),hZ={kernelName:nu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>pZ(r,a,e,s,i,o,l)}}};function nM(e,t,n,r){return t.rank<n.rank&&(t=V(t,il(t.shape,r))),e.rank<n.rank&&(e=V(e,il(e.shape,r))),{x:()=>W(e,ue(Or(n,t),e.dtype))}}var JT={kernelName:ru,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=t[1],o=va(a,s.shape),l=nM(e,i,s,o);return{x:()=>l.x()}}},fZ={kernelName:au,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>W(e,ue(js(n,r),"float32")),b:()=>W(e,ue(jd(n,r),"float32"))}}};function mZ(e,t,n,r,a,s,i){let o=_(e,"dy","maxPool3dGrad"),l=_(t,"input","maxPool3dGrad"),d=_(n,"output","maxPool3dGrad"),u=o,c=l,p=d,h=!1;l.rank===4&&(h=!0,u=V(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=V(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=V(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),D(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),D(c.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),D(p.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`),tr("maxPool3dGrad",s,i);let f={dy:u,input:c,output:p},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=L.runKernel(Af,f,m);return h?V(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var gZ=z({maxPool3dGrad_:mZ}),yZ={kernelName:Bc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>gZ(e,r,a,s,i,o,l)}}};function bZ(e,t,n,r,a,s,i){let o=_(e,"dy","maxPoolGrad"),l=_(t,"input","maxPoolGrad"),d=_(n,"output","maxPoolGrad");D(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),D(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),D(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),tr("maxPoolGrad",s,i);let u={dy:o,input:l,output:d},c={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return L.runKernel($f,u,c)}var vZ=z({maxPoolGrad_:bZ}),xZ={kernelName:su,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>vZ(e,r,a,s,i,o)}}},wZ={kernelName:iu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=va(a,r.shape),i=EF(r.shape,s)[1],o=dt(i);return{x:()=>{let l=r.shape.slice();s.forEach(u=>{l[u]=1});let d=V(e,l);return be(W(d,ur(r.shape,"float32")),o)}}}},kZ={kernelName:ou,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=va(a,s.shape),l=nM(e,i,s,o);return{x:()=>l.x()}}},SZ={kernelName:lu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>W(e,ue(ao(n,r),"float32")),b:()=>W(e,ue(nr(n,r),"float32"))}}},IZ={kernelName:uu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Xe(e,s,r.shape)}}},NZ={kernelName:du,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=yt(n.shape,r.shape);return{a:()=>{let s=tn(n.shape,a);return s.length>0?V(ke(e,s),n.shape):e},b:()=>{let s=W(e,St(gp(be(n,r)))),i=tn(r.shape,a);return i.length>0?V(ke(s,i),r.shape):s}}}},CZ={kernelName:cu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=yt(n.shape,r.shape);return{a:()=>{let s=W(e,ue(r,"float32")),i=tn(n.shape,a);return i.length>0?V(ke(s,i),n.shape):s},b:()=>{let s=W(e,ue(n,"float32")),i=tn(r.shape,a);return i.length>0?V(ke(s,i),r.shape):s}}}},TZ={kernelName:Uc,gradFunc:e=>({x:()=>St(e)})},EZ={kernelName:pu,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>Dt(n.shape,"float32")}}},_Z={kernelName:qc,gradFunc:e=>({x:()=>Ze(e)})},$Z={kernelName:Kc,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return Ut(e,r).map(a=>()=>a)}},ZT={kernelName:hu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Xe(e,s,r.shape)}}},AZ={kernelName:fu,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=yt(s.shape,i.shape);return{a:()=>{let l=ue(i,"float32"),d=W(e,W(l,ds(s,me(l,Ce(1))))),u=tn(s.shape,o);return u.length>0&&(d=ke(d,u)),V(d,s.shape)},b:()=>{let l=nr(s,0),d=xn(l,Pr(s),Ze(s)),u=W(e,W(a,d)),c=tn(i.shape,o);return c.length>0&&(u=ke(u,c)),V(u,i.shape)}}}},RZ={kernelName:mu,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=nr(n,0);return{x:()=>xn(a,e,W(e,r)),alpha:()=>{let s=xn(a,Ze(e),W(e,n)),i=tn(r.shape,e.shape);return i.length>0&&(s=ke(s,i)),V(s,r.shape)}}}};function FZ(e,t,n){let r=e.shape.slice();r[n]=1;let a=V(t,r),s=ef(e,n,!0,!1),i=ef(e,n,!0,!0),o=W(s,i);return W(a,o)}function DZ(e,t,n){let r=e.shape.length,a=r-n.length,s=E.getAxesPermutation(n,r),i=e;s!=null&&(i=Ue(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((c,p)=>c*p,1);o.push(l);let d=i.reshape(o),u=FZ(d,t,a);if(u=u.reshape(i.shape),s!=null){let c=E.getUndoAxesPermutation(s);u=Ue(u,c)}return u}var MZ={kernelName:gu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return a==null?s=r.shape.map((i,o)=>o):typeof a=="number"?s=[a]:s=a,{x:()=>DZ(r,e,s)}}},OZ={kernelName:Bl,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=yt(n.shape,r.shape);return{a:()=>{let s=be(e,ue(r,"float32")),i=tn(n.shape,a);return i.length>0?V(ke(s,i),n.shape):s},b:()=>{let s=W(e,ue(n,"float32")),i=tn(r.shape,a);i.length>0&&(s=V(ke(s,i),r.shape));let o=ft(r);return St(be(s,ue(o,"float32")))}}}},PZ={kernelName:yu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>be(e,St(ft(n)))}}},LZ={kernelName:wu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=W(ao(n,6),Wu(n));return{x:()=>W(e,ue(r,"float32"))}}},zZ={kernelName:bu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,ue(Wu(n),"float32"))}}},BZ={kernelName:Xc,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>V(e,n.shape)}}},WZ={kernelName:xu,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>L.runKernel(Jc,a,n)}}},UZ={kernelName:vu,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>L.runKernel(Qc,a,n)}}},VZ={kernelName:ku,gradFunc:(e,t,n)=>{let{dims:r}=n,a=va(r,e.shape);return{x:()=>na(e,a)}}},jZ={kernelName:Su,gradFunc:e=>({x:()=>Ze(e)})},HZ={kernelName:Iu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>St(be(e,W(ds(n,1.5),2)))}}},GZ={kernelName:tp,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>ue(Ze(n),"float32"),t:()=>W(e,ue(n,e.dtype)),e:()=>W(e,ue(nm(n),e.dtype))}}},qZ={kernelName:Nu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=nr(n,Ce(0)),a=Ce(ZD),s=Ce(YD),i=W(e,s),o=W(W(e,a),Pn(ue(n,"float32")));return xn(r,i,o)}}}},KZ={kernelName:_u,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,W(n,me(Ce(1),n)))}}},XZ={kernelName:Eu,gradFunc:e=>({x:()=>Ze(e)})},QZ={kernelName:Cu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(Jf(ue(n,"float32")),e)}}},JZ={kernelName:Tu,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(Gb(ue(n,"float32")),e)}}},ZZ={kernelName:np,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=QD(r,a,s),d=[];for(let u=0;u<e.rank;u++)d.push([o[u],i[u]-o[u]-l[u]]);return{x:()=>Ua(e,d)}}},YZ={kernelName:Fu,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=!0,i=W(e,r);return{logits:()=>me(i,W(ke(i,[a],s),r))}}},eY={kernelName:$u,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,ma(n))}}},YT={kernelName:rp,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>Qf(e,r,a)}}},eE={kernelName:ap,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>gt(e,r)}}},tY={kernelName:Au,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>be(e,W(wn(ue(n,"float32")),2))}}},nY={kernelName:Pf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,W(ue(n,"float32"),2))}}},rY={kernelName:Du,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Ce(2);return{a:()=>W(e,W(a,me(n,r))),b:()=>W(e,W(a,me(r,n)))}}},aY={kernelName:no,gradFunc:e=>({x:()=>Ze(e)})},sY={kernelName:Mu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=yt(n.shape,r.shape);return{a:()=>{let s=e,i=tn(n.shape,a);return i.length>0&&(s=ke(s,i)),V(s,n.shape)},b:()=>{let s=e,i=tn(r.shape,a);return i.length>0&&(s=ke(s,i)),V(St(s),r.shape)}}}},iY={kernelName:Ru,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;va(s,r.shape).forEach(l=>{a[l]=1});let i=V(e,a),o=W(i,ur(r.shape,"float32"));return{x:()=>o}}},oY={kernelName:Ou,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>be(e,ft(Jf(n)))}}},lY={kernelName:Pu,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(me(Ce(1),ft(n)),e)}}},uY={kernelName:to,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let s=Ze(r);if(r.rank===1)for(let i=0;i<a[0];++i)s=te(s,Xe(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)s=te(s,Xe(e,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)s=te(s,Xe(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)for(let d=0;d<a[3];++d)s=te(s,Xe(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2],d*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return s}}}},dY={kernelName:As,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=aS(a);return{x:()=>Ue(e,s)}}},cY={kernelName:dp,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>en(e,a)}}},pY={kernelName:Vf,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>hY(e,n)}}};function hY(e,t){let n=ms(t,Ze(t)),r=yp(e,n),a=js(t,Ce(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=yn(a,o+1);a=ba(a,ur(r.shape,"bool"));let i=Ze(r);return xn(a,r,i)}var fY={kernelName:cp,gradFunc:e=>({x:()=>Ze(e)})},mY=[tM,pJ,hJ,fJ,mJ,gJ,yJ,bJ,vJ,xJ,wJ,kJ,NJ,EJ,_J,$J,AJ,RJ,FJ,DJ,MJ,OJ,LJ,PJ,WJ,UJ,VJ,jJ,HJ,GJ,OZ,qJ,KJ,XJ,QJ,JJ,YJ,ZJ,eZ,tZ,nZ,rZ,aZ,sZ,iZ,oZ,lZ,uZ,dZ,hZ,JT,JT,fZ,yZ,xZ,wZ,kZ,SZ,IZ,NZ,CZ,TZ,EZ,_Z,$Z,ZT,ZT,AZ,RZ,MZ,PZ,LZ,zZ,BZ,WZ,UZ,VZ,jZ,HZ,GZ,qZ,KZ,XZ,QZ,JZ,ZZ,YZ,eY,YT,YT,eE,eE,tY,rY,nY,aY,sY,iY,oY,lY,uY,dY,cY,pY,fY];for(let e of mY)VR(e);ne().prototype.abs=function(){return this.throwIfDisposed(),Xt(this)};ne().prototype.acos=function(){return this.throwIfDisposed(),Ak(this)};ne().prototype.acosh=function(){return this.throwIfDisposed(),Rk(this)};ne().prototype.add=function(e){return this.throwIfDisposed(),te(this,e)};ne().prototype.all=function(e,t){return this.throwIfDisposed(),Vb(this,e,t)};ne().prototype.any=function(e,t){return this.throwIfDisposed(),Jh(this,e,t)};ne().prototype.argMax=function(e){return this.throwIfDisposed(),al(this,e)};ne().prototype.argMin=function(e){return this.throwIfDisposed(),Fk(this,e)};ne().prototype.asScalar=function(){return this.throwIfDisposed(),D(this.size===1,()=>"The array must have only 1 element."),V(this,[])};ne().prototype.asType=function(e){return this.throwIfDisposed(),ue(this,e)};ne().prototype.as1D=function(){return this.throwIfDisposed(),V(this,[this.size])};ne().prototype.as2D=function(e,t){return this.throwIfDisposed(),V(this,[e,t])};ne().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),V(this,[e,t,n])};ne().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),V(this,[e,t,n,r])};ne().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),V(this,[e,t,n,r,a])};ne().prototype.asin=function(){return this.throwIfDisposed(),Dk(this)};ne().prototype.asinh=function(){return this.throwIfDisposed(),Mk(this)};ne().prototype.atan=function(){return this.throwIfDisposed(),Ok(this)};ne().prototype.atan2=function(e){return this.throwIfDisposed(),Pk(this,e)};ne().prototype.atanh=function(){return this.throwIfDisposed(),Lk(this)};ne().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Vs(this,e,t,n,r)};ne().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Qf(this,e,t)};ne().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),Lu(this,e,t,n,r,a)};ne().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Bo(this,e)};ne().prototype.cast=function(e){return this.throwIfDisposed(),ue(this,e)};ne().prototype.ceil=function(){return this.throwIfDisposed(),Hk(this)};ne().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),On(this,e,t)};ne().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Pe&&(e=[e]),gt([this,...e],t)};ne().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),jb(this,e,t,n,r,a,s)};ne().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),Hb(this,e,t,n,r,a)};ne().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Jn(this,e,t,n,r,a,s)};ne().prototype.cos=function(){return this.throwIfDisposed(),Jf(this)};ne().prototype.cosh=function(){return this.throwIfDisposed(),Gb(this)};ne().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),ef(this,e,t,n)};ne().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),qb(this,e,t,n)};ne().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Yk(this,e,t)};ne().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),zu(this,e,t,n,r,a,s)};ne().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),eS(this,e,t,n,r,a)};ne().prototype.divNoNan=function(e){return this.throwIfDisposed(),tS(this,e)};ne().prototype.div=function(e){return this.throwIfDisposed(),be(this,e)};ne().prototype.dot=function(e){return this.throwIfDisposed(),nS(this,e)};ne().prototype.elu=function(){return this.throwIfDisposed(),fp(this)};ne().prototype.equal=function(e){return this.throwIfDisposed(),Or(this,e)};ne().prototype.erf=function(){return this.throwIfDisposed(),Kb(this)};ne().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),sS(this,e,t)};ne().prototype.exp=function(){return this.throwIfDisposed(),Pn(this)};ne().prototype.expandDims=function(e){return this.throwIfDisposed(),yn(this,e)};ne().prototype.expm1=function(){return this.throwIfDisposed(),iS(this)};ne().prototype.fft=function(){return this.throwIfDisposed(),om(this)};ne().prototype.flatten=function(){return this.throwIfDisposed(),V(this,[this.size])};ne().prototype.floor=function(){return this.throwIfDisposed(),gp(this)};ne().prototype.floorDiv=function(e){return this.throwIfDisposed(),Ub(this,e)};ne().prototype.gather=function(e,t,n){return this.throwIfDisposed(),yp(this,e,t,n)};ne().prototype.greaterEqual=function(e){return this.throwIfDisposed(),js(this,e)};ne().prototype.greater=function(e){return this.throwIfDisposed(),nr(this,e)};ne().prototype.ifft=function(){return this.throwIfDisposed(),Kd(this)};ne().prototype.irfft=function(){return this.throwIfDisposed(),lv(this)};ne().prototype.isFinite=function(){return this.throwIfDisposed(),oS(this)};ne().prototype.isInf=function(){return this.throwIfDisposed(),lS(this)};ne().prototype.isNaN=function(){return this.throwIfDisposed(),uS(this)};ne().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Yf(this,e)};ne().prototype.lessEqual=function(e){return this.throwIfDisposed(),ao(this,e)};ne().prototype.less=function(e){return this.throwIfDisposed(),jd(this,e)};ne().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),dS(this,e,t,n,r)};ne().prototype.logSigmoid=function(){return this.throwIfDisposed(),cS(this)};ne().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Jb(this,e)};ne().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),tm(this,e,t)};ne().prototype.log=function(){return this.throwIfDisposed(),Pr(this)};ne().prototype.log1p=function(){return this.throwIfDisposed(),em(this)};ne().prototype.logicalAnd=function(e){return this.throwIfDisposed(),ba(this,e)};ne().prototype.logicalNot=function(){return this.throwIfDisposed(),nm(this)};ne().prototype.logicalOr=function(e){return this.throwIfDisposed(),Zb(this,e)};ne().prototype.logicalXor=function(e){return this.throwIfDisposed(),pS(this,e)};ne().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),We(this,e,t,n)};ne().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),hn(this,e,t,n,r)};ne().prototype.max=function(e,t){return this.throwIfDisposed(),Zr(this,e,t)};ne().prototype.maximum=function(e){return this.throwIfDisposed(),ms(this,e)};ne().prototype.mean=function(e,t){return this.throwIfDisposed(),Ft(this,e,t)};ne().prototype.min=function(e,t){return this.throwIfDisposed(),Vd(this,e,t)};ne().prototype.minimum=function(e){return this.throwIfDisposed(),Li(this,e)};ne().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),fS(this,e,t)};ne().prototype.mod=function(e){return this.throwIfDisposed(),mS(this,e)};ne().prototype.mul=function(e){return this.throwIfDisposed(),W(this,e)};ne().prototype.neg=function(){return this.throwIfDisposed(),St(this)};ne().prototype.norm=function(e,t,n){return this.throwIfDisposed(),mp(this,e,t,n)};ne().prototype.notEqual=function(e){return this.throwIfDisposed(),ol(this,e)};ne().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Hd(this,e,t,n)};ne().prototype.onesLike=function(){return this.throwIfDisposed(),Lr(this)};ne().prototype.pad=function(e,t){return this.throwIfDisposed(),Ua(this,e,t)};ne().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),gS(this,e,t,n,r,a,s)};ne().prototype.pow=function(e){return this.throwIfDisposed(),ds(this,e)};ne().prototype.prelu=function(e){return this.throwIfDisposed(),sm(this,e)};ne().prototype.prod=function(e,t){return this.throwIfDisposed(),yS(this,e,t)};ne().prototype.reciprocal=function(){return this.throwIfDisposed(),kS(this)};ne().prototype.relu=function(){return this.throwIfDisposed(),ut(this)};ne().prototype.relu6=function(){return this.throwIfDisposed(),tv(this)};ne().prototype.reshapeAs=function(e){return this.throwIfDisposed(),V(this,e.shape)};ne().prototype.reshape=function(e){return this.throwIfDisposed(),V(this,e)};ne().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),SD(this,e,t,n)};ne().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),ID(this,e,t,n)};ne().prototype.reverse=function(e){return this.throwIfDisposed(),na(this,e)};ne().prototype.rfft=function(){return this.throwIfDisposed(),lm(this)};ne().prototype.round=function(){return this.throwIfDisposed(),nv(this)};ne().prototype.rsqrt=function(){return this.throwIfDisposed(),rv(this)};ne().prototype.selu=function(){return this.throwIfDisposed(),av(this)};ne().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),bp(this,e,t,n,r,a,s)};ne().prototype.sigmoid=function(){return this.throwIfDisposed(),ma(this)};ne().prototype.sign=function(){return this.throwIfDisposed(),SS(this)};ne().prototype.sin=function(){return this.throwIfDisposed(),sv(this)};ne().prototype.sinh=function(){return this.throwIfDisposed(),iv(this)};ne().prototype.slice=function(e,t){return this.throwIfDisposed(),Xe(this,e,t)};ne().prototype.softmax=function(e){return this.throwIfDisposed(),io(this,e)};ne().prototype.softplus=function(){return this.throwIfDisposed(),Bu(this)};ne().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),am(this,e,t)};ne().prototype.split=function(e,t){return this.throwIfDisposed(),cr(this,e,t)};ne().prototype.sqrt=function(){return this.throwIfDisposed(),wn(this)};ne().prototype.square=function(){return this.throwIfDisposed(),ft(this)};ne().prototype.squaredDifference=function(e){return this.throwIfDisposed(),uv(this,e)};ne().prototype.squeeze=function(e){return this.throwIfDisposed(),oo(this,e)};ne().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Pe?[this,e]:[this,...e];return en(n,t)};ne().prototype.step=function(e){return this.throwIfDisposed(),Wu(this,e)};ne().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),IS(this,e,t,n,r,a,s,i,o)};ne().prototype.sub=function(e){return this.throwIfDisposed(),me(this,e)};ne().prototype.sum=function(e,t){return this.throwIfDisposed(),ke(this,e,t)};ne().prototype.tan=function(){return this.throwIfDisposed(),NS(this)};ne().prototype.tanh=function(){return this.throwIfDisposed(),Pi(this)};ne().prototype.tile=function(e){return this.throwIfDisposed(),Er(this,e)};ne().prototype.toBool=function(){return this.throwIfDisposed(),ue(this,"bool")};ne().prototype.toFloat=function(){return this.throwIfDisposed(),ue(this,"float32")};ne().prototype.toInt=function(){return this.throwIfDisposed(),ue(this,"int32")};ne().prototype.topk=function(e,t){return this.throwIfDisposed(),TS(this,e,t)};ne().prototype.transpose=function(e){return this.throwIfDisposed(),Ue(this,e)};ne().prototype.unique=function(e){return this.throwIfDisposed(),ES(this,e)};ne().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),fv(this,e,t)};ne().prototype.unstack=function(e){return this.throwIfDisposed(),Ut(this,e)};ne().prototype.where=function(e,t){return this.throwIfDisposed(),xn(e,this,t)};ne().prototype.zerosLike=function(){return this.throwIfDisposed(),Ze(this)};var ii=class rM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,rM.prototype)}},ns=class aM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,aM.prototype)}},H=class sM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,sM.prototype)}},Ge=class iM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,iM.prototype)}},gY=class oM extends Error{constructor(t){super(t),Object.setPrototypeOf(this,oM.prototype)}},lM=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function ul(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function Ya(e,t){if(!e)throw new gY(t)}function tE(e,t){let n=0;for(let r of e)r===t&&n++;return n}function lr(e){return e.length===1?e[0]:e}function lt(e){return Array.isArray(e)?e:[e]}function Is(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Eo(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var oa={};function qS(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Tw(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>Tw(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:Tw(r))}}}function dm(e,t={},n={},r="object",a=!1){if(typeof e=="string"){let s=e,i;if(s in n)i=n[s];else if(s in oa)i=oa[s];else if(i=t[s],i==null)throw new H(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new H(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,o,l;if(i in n?[o,l]=n[i]:i in oa?[o,l]=oa.className:i in t&&([o,l]=t[i]),o==null)throw new H(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let d={};for(let h of Object.keys(oa))d[h]=oa[h];for(let h of Object.keys(n))d[h]=n[h];let u=s.config;u.customObjects=d;let c=Object.assign({},oa);for(let h of Object.keys(n))oa[h]=n[h];Tw(s.config);let p=l(o,s.config,n,a);return oa=Object.assign({},c),p}else{let d=Object.assign({},oa);for(let c of Object.keys(n))oa[c]=n[c];let u=new o(s.config);return oa=Object.assign({},d),u}}}function yY(e,t){return e<t?-1:e>t?1:0}function lg(e,t){return-1*yY(e,t)}function Ei(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function bY(e){if(e==null)throw new H(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Uu(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new H(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function KS(e,t,n=0,r=1/0){return Ya(n>=0),Ya(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(a=>typeof a===t)}function vn(e,t){Array.isArray(e)?(k.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>vn(n,`element ${r+1} of ${t}`))):k.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${uM(e)}.`)}function uM(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>uM(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function vY(e,t,n){let r=n!=null?n():k.now(),a;return(...s)=>{let i=n!=null?n():k.now();return i-r<t||(r=i,a=e(...s)),a}}function dM(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var xY=0;function cM(){return xY++}var ug={};function wv(e=""){return e in ug||(ug[e]=0),ug[e]+=1,e+ug[e].toString()}var wY=["channelsFirst","channelsLast"],kY=["nearest","bilinear"],SY=["valid","same","causal"],IY=["max","avg"],NY=["sum","mul","concat","ave"],ed=new Map;function Ht(e){Uu(wY,"DataFormat",e)}function CY(e){Uu(kY,"InterpolationFormat",e)}function sa(e){Uu(SY,"PaddingMode",e)}function pM(e){Uu(IY,"PoolMode",e)}var Sh=[],nE="/";function Wo(e,t){Sh.push(e);try{let n=t();return Sh.pop(),n}catch(n){throw Sh.pop(),n}}function TY(){return Sh.length===0?"":Sh.join(nE)+nE}function hM(e){if(!mM(e))throw new Error("Not a valid tensor name: '"+e+"'");return TY()+e}function fM(e){if(!mM(e))throw new Error("Not a valid tensor name: '"+e+"'");ed.has(e)||ed.set(e,0);let t=ed.get(e);if(ed.set(e,ed.get(e)+1),t>0){let n=`${e}_${t}`;return ed.set(n,1),n}else return e}var EY=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function mM(e){return!!e.match(EY)}function _Y(e){return e===parseInt(e.toString(),10)}function _i(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function Qd(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function Bi(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function Oa(e,t){if(t<e)throw new H(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var Ux;function on(){return Ux==null&&(Ux=Tk().epsilon()),Ux}function Pa(){return"channelsLast"}function zs(e,t){return ue(e,t)}function cm(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),V(e,n)}function $Y(e,t){return j(()=>{if(e.shape.length!==2)throw new H(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=cm(e,1);return Ew(n,[1,t,1])})}function AY(e){let t=[_i(e.shape)];return V(e,t)}function RY(e){if(e.rank<=1)throw new H(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],_i(e.shape,1)];return V(e,t)}function Uo(e,t,n){return j(()=>{switch(e.rank){case 1:return im(e,t,n);case 2:return ov(e,[t,0],[n,e.shape[1]]);case 3:return vp(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return qd(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Xe(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Xe(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new H(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Vx(e,t,n){return j(()=>{switch(e.rank){case 1:return im(e,t,n);case 2:return ov(e,[0,t],[e.shape[0],n]);case 3:return vp(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return qd(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function dg(e,t,n,r){return j(()=>{switch(e.rank){case 1:return im(e,t,n);case 2:switch(r){case 1:return Uo(e,t,n);case 2:return Vx(e,t,n);default:throw new H(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Uo(e,t,n);case 2:return vp(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Vx(e,t,n);default:throw new H(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Uo(e,t,n);case 2:return qd(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return qd(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Vx(e,t,n);default:throw new H(`The axis is not within the rank of the tensor ${r}`)}default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function XS(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),gt(e,t)}function rE(e,t){switch(e.rank){case 1:return Gk([e,t]);case 2:return qk([e,t],0);case 3:return Kk([e,t],0);case 4:return Xk([e,t],0);default:throw new H(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Ew(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new H(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Er(e,t)}function kv(e,t=0,n=1,r,a){return ev(e,t,n,r,a)}function ls(e,t,n,r){if(e.rank<2||t.rank<2)throw new Ge(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let a=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(a!==s)throw new Ge(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Xd.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?_w(e.rank,r,Pa()):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=V(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),d=[...i,o],u=Array.from({length:t.rank},(p,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=V(Ue(t,u),[l,-1]);let c=[...a,...d];return V(Xd.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?_w(e.rank,r,Pa()):null,activation:n}),c)}}function gM(e,t,n){return j(()=>(Array.isArray(t)?t=ot(t,"int32"):t=ue(t,"int32"),yp(e,t,n)))}function pm(e){return W(e,e)}function _w(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new H(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?V(t,[1,r[0],1,1,1]):V(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?V(t,[1,1,1,1,r[0]]):V(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?V(t,[1,r[0],1,1]):V(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?V(t,[1,1,1,r[0]]):V(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?V(t,[1,r[0],1]):V(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?V(t,[1,1,r[0]]):V(t,[1].concat(r))}else if(e<3)return t;throw new H(`Unsupported input rank by biasAdd: ${t.rank}`)}function Va(e,t,n){return j(()=>(n==null&&(n=Pa()),Ht(n),te(e,_w(e.rank,t,n))))}function FY(e,t=1){if(t!==1)throw new Ge(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return fp(e)}function DY(e){return j(()=>be(e,te(Xt(e),1)))}function yM(e,t,n,r){return j(()=>AS(e,t,n,r))}function MY(e){return j(()=>{let t=te(.5,W(.2,e));return On(t,0,1)})}function hm(e,t,n=!1){return n?e():t()}var OY=["fanIn","fanOut","fanAvg"],PY=["normal","uniform","truncatedNormal"];function LY(e){Uu(OY,"FanMode",e)}function zY(e){Uu(PY,"Distribution",e)}var xa=class extends oe.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},QS=class extends xa{apply(e,t){return Dt(e,t)}};QS.className="Zeros";oe.registerClass(QS);var Sv=class extends xa{apply(e,t){return ur(e,t)}};Sv.className="Ones";oe.registerClass(Sv);var JS=class extends xa{constructor(e){if(super(),typeof e!="object")throw new H(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new H(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return j(()=>W(Ce(this.value),ur(e,t)))}getConfig(){return{value:this.value}}};JS.className="Constant";oe.registerClass(JS);var ZS=class extends xa{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return so(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};ZS.className="RandomUniform";oe.registerClass(ZS);var YS=class extends xa{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ge(`randomNormal does not support dType ${t}.`);return kv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};YS.className="RandomNormal";oe.registerClass(YS);var eI=class extends xa{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ge(`truncatedNormal does not support dType ${t}.`);return hv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};eI.className="TruncatedNormal";oe.registerClass(eI);var tI=class extends xa{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return j(()=>{if(e.length!==2||e[0]!==e[1])throw new H("Identity matrix initializer can only be used for 2D square matrices.");return W(this.gain,Xb(e[0]))})}getConfig(){return{gain:this.gain}}};tI.className="Identity";oe.registerClass(tI);function BY(e,t="channelsLast"){let n,r;if(Ht(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let a=_i(e,2);n=e[1]*a,r=e[0]*a}else if(t==="channelsLast"){let a=_i(e,0,e.length-2);n=e[e.length-2]*a,r=e[e.length-1]*a}}else{let a=_i(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}var fr=class extends xa{constructor(e){if(super(),e.scale<0)throw new H(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,LY(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,zY(this.distribution),this.seed=e.seed}apply(e,t){let n=BY(e),r=n[0],a=n[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,r):this.mode==="fanOut"?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),this.distribution==="normal"){let i=Math.sqrt(s);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ge(`${this.getClassName()} does not support dType ${t}.`);return hv(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return so(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};fr.className="VarianceScaling";oe.registerClass(fr);var Iv=class extends fr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return fr.className}};Iv.className="GlorotUniform";oe.registerClass(Iv);var Nv=class extends fr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return fr.className}};Nv.className="GlorotNormal";oe.registerClass(Nv);var Cv=class extends fr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return fr.className}};Cv.className="HeNormal";oe.registerClass(Cv);var Tv=class extends fr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return fr.className}};Tv.className="HeUniform";oe.registerClass(Tv);var Ev=class extends fr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return fr.className}};Ev.className="LeCunNormal";oe.registerClass(Ev);var _v=class extends fr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return fr.className}};_v.className="LeCunUniform";oe.registerClass(_v);var nI=class extends xa{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return j(()=>{if(e.length<2)throw new Ge("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=k.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=[Math.max(r,n),Math.min(r,n)],i=kv(s,0,1,t,this.seed),o=MS.qr(i,!1),l=o[0],d=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return l=W(l,d.sign()),n<r&&(l=l.transpose()),W(Ce(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};nI.className="Orthogonal";oe.registerClass(nI);var aE={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function sE(e,t={}){return dm(e,oe.SerializationMap.getMap().classNameMap,t,"initializer")}function Mt(e){return qS(e)}function _t(e){if(typeof e=="string"){let t=e in aE?aE[e]:e;if(t==="GlorotNormal")return new Nv;if(t==="GlorotUniform")return new Iv;if(t==="HeNormal")return new Cv;if(t==="HeUniform")return new Tv;if(t==="LeCunNormal")return new Ev;if(t==="LeCunUniform")return new _v;{let n={};return n.className=t,n.config={},sE(n)}}else return e instanceof xa?e:sE(e)}function $w(e){return Array.isArray(e)&&Array.isArray(e[0])}function Ey(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Re(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new H(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function rt(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new H(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function _y(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,a)=>r*a);return t}var iE="Variable",bM=class{constructor(e,t="float32",n=iE,r=!0,a=null){this.dtype=t??"float32",this.shape=e.shape,this.id=cM(),n=n??iE,this.originalName=hM(n),this.name=fM(this.originalName),this.trainable_=r,this.constraint=a,this.val=_S(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),WY(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function WY(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function Aw(e){return e.map(t=>t.read())}function rI(e){e.forEach(t=>{t[0].write(t[1])})}var Jt=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},La=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=cM(),s!=null&&(this.originalName=hM(s),this.name=fM(this.originalName)),this.rank=t.length}},UY=0,$v=class{constructor(e,t){this.callArgs=t,this.id=UY++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},VY=0,qe=class extends oe.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=VY++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Is(n)+"_"+wv(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),n=[a].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new ns(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new H(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return lr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return lr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ii(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ii(`Layer ${this.name} is not connected, no input to return.`);return lr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ii(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ii(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return lr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=lt(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=lt(this.inputSpec);if(t.length!==n.length)throw new H(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let a=t[r],s=n[r];if(s==null)continue;let i=a.rank;if(s.ndim!=null&&i!==s.ndim)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&a.dtype!==s.dtype)throw new H(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${a.dtype}.`);if(s.axes){let o=a.shape;for(let l in s.axes){let d=Number(l),u=s.axes[l],c=d>=0?o[d]:o[o.length+d];if(u!=null&&[u,null].indexOf(c)===-1)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${u} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let l=s.shape[o],d=a.shape[o];if(l!=null&&d!=null&&l!==d)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${a.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=lt(e),r=GY(e),a=qY(e);if(r===a)throw new H("Arguments to apply() must be all SymbolicTensors or all Tensors");return Wo(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of lt(e))s.push(i.shape);this.build(lr(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=lt(s),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=lr(o),this.activityRegularizer!=null)throw new Ge("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=jY(e),i=this.computeOutputShape(s),o,l=HY(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((d,u)=>new La(l,d,this,lt(e),t,this.name,u)):o=new La(l,i,this,lt(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new Ge("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ii(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new ii(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ns(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return _y(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Aw(e?this.trainableWeights:this.weights)}setWeights(e){j(()=>{let t=this.weights;if(t.length!==e.length)throw new H(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=Aw(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!k.arraysEqual(s.shape,o.shape))throw new H(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}rI(n)})}addWeight(e,t,n,r,a,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new H(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():_t("zeros"));let l=r.apply(t,n),d=new bM(l,n,e,s,i);return l.dispose(),a!=null&&this.addLoss(()=>a.apply(d.read())),s==null&&(s=!0),s?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=lt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=lt(t),s=lt(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s,i=null){let o=lt(e);t=lt(t),n=lt(n),r=lt(r),a=Ey(a),s=Ey(s);let l=[],d=[],u=[];for(let c of o)l.push(c.sourceLayer),d.push(c.nodeIndex),u.push(c.tensorIndex);new $v({outboundLayer:this,inboundLayers:l,nodeIndices:d,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let c=0;c<t.length;c++)t[c].sourceLayer=this,t[c].nodeIndex=this.inboundNodes.length-1,t[c].tensorIndex=c}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function jY(e){e=lt(e);let t=[];for(let n of e)t.push(n.shape);return lr(t)}function HY(e){return"float32"}function vM(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let a=[];for(let s=0;s<r.inboundLayers.length;s++){let i=r.inputTensors[s],o=r.inboundLayers[s],l=r.nodeIndices[s],d=vM(i,o,l);for(let u of d)a.indexOf(u)===-1&&a.push(u)}return a}}}function GY(e){let t=!0;for(let n of lt(e))if(!(n instanceof La)){t=!1;break}return t}function qY(e){let t=!0;for(let n of lt(e))if(n instanceof La){t=!1;break}return t}var wp=class extends qe{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:wv("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new H("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new H("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new H("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new La(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new $v({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new H(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};wp.className="InputLayer";oe.registerClass(wp);function xM(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new H("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new wp({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function KY(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return ue(t,e.dtype)}catch{throw new H(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var vd=class wM{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof wM)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=KY(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new H(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof La){if(this.id2Value[t.id]==null)throw new H(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new H(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof La){if(this.id2Value[t.id]==null)throw new H(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new H(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Fe(this.id2Mask)}},$y=new lM,Ay=new lM;function XY(e){$y!=null&&$y.setMaxEntries(e),Ay!=null&&Ay.setMaxEntries(e)}function sh(e,t,n,r){let a=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(f=>f.name),l=[],d=t.names();for(let f of o)d.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);let u=o.join(",")+"|"+t.names().sort().join(","),c=$y.get(u),p;if(c==null){let f=QY(i,t);c=f.sorted,p=f.recipientCounts,$y.put(u,c),Ay.put(u,p)}p={},a||Object.assign(p,Ay.get(u));let h=new vd(t);for(let f=0;f<c.length;++f){let m=c[f],g=m.sourceLayer;if(g instanceof wp)continue;let y=[],b=[],v=[],x=!1;for(let A of m.inputs){let R=h.getValue(A),F=h.getMask(A);y.push(R),b.push(F),F!=null&&(x=!0),a||(p[A.name]--,p[A.name]===0&&!t.hasKey(A)&&o.indexOf(A.name)===-1&&!R.isDisposed&&A.sourceLayer.stateful!==!0&&v.push(R))}x&&(n=n||{},n.mask=b[0]);let w=lt(g.apply(y,n)),I=null;g.supportsMasking&&(I=g.computeMask(y,b));let N=ZY(m),T=Array.isArray(N)?N:[N];for(let A=0;A<T.length;++A){h.hasKey(T[A])||h.add(T[A],w[A],Array.isArray(I)?I[0]:I);let R=o.indexOf(T[A].name);R!==-1&&(l[R]=w[A])}a||Fe(v)}return h.disposeMasks(),s?l:l[0]}function QY(e,t){k.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let a=oE(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:i,recipientMap:o}=oE(s,t);for(let l of i)a.has(l.name)||(n.push(l),a.add(l.name));for(let l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(d=>r[l].add(d))}}return{sorted:n,recipientCounts:JY(r)}}function JY(e){let t={};for(let n in e)t[n]=e[n].size;return t}function oE(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(let d of o.inputs)a[d.name]==null&&(a[d.name]=new Set),a[d.name].add(o.name),!n.has(d.name)&&s.push(d)}}return{sorted:r,recipientMap:a}}function ZY(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let a of e.sourceLayer.inboundNodes[r].outputTensors)if(a.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var YY=K();YY.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,XY);var kM={};De(kM,{maxNorm:()=>eee,minMaxNorm:()=>ree,nonNeg:()=>nee,unitNorm:()=>tee});function aI(e,t){return j(()=>wn(ke(W(e,e),t,!0)))}var fm=class extends oe.Serializable{getConfig(){return{}}},sI=class extends fm{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return j(()=>{let t=aI(e,this.axis),n=On(t,0,this.maxValue);return W(e,be(n,te(on(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};sI.className="MaxNorm";oe.registerClass(sI);var iI=class extends fm{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return j(()=>be(e,te(on(),aI(e,this.axis))))}getConfig(){return{axis:this.axis}}};iI.className="UnitNorm";oe.registerClass(iI);var oI=class extends fm{apply(e){return ut(e)}};oI.className="NonNeg";oe.registerClass(oI);var lI=class extends fm{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return j(()=>{let t=aI(e,this.axis),n=te(W(this.rate,On(t,this.minValue,this.maxValue)),W(1-this.rate,t));return W(e,be(n,te(on(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};lI.className="MinMaxNorm";oe.registerClass(lI);var lE={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function un(e){return qS(e)}function uE(e,t={}){return dm(e,oe.SerializationMap.getMap().classNameMap,t,"constraint")}function dn(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in lE?lE[e]:e,config:{}};return uE(t)}else return e instanceof fm?e:uE(e)}function eee(e){return new sI(e)}function tee(e){return new iI(e)}function nee(){return new oI}function ree(e){return new lI(e)}var SM={};De(SM,{constant:()=>iee,glorotNormal:()=>hee,glorotUniform:()=>pee,heNormal:()=>fee,heUniform:()=>mee,identity:()=>dee,leCunNormal:()=>gee,leCunUniform:()=>yee,ones:()=>see,orthogonal:()=>bee,randomNormal:()=>lee,randomUniform:()=>oee,truncatedNormal:()=>uee,varianceScaling:()=>cee,zeros:()=>aee});function aee(){return new QS}function see(){return new Sv}function iee(e){return new JS(e)}function oee(e){return new ZS(e)}function lee(e){return new YS(e)}function uee(e){return new eI(e)}function dee(e){return new tI(e)}function cee(e){return new fr(e)}function pee(e){return new Iv(e)}function hee(e){return new Nv(e)}function fee(e){return new Cv(e)}function mee(e){return new Tv(e)}function gee(e){return new Ev(e)}function yee(e){return new _v(e)}function bee(e){return new nI(e)}var IM={};De(IM,{Layer:()=>qe,RNN:()=>qs,RNNCell:()=>gm,activation:()=>Xte,add:()=>ane,alphaDropout:()=>Wne,average:()=>sne,averagePooling1d:()=>x2,averagePooling2d:()=>w2,averagePooling3d:()=>k2,avgPool1d:()=>fne,avgPool2d:()=>gne,avgPool3d:()=>bne,avgPooling1d:()=>mne,avgPooling2d:()=>yne,avgPooling3d:()=>vne,batchNormalization:()=>cne,bidirectional:()=>Fne,categoryEncoding:()=>Gne,centerCrop:()=>jne,concatenate:()=>ine,conv1d:()=>Bte,conv2d:()=>Wte,conv2dTranspose:()=>Ute,conv3d:()=>Vte,conv3dTranspose:()=>jte,convLstm2d:()=>_ne,convLstm2dCell:()=>$ne,cropping2D:()=>Gte,dense:()=>Qte,depthwiseConv2d:()=>Kte,dot:()=>dne,dropout:()=>Jte,elu:()=>Dte,embedding:()=>rne,flatten:()=>Yte,gaussianDropout:()=>Bne,gaussianNoise:()=>zne,globalAveragePooling1d:()=>xne,globalAveragePooling2d:()=>wne,globalMaxPool1d:()=>Mne,globalMaxPool2d:()=>One,globalMaxPooling1d:()=>CO,globalMaxPooling2d:()=>TO,gru:()=>Sne,gruCell:()=>Ine,input:()=>UM,inputLayer:()=>Fte,layerNormalization:()=>pne,leakyReLU:()=>Ote,lstm:()=>Nne,lstmCell:()=>Cne,masking:()=>Une,maxPool1d:()=>Pne,maxPool2d:()=>Lne,maxPooling1d:()=>EO,maxPooling2d:()=>_O,maxPooling3d:()=>kne,maximum:()=>one,minimum:()=>lne,multiply:()=>une,permute:()=>nne,prelu:()=>Pte,randomWidth:()=>qne,reLU:()=>Mte,repeatVector:()=>ene,rescaling:()=>Vne,reshape:()=>tne,resizing:()=>Hne,rnn:()=>Ane,separableConv2d:()=>Hte,simpleRNN:()=>Tne,simpleRNNCell:()=>Ene,softmax:()=>Lte,spatialDropout1d:()=>Zte,stackedRNNCells:()=>Rne,thresholdedReLU:()=>zte,timeDistributed:()=>Dne,upSampling2d:()=>qte,zeroPadding2d:()=>hne});async function ni(e){if(e==null)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if(typeof s!="number"){let i=s;t.push(i.data()),n.push(a),r.push(i)}}if(t.length>0){let a=await Promise.all(t);for(let s=0;s<a.length;++s)e[n[s]]=a[s][0];Fe(r)}}function NM(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var dE;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(dE||(dE={}));var vee=125,Jd=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},CM=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},xee=class extends Jd{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let a=t[r];if(typeof a=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+a*n;else{let s;r in this.totals?s=this.totals[r]:this.totals[r]=0;let i=j(()=>te(this.totals[r],W(a,n)));this.totals[r]=i,s!=null&&s.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:j(()=>{let r=W(be(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),sn(t[n])}))}},TM=class extends Jd{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let s=this.history[a];for(let i=0;i<s.length;++i)if(typeof s[i]!="number"){let o=s[i];e.push(o.data()),t.push(a),n.push(i)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},EM=class extends Jd{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||HS,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=vee),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");k.isNumber(this.yieldEvery)&&(this.maybeWait=vY(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await ni(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await ni(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await ni(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await ni(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await ni(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):k.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await ni(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await ni(e),await this.trainEnd(e))}};function _M(e,t){return e==null&&(e={}),e instanceof Jd?[e]:Array.isArray(e)&&e[0]instanceof Jd?e:lt(e).map(n=>new EM(n,t))}var uI=class Ka{constructor(){}static registerCallbackConstructor(t,n){k.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Ka.checkForDuplicate(n),Ka.constructors[t]==null&&(Ka.constructors[t]=[]),Ka.constructors[t].push(n)}static checkForDuplicate(t){for(let n in Ka.constructors)Ka.constructors[+n].forEach(r=>{if(r===t)throw new H("Duplicate callback constructor.")})}static clear(){Ka.constructors={}}static createCallbacks(t){let n=[];for(let r in Ka.constructors){let a=+r;t>=a&&n.push(...Ka.constructors[a])}return n.map(r=>new r)}};uI.constructors={};function $M(e,t,n,r,a,s,i,o,l){let d=new TM,u=[new xee,...uI.createCallbacks(t)];e!=null&&u.push(...e),u.push(d);let c=new CM(u);return c.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:c,history:d}}function Fa(e,t={},n=!1){return dm(e,oe.SerializationMap.getMap().classNameMap,t,"layer",n)}function Ry(e,t){return j(()=>{e.dtype!=="float32"&&(e=ue(e,"float32"));let n=ke(pm(e),t,!0),r=Dr(n.shape,on()),a=wn(ms(n,r));return be(e,a)})}function Vu(e,t){return j(()=>Ft(pm(me(t,e)),-1))}function Av(e,t){return j(()=>Ft(Xt(me(t,e)),-1))}function kp(e,t){return j(()=>{let n=me(e,t),r=On(Xt(e),on(),Number.MAX_VALUE),a=Xt(be(n,r));return W(100,Ft(a,-1))})}function wee(e,t){return j(()=>{let n=On(t,on(),Number.MAX_VALUE),r=Pr(te(1,n)),a=On(e,on(),Number.MAX_VALUE),s=Pr(te(1,a));return Ft(pm(me(r,s)),-1)})}function kee(e,t){return j(()=>{let n=ms(0,me(1,W(e,t)));return Ft(pm(n),-1)})}function See(e,t){return j(()=>{let n=ms(0,me(1,W(e,t)));return Ft(n,-1)})}function Iee(e,t){return j(()=>{let n=ke(W(e,t),-1),r=Zr(W(me(1,e),t),-1);return ms(0,te(1,me(r,n)))})}function Nee(e,t){return j(()=>{let n=Math.log(2),r=me(t,e),a=me(te(r,Bu(W(-2,r))),n);return Ft(a,-1)})}function tf(e,t,n=!1){return j(()=>{if(n)t=io(t);else{let r=ke(t,t.shape.length-1,!0);t=be(t,r)}return t=On(t,on(),1-on()),St(ke(W(ue(e,"float32"),Pr(t)),t.shape.length-1))})}function Fy(e,t,n=!1){return j(()=>{let r=ue(gp(AY(e)),"int32");t=On(t,on(),1-on());let a=t.shape,s=V(Hd(r,a[a.length-1]),a);return tf(s,t,n)})}function Cee(e,t){if(!k.arraysEqual(e.shape,t.shape))throw new H(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return j(()=>{let n=ut(t),r=St(Xt(t));return te(me(n,W(t,e)),em(Pn(r)))})}function Rv(e,t){return j(()=>{let n;return n=On(t,on(),1-on()),n=Pr(be(n,me(1,n))),Ft(Cee(e,n),-1)})}function Tee(e,t){return j(()=>{let n=On(e,on(),1),r=On(t,on(),1);return ke(W(e,Pr(be(n,r))),-1)})}function Eee(e,t){return j(()=>{let n=Pr(te(on(),t));return Ft(me(t,W(e,n)),-1)})}function dI(e,t){return j(()=>{let n=Ry(e,-1),r=Ry(t,-1),a=W(n,r);return St(ke(a,-1))})}var Dy={meanSquaredError:Vu,meanAbsoluteError:Av,meanAbsolutePercentageError:kp,meanSquaredLogarithmicError:wee,squaredHinge:kee,hinge:See,categoricalHinge:Iee,logcosh:Nee,categoricalCrossentropy:tf,sparseCategoricalCrossentropy:Fy,binaryCrossentropy:Rv,kullbackLeiblerDivergence:Tee,poisson:Eee,cosineProximity:dI};function jx(e){if(typeof e=="string"){if(e in Dy)return Dy[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new H(t)}else return e}function cI(e,t){return j(()=>{let n=W(.5,Lr(t)),r=zs(nr(t,n),e.dtype);return Ft(Or(e,r),-1)})}function pI(e,t){return j(()=>zs(Or(al(e,-1),al(t,-1)),"float32"))}function AM(e,t){return j(()=>ue(ke(ba(Or(e,1),Or(t,1))),"float32"))}function _ee(e,t){return j(()=>ue(ke(ba(Or(e,1),Or(t,0))),"float32"))}function $ee(e,t){return j(()=>ue(ke(ba(Or(e,0),Or(t,1))),"float32"))}function RM(e,t){return j(()=>{let n=AM(e,t),r=$ee(e,t),a=te(n,r);return ue(xn(nr(a,0),be(n,a),0),"float32")})}function Aee(e,t){return j(()=>{let n=AM(e,t),r=_ee(e,t),a=te(n,r);return ue(xn(nr(a,0),be(n,a),0),"float32")})}function FM(e,t){return Rv(e,t)}function DM(e,t){return e.rank===t.rank&&(e=oo(e,[e.rank-1])),t=al(t,-1),t.dtype!==e.dtype&&(t=ue(t,e.dtype)),ue(Or(e,t),"float32")}function Ree(e,t){return j(()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return Ce(1).sub(n.div(r))})}var Fee=Vu,Dee=Vu,Mee=Av,Oee=Av,Pee=kp,Lee=kp,hI=tf,zee=dI,MM=Fy,My={binaryAccuracy:cI,categoricalAccuracy:pI,precision:RM,categoricalCrossentropy:hI,sparseCategoricalCrossentropy:MM,mse:Fee,MSE:Dee,mae:Mee,MAE:Oee,mape:Pee,MAPE:Lee,cosine:zee};function Bee(e){if(typeof e=="string"&&e in My)return My[e];if(typeof e!="string"&&e!=null)return e;throw new H(`Unknown metric ${e}`)}function cg(e){if(Ya(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(Dy))if(Dy[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(My))if(My[n]===e){t=n;break}return t!==void 0?t:e.name}}function Wee(e){let t={Adagrad:()=>Io.adagrad(.01),Adadelta:()=>Io.adadelta(1,.95,on()),Adam:()=>Io.adam(.001,.9,.999,on()),Adamax:()=>Io.adamax(.002,.9,.999,on(),0),RMSProp:()=>Io.rmsprop(.001,.9,0,on()),SGD:()=>Io.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new H(`Unknown Optimizer ${e}`)}function cE(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!Rw(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Rw(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!Rw(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!Rw(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function Uee(e,t,n,r=console.log){let a=jee(e),s=["Layer (type)","Input Shape","Output shape","Param #"];a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(u=>Math.floor(t*u)));let i;if(!a){s.push("Receives inputs"),i=[];for(let u in e.nodesByDepth)i.push(...e.nodesByDepth[u])}r("_".repeat(t)),Oy(s,n,r),r("=".repeat(t));let o=e.layers;for(let u=0;u<o.length;++u)a?Hee(o[u],n,r):Gee(o[u],n,i,r),r((u===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=Vee(e),d=_y(e.nonTrainableWeights);r(`Total params: ${l+d}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${d}`),r("_".repeat(t))}function Vee(e){let t;return e.collectedTrainableWeights!=null?t=_y(e.collectedTrainableWeights):t=_y(e.trainableWeights),t}function jee(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||a.length===1&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let s=!1;for(let i of a.inboundNodes)if(r.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function Oy(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function Hee(e,t,n){let r,a;try{a=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,a,r,e.countParams().toString()];Oy(o,t,n)}function Gee(e,t,n,r){let a,s;try{s=e.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{s="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let i=[];for(let c of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(c)===-1))for(let p=0;p<c.inboundLayers.length;++p){let h=c.inboundLayers[p].name,f=c.nodeIndices[p],m=c.tensorIndices[p];i.push(`${h}[${f}][${m}]`)}let o=e.name,l=e.getClassName(),d=i.length===0?"":i[0],u=[`${o} (${l})`,s,a,e.countParams().toString(),d];Oy(u,t,r);for(let c=1;c<i.length;++c)Oy(["","","","",i[c]],t,r)}function OM(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function nf(e,t){if(e===null)return null;if(typeof e=="string")return Eo(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];OM(t,a,s)?n.push(s):n.push(nf(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r];if(r==="name"&&typeof a=="string")n[r]=a;else{let s=Eo(r);n[s]=nf(a,s)}}return n}}function Fw(e,t){if(e==null)return null;if(typeof e=="string")return Is(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];OM(t,a,s)?n.push(s):n.push(Fw(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r],s=Is(r);(r==="name"||r==="className")&&typeof a=="string"?n[s]=a:n[s]=Fw(a,r)}return n}}var fI="4.22.0",qee=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},Kee=class Xa extends qe{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=wv(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Ei(this.inputs).length!==this.inputs.length)throw new H(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Ei(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let v=b.sourceLayer,x=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(v),this.outputLayersNodeIndices.push(x),this.outputLayersTensorIndices.push(w)}for(let b of this.inputs){let v=b.sourceLayer,x=b.nodeIndex,w=b.tensorIndex;Ya(x===0,"input layer has >1 nodes"),Ya(w===0,"input layer has >1 tensors"),this.inputLayers.push(v),this.inputLayersNodeIndices.push(x),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let v=this.inputLayers[b];if(!(v instanceof wp))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${v.getClassName()}.`);this.inputNames.push(v.name),this.feedInputShapes.push(v.batchInputShape),this.feedInputNames.push(v.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let n={},r={},a={},s={},i={},o=[],l=(b,v,x,w,I,N)=>{(w==null||I==null||N==null)&&(w=b.sourceLayer,I=b.nodeIndex,N=b.tensorIndex);let T=w.inboundNodes[I];if(x.indexOf(T)!==-1)throw new ns(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(v.indexOf(T)!==-1)return;this.containerNodes.add(Xa.nodeKey(w,I)),w.id in i||(i[w.id]=Object.keys(i).length),x.indexOf(T)===-1&&x.push(T);let A=T.inboundLayers.length;for(let R=0;R<A;R++){let F=T.inputTensors[R],C=T.inboundLayers[R],M=T.nodeIndices[R],B=T.tensorIndices[R];l(F,v,x,C,M,B)}for(v.push(T);x.indexOf(T)>=0;)x.splice(x.indexOf(T),1);o.push(T)},d=[],u=[];for(let b of this.outputs)l(b,d,u);let c=o.slice().reverse();for(let b of c){r[b.id]=b,b.id in n||(n[b.id]=0);let v=n[b.id],x=a[b.outboundLayer.id]==null?0:a[b.outboundLayer.id];v=Math.max(v,x),a[b.outboundLayer.id]=v,s[b.outboundLayer.id]=b.outboundLayer,n[b.id]=v;for(let w=0;w<b.inboundLayers.length;w++){let I=b.inboundLayers[w],N=b.nodeIndices[w],T=I.inboundNodes[N],A=n[T.id]==null?0:n[T.id];n[T.id]=Math.max(v+1,A),r[T.id]=T}}let p={};for(let b in n){let v=n[b];v in p||(p[v]=[]),p[v].push(r[b])}let h={};for(let b in a){let v=a[b];v in h||(h[v]=[]),h[v].push(s[b])}let f=Object.keys(h).map(b=>parseInt(b,10)).sort(lg);this.layers=[];for(let b of f){let v=h[b];v.sort((x,w)=>{let I=i[x.id],N=i[w.id];return I<N?-1:I>N?1:0});for(let x of v)x instanceof Xa&&this.internalContainerRefs.push(x),this.layers.push(x)}this.layersByDepth=h,f=Object.keys(p).map(b=>parseInt(b,10)).sort(lg);let m=this.inputs.slice(),g=[];for(let b of f)for(let v of p[b]){let x=v.outboundLayer;if(x!=null){for(let w of v.inputTensors)if(m.indexOf(w)===-1)throw new ns(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${x.name}". The following previous layers were accessed without issue: ${g}`);for(let w of v.outputTensors)m.push(w);g.push(x.name)}}this.nodesByDepth=p;let y=this.layers.map(b=>b.name);for(let b of y){let v=y.filter(x=>x===b).length;if(v!==1)throw new ns(`The name "${b}" is used ${v} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new $v({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new H("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let r={},a=0,s=qee(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[l,d]of o.weights.entries()){let u=s?`${d.name.split("/").slice(0,-1).join("/")+"/"}${l}`:d.originalName;if(r[u]!=null)throw new H(`Duplicate weight name: ${u}`);r[u]=d,a++}let i=[];for(let o in t){let l=o;if(r[o]==null){let d=o.split("/");l=d.slice(0,-2).concat([d[d.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],t[o]]);else if(n)throw new H(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){let o=[];for(let l in r)o.push(l);if(o.length>0)throw new H(`${o.length} of ${a} weights are not set: ${o}`)}rI(i)}parseWeights(t){for(let n in Object.keys(t)){let r=n.split("/"),a=["vars","layer_checkpoint_dependencies"],s=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!a.includes(i)).join("/");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${fI}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let r=Fw(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return j(()=>{t=lt(t);let r=new vd;for(let a=0;a<this.inputs.length;++a)r.add(this.inputs[a],t[a]);return sh(this.outputs,r,n)})}computeMask(t,n){return j(()=>{t=lt(t);let r;return n==null?r=ul(null,t.length):r=lt(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let n=Ey(t);if(n.length!==this.inputLayers.length)throw new H(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],d=n[o],u=l.name+"_0_0";r[u]=d}let a=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(lg);if(a.length>1)for(let o of a){let l=this.nodesByDepth[o];for(let d of l){let u=d.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;let c=[];for(let m=0;m<d.inboundLayers.length;m++){let g=d.inboundLayers[m],y=d.nodeIndices[m],b=d.tensorIndices[m],v=`${g.name}_${y}_${b}`,x=r[v];c.push(x)}let p=u.computeOutputShape(lr(c)),h=Ey(p),f=u.inboundNodes.indexOf(d);for(let m=0;m<h.length;m++){let g=`${u.name}_${f}_${m}`;r[g]=h[m]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],d=this.outputLayersNodeIndices[o],u=this.outputLayersTensorIndices[o],c=`${l.name}_${d}_${u}`;i.push(c)}for(let o=0;o<i.length;o++){let l=i[o];Ya(l in r),s.push(r[l])}return lr(s)}runInternalGraph(t,n){n==null&&(n=ul(null,t.length));let r={};for(let l=0;l<this.inputs.length;++l){let d=this.inputs[l],u=t[l],c=n[l];r[d.id]=[u,c]}let a=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(lg);for(let l of a){let d=this.nodesByDepth[l];for(let u of d){let c=u.outboundLayer,p=u.inputTensors,h=u.outputTensors,f=new Array;for(let m of p)m.id in r&&f.push(r[m.id]);if(f.length===p.length){let m={},g,y,b,v;if(u.callArgs!=null&&(m=u.callArgs),f.length===1){let[x,w]=f[0];m.mask==null&&(m.mask=w),b=lt(c.call(x,m)),v=lt(c.computeMask(x,w)),g=[x],y=[w]}else g=f.map(x=>x[0]),y=f.map(x=>x[1]),m.mask==null&&(m.mask=y),b=lt(c.call(g,m)),v=lt(c.computeMask(g,y));if(c.activityRegularizer)throw new Ge("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let x=0;x<h.length;++x){let w=h[x],I=b[x],N=v[x];r[w.id]=[I,N]}}}}let s=[],i=[],o=[];for(let l of this.outputs){Ya(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[d,u]=r[l.id];o.push(d.shape),s.push(d),i.push(u)}return[s,i,o]}buildNodeConversionMap(t){let n={},r;for(let a of this.layers){r=a instanceof Xa?1:0;for(let s=0;s<a.inboundNodes.length;s++){let i=Xa.nodeKey(a,s);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new H("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let r of this.layers)if(r.name===t)return r;throw new H(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new H(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return j(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=Xa.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),d=[];for(let c=0;c<i.inboundNodes.length;c++){let p=i.inboundNodes[c],h=Xa.nodeKey(i,c),f={};if(this.containerNodes.has(h)){if(p.callArgs)try{JSON.stringify(p.callArgs),f=p.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${p.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(p.inboundLayers.length>0){let m=[];for(let g=0;g<p.inboundLayers.length;g++){let y=p.inboundLayers[g],b=p.nodeIndices[g],v=p.tensorIndices[g],x=Xa.nodeKey(y,b),w=n[x];w==null&&(w=0),m.push([y.name,w,v,f])}d.push(m)}}}let u={};u.name=i.name,u.className=o,u.config=l,u.inboundNodes=d,r.push(u)}t.layers=r;let a=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],d=Xa.nodeKey(o,l);if(!this.containerNodes.has(d))continue;let u=n[d];u==null&&(u=0);let c=this.inputLayersTensorIndices[i];a.push([o.name,u,c])}t.inputLayers=a;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],d=Xa.nodeKey(o,l);if(!this.containerNodes.has(d))continue;let u=n[d];u==null&&(u=0);let c=this.outputLayersTensorIndices[i];s.push([o.name,u,c])}return t.outputLayers=s,t}static fromConfig(t,n,r={},a=!1){let s={},i={};function o(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){let b=[],v;for(let x of y){let w=x[0],I=x[1],N=x[2];if(v=x[3]==null?{}:x[3],!(w in s)){o(g,y);return}let T=s[w];if(T.inboundNodes.length<=I){o(g,y);return}let A=T.inboundNodes[I];b.push(A.outputTensors[N])}b.length>0&&g.apply(lr(b),v)}function d(g){let y=g.name,b=Fa(g,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(a),s[y]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new H(`Corrupted configuration, expected array for nodeData: ${v}`);o(b,v)})}let u=n.name,c=n.layers;for(let g of c)d(g);for(;!bY(i);)for(let g of c){let y=s[g.name];if(y.name in i){let b=i[y.name];delete i[y.name];for(let v of b)l(y,v)}}let p=[],h=[],f=n.inputLayers;for(let g of f){let y=g[0],b=g[1],v=g[2];Ya(y in s);let x=s[y].inboundNodes[b].outputTensors;p.push(x[v])}let m=n.outputLayers;for(let g of m){let y=g[0],b=g[1],v=g[2];Ya(y in s);let x=s[y].inboundNodes[b].outputTensors;h.push(x[v])}return new t({inputs:p,outputs:h,name:u})}get stateful(){if(this._stateful)throw new H("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){j(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function Xee(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let a=[];return t.forEach(s=>{s in e?a.push(e[s]):a.push(null)}),a}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function PM(e,t){return Xee(e,t,"classWeight")}async function LM(e,t,n,r){if(n!=null){let a=j(()=>{if(e.shape.length===1)return is(e);if(e.shape.length===2){if(e.shape[1]>1)return al(e,1);if(e.shape[1]===1)return V(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await a.data());Fe(a);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),ot(i,"float32")}else return null}function Qee(e,t){return W(e,t)}var Jee=32;function zM(e,t){let n,r,a=t;n=a.xs,r=a.ys,k.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=pE("input",e.inputNames,n),i=pE("output",e.outputNames,r),o=s[0].shape[0];k.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),k.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)k.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)k.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function pE(e,t,n){if(n instanceof Pe)return[n];if(Array.isArray(n))return k.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let a of t){if(n[a]==null)throw new H(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}function Zee(e){if(e.length===3)throw new Ge("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function Yee(e,t,n){let r=n.batchesPerEpoch!=null;if(k.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),k.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),k.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),k.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),k.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a=n.validationData!=null,s,i;if(a)if(hE(n.validationData))k.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=Zee(n.validationData);s=g.xs,i=g.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),d;a?d=l.slice().concat(l.map(g=>"val_"+g)):d=l.slice();let u=_M(n.callbacks,n.yieldEvery),c=n.verbose==null?1:n.verbose,{callbackList:p,history:h}=$M(u,c,n.epochs,null,null,ete(t,n),null,a,d);p.setModel(e),e.history=h,await p.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let g={};await p.onEpochBegin(f);let y=0,b=0;for(r||(m=await t.iterator());!r||y<n.batchesPerEpoch;){let v=await m.next();if(r&&v.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(v.value!=null){let{xs:x,ys:w}=zM(e,v.value),I={};I.batch=b,I.size=x[0].shape[0],await p.onBatchBegin(b,I);let N=[];if(n.classWeight!=null){let R=PM(n.classWeight,e.outputNames);for(let F=0;F<R.length;++F)N.push(await LM(w[F],null,R[F]))}let T=x.concat(w).concat(N),A=o(T);Fe(T);for(let R=0;R<l.length;++R){let F=l[R],C=A[R];I[F]=C,sn(C)}await p.onBatchEnd(b,I),NM(I),b++,y++}if(r?y>=n.batchesPerEpoch:v.done){if(a){let x;hE(n.validationData)?x=lt(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):x=lt(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?Jee:n.validationBatchSize,verbose:0}));for(let w=0;w<e.metricsNames.length;++w)g[`val_${e.metricsNames[w]}`]=x[w]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(f,g),f++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function ete(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function hE(e){return typeof e.iterator=="function"}function tte(e){return typeof e.next=="function"}async function nte(e,t,n){n=n||{};let r=n.batches!=null,a=e.testFunction,s=[];if(n.verbose>0)throw new Ge("Verbose mode is not implemented yet.");k.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=tte(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let d=await i.next();if(s=j(()=>{if(d.value){let{xs:u,ys:c}=zM(e,d.value),p=u.concat(c),h=j(()=>a(p));if(Fe(p),l===0)for(let m=0;m<h.length;++m)s.push(Ce(0));let f=p[0].shape[0];for(let m=0;m<h.length;++m){let g=h[m],y=s[m];s[m]=j(()=>te(s[m],W(f,g))),l>0&&Fe(y)}Fe(h),o+=f,++l}return s}),d.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let d=0;d<s.length;++d){let u=s[d];s[d]=be(s[d],o),Fe(u)}return lr(s)}function Hx(e){k.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Xp(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>Uo(r,t,n-t)):Uo(e,t,n-t)}function Dw(e,t){return j(()=>e==null?null:Array.isArray(e)?e.map(n=>Dw(n,t)):gM(e,t.dtype==="int32"?t:ue(t,"int32")))}function Gx(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function BM(e){let t=[];e instanceof Pe&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(cm(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Sa(e,t){if(e==null)return;let n=[];if(t instanceof Pe)n.push(t.id);else if(Array.isArray(t))t.forEach(a=>n.push(a.id));else if(t!=null)for(let a in t){let s=t[a];n.push(s.id)}let r=[];if(e instanceof Pe)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(a=>{n.indexOf(a.id)===-1&&r.push(a)});else if(e!=null)for(let a in e){let s=e[a];n.indexOf(s.id)===-1&&r.push(s)}r.forEach(a=>{a.isDisposed||a.dispose()})}function rte(e){return e instanceof Pe}function Mw(e){return Array.isArray(e)}function fE(e){return!rte(e)&&!Mw(e)}function mE(e,t,n,r=!0,a=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(Mw(e)&&e.length>0)i=!0;else if(fE(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new H(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(fE(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new H(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(Mw(e)){if(e=e,e.length!==t.length)throw new H(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new H(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=BM(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new H(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let d=o.shape[l],u=n[i][l];if(u!=null&&u>=0&&d!==u)throw new H(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function ate(e,t,n){let r=Ei(e.map(s=>s.shape[0]));r.sort();let a=Ei(t.map(s=>s.shape[0]));if(a.sort(),r.length>1)throw new H(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(a.length>1)throw new H(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(r.length>0&&a.length>0&&!k.arraysEqual(r,a))throw new H(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}function ste(e,t,n){let r=[Vu,Rv,tf];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(i!=null){if(i===tf&&s.shape[s.shape.length-1]===1)throw new H(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=s.shape.slice(1),d=o.slice(1);for(let u=0;u<l.length;++u){let c=l[u],p=d[u];if(p!=null&&c!==p)throw new H(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function gE(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new H(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new H(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new H(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let d=o.shape[l],u=n[i][l];if(u!=null&&u!==d)throw new H(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function ite(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let a of t){let s=n.hasOwnProperty(a)?n[a]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}var ote="layers-model",Rs=class extends Kee{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new H("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Uee(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Wee(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Gs))throw new H("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new H(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(jx(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new H(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>jx(s))}else{let s=jx(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Wo("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let r=ite(e.metrics,this.outputNames),a=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};Wo("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=r[s];(o=>{let l="",d,u,c;for(let p of o){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){let f=this.internalOutputShapes[s];f[f.length-1]===1||this.lossFunctions[s]===Rv?["accuracy","acc"].indexOf(p)!==-1?u=cI:["crossentropy","ce"].indexOf(p)!==-1&&(u=FM):this.lossFunctions[s]===Fy?["accuracy","acc"].indexOf(p)!==-1?u=DM:["crossentropy","ce"].indexOf(p)!==-1&&(u=MM):["accuracy","acc"].indexOf(p)!==-1?u=pI:["crossentropy","ce"].indexOf(p)!==-1&&(u=hI);let m;["accuracy","acc"].indexOf(p)!==-1?m="acc":["crossentropy","ce"].indexOf(p)!==-1&&(m="ce"),c=u,d=l+m}else c=Bee(p),d=l+cg(p);let h;Wo(d,()=>{h=c}),a(s,d,h)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;Hx(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let s=a[0].concat(a[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,r,n.verbose,n.steps);return lr(o)}finally{Sa(a[0],e),Sa(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),nte(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(n!=null){if(a=null,t!=null)throw new H(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new H(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new H("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new vd;if(e instanceof Pe&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new H(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new H(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let i=sh(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=ul(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=a[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((a,s)=>{a==null&&r.push(e[s])}),new H(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return j(()=>{let r=this.checkNumSamples(e);if(n)throw new Ge("Verbose predictLoop() is not implemented yet.");let a=Gx(r,t),s=this.outputs.map(i=>[]);for(let i=0;i<a.length;++i)j(()=>{let o=a[i][0],l=a[i][1],d=Xp(e,o,l),u=[];if(Array.isArray(d))for(let p=0;p<d.length;++p)u.push({key:this.inputs[p],value:d[p]});else u.push({key:this.inputs[0],value:d});let c=new vd(u);return sh(this.outputs,c)}).forEach((o,l)=>s[l].push(o));return lr(s.map(i=>gt(i,0)))})}predict(e,t={}){let n=BM(e);gE(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return Hx(r),this.predictLoop(n,r)}finally{Sa(n,e)}}predictOnBatch(e){gE(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new ns("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===Fy?a.push(i.slice(0,i.length-1).concat([1])):a.push(i)}if(e=mE(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=mE(t,this.feedOutputNames,a,!1,"target"),ate(e,t),ste(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new H(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let d=PM(r,this.outputNames);l=[];for(let u=0;u<d.length;++u)l.push(await LM(o[u],null,d[u]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return j(()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new Ge("Verbose mode is not implemented yet.");if(a!=null)throw new Ge("steps mode in testLoop() is not implemented yet");{let o=Gx(s,n),l=ot(Oa(0,s));for(let d=0;d<o.length;++d){let u=o[d][0],c=o[d][1],p=Uo(l,u,c-u),h=Dw(t,p),f=e(h);if(d===0)for(let m=0;m<f.length;++m)i.push(Ce(0));for(let m=0;m<f.length;++m){let g=f[m];i[m]=te(i[m],W(c-u,g))}}for(let d=0;d<i.length;++d)i[d]=be(i[d],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(tE(e,r)>1){let s=tE(e.slice(0,n),r);a+=`_${s}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let l=[];for(let p=0;p<this.inputs.length;++p)l.push({key:this.inputs[p],value:n[p]});let d=new vd(l),u=sh(this.outputs,d,{training:!0}),c;for(let p=0;p<this.lossFunctions.length;++p){let h=this.lossFunctions[p],f=h(r[p],u[p]);a[p]!=null&&(f=Qee(f,a[p]));let m=Ft(f);t.push(m),p===0?c=f:c=te(c,f)}for(let p=0;p<this.metricsTensors.length;++p){let h;if(this.outputs.length>1&&p<this.outputs.length)h=t[p];else{let f=this.metricsTensors[p][0],m=this.metricsTensors[p][1];h=Ft(f(r[m],u[m]))}sn(h),s.push(h)}return c=Ft(c),this.calculateLosses().forEach(p=>{c=te(c,p)}),c},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>j(()=>{let t=[],n,r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:r[l]});let i=new vd(s),o=sh(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let d=this.lossFunctions[l],u=Ft(d(a[l],o[l]));l===0?n=u:n=te(n,u),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let d=this.metricsTensors[l][0],u=this.metricsTensors[l][1],c=Ft(d(a[u],o[u]));t.push(c)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,a,s,i,o,l,d,u,c;try{let p=n.batchSize==null?32:n.batchSize;Hx(p);let h=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,p);r=h[0],a=h[1],c=h[2];let f=!1,m;if(n.validationData!=null&&n.validationData.length>0){if(f=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Ge("validationData including sample weights is not supported yet."):new H(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let I=await this.standardizeUserData(o,l,null,null,!0,p);d=I[0],u=I[1],m=d.concat(u)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){f=!0;let I=Math.floor(r[0].shape[0]*(1-n.validationSplit)),N=r[0].shape[0];d=Xp(r,I,N),s=r,r=Xp(r,0,I),u=Xp(a,I,N),i=a,a=Xp(a,0,I),m=d.concat(u)}else n.validationSteps!=null&&(f=!0);let g=r.concat(a).concat(c);this.checkTrainableWeightsConsistency();let y=this.makeTrainFunction(),b=this.getDedupedMetricsNames(),v,x;f?(this.makeTestFunction(),v=this.testFunction,x=b.slice().concat(b.map(I=>"val_"+I))):(v=null,m=[],x=b.slice());let w=_M(n.callbacks,n.yieldEvery);return await this.fitLoop(y,g,b,p,n.epochs,n.verbose,w,v,m,n.shuffle,x,n.initialEpoch,null,null)}finally{this.isTraining=!1,Sa(r,e),Sa(a,t),Sa(s,e),Sa(i,t),Sa(d,o),Sa(u,l),c!=null&&Fe(c)}}async fitLoop(e,t,n,r,a,s,i,o,l,d,u,c,p,h){r==null&&(r=32),a==null&&(a=1),d==null&&(d=!0),c==null&&(c=0);let f=!1;if(o!=null&&l!=null&&(f=!0),h!=null&&(f=!0,p==null))throw new H("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m=this.checkNumSamples(t,r,p,"steps_per_epoch"),g;m!=null&&(g=Oa(0,m)),s==null&&(s=1);let{callbackList:y,history:b}=$M(i,s,a,c,m,p,r,f,u);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=c;v<a;++v){await y.onEpochBegin(v);let x={};if(p!=null)throw new Ge("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new Ge("batch shuffling is not implemneted yet");d&&k.shuffle(g);let w=ot(g),I=Gx(m,r);for(let N=0;N<I.length;++N){let T={};if(await y.onBatchBegin(N,T),j(()=>{let A=I[N][0],R=I[N][1],F=Uo(w,A,R-A);T.batch=N,T.size=R-A;let C=Dw(t,F),M=e(C);for(let B=0;B<n.length;++B){let U=n[B],G=M[B];T[U]=G,sn(G)}if(N===I.length-1&&f){let B=this.testLoop(o,l,r);for(let U=0;U<n.length;++U){let G=n[U],X=B[U];sn(X),x["val_"+G]=X}}}),await y.onBatchEnd(N,T),NM(T),this.stopTraining_)break}w.dispose()}if(await y.onEpochEnd(v,x),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Yee(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let l=await o.data();i.push(l[0])}return Fe(s),Sa(n[0],e),Sa(n[1],t),lr(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=gw().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-gw().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Is(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Is(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=Is(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Is(cg(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Is(cg(e)));{let e={};for(let t in this.metrics)e[t]=Is(cg(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=nf(e.optimizer_config),n=Fa(t),r;if(typeof e.loss=="string")r=Eo(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(s=>Eo(s));else if(e.loss!=null){r={};for(let s in e.loss)r[s]=Eo(e.loss[s])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(s=>Eo(s));else if(e.metrics!=null){a={};for(let s in e.metrics)a[s]=Eo(e.metrics[s])}this.compile({loss:r,metrics:a,optimizer:n})}async save(e,t){if(typeof e=="string"){let a=$n.getSaveHandlers(e);if(a.length===0)throw new H(`Cannot find any save handlers for URL '${e}'`);if(a.length>1)throw new H(`Found more than one (${a.length}) save handlers for URL '${e}'`);e=a[0]}if(e.save==null)throw new H("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await $n.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:ote,generatedBy:`TensorFlow.js tfjs-layers v${fI}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){r.trainingConfig=this.getTrainingConfig();let a="optimizer",{data:s,specs:i}=await $n.encodeWeights(await this.optimizer.getWeights(),a);n.specs.push(...i),n.data=$n.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(cE(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){cE(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Rs.className="Model";oe.registerClass(Rs);var WM=class extends Rs{};WM.className="Functional";oe.registerClass(WM);async function lte(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=nf(n),a=Fa(r,t);if(e.weightsManifest!=null){let s=await $n.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map(o=>o.originalName)),i={};for(let o of a.weights)i[o.originalName]=s[o.originalName];a.loadWeights(i),Fe(s)}return a}async function ute(e,t){if(t==null&&(t={}),typeof e=="string"){let n=$n.getLoadHandlers(e,t);if(n.length===0)n.push($n.browserHTTPRequest(e,t));else if(n.length>1)throw new H(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return dte(e,void 0,t)}async function dte(e,t,n){if(n==null&&(n={}),e.load==null)throw new H("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;a.model_config!=null&&(a=a.model_config);let s=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&s,o=Fa(nf(a),t,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new H("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:d,optimizerWeights:u}=cte(r.weightData,r.weightSpecs);o.loadWeights(d,s),o.optimizer!=null&&u.length>0&&await o.optimizer.setWeights(u),Fe(d),Fe(u.map(c=>c.tensor))}return o}function cte(e,t){let n=$n.decodeWeights(e,t),r={},a=[];return t.forEach(s=>{s.group==="optimizer"?a.push({name:s.name,tensor:n[s.name]}):r[s.name]=n[s.name]}),{modelWeights:r,optimizerWeights:a}}var Fv=class Ow extends Rs{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:wv("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new H(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof Ow||t instanceof Rs,r;if(n){if(r=t,r.outputs.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new H("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new H("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let a=xM({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(a)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new H(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=vM(this.outputs[0])}this.inboundNodes=[],new $v({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ul(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs[0].shape})}else{let a=t.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(rt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Rs({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new ns("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new ns("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new ns("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new ns("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},a=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new H("Legacy serialization format not supported yet.");s=n}else k.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof Ow))throw new Ge(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of s){let d=Fa(l,void 0,a);a&&d.setFastWeightInitDuringBuild(!0),o.add(d)}return o}set stopTraining(t){if(this.model==null)throw new H("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new H("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}};Fv.className="Sequential";oe.registerClass(Fv);function pte(e){return new Rs(e)}function hte(e){return new Fv(e)}function UM(e){return xM(e)}function fte(e,t){uI.registerCallbackConstructor(e,t)}var Ln=class extends oe.Serializable{getConfig(){return{}}},VM=class extends Ln{apply(e,t=1){return FY(e,t)}};VM.className="elu";oe.registerClass(VM);var jM=class extends Ln{apply(e){return av(e)}};jM.className="selu";oe.registerClass(jM);var HM=class extends Ln{apply(e){return ut(e)}};HM.className="relu";oe.registerClass(HM);var GM=class extends Ln{apply(e){return j(()=>Li(6,ut(e)))}};GM.className="relu6";oe.registerClass(GM);var qM=class extends Ln{apply(e){return e}};qM.className="linear";oe.registerClass(qM);var KM=class extends Ln{apply(e){return ma(e)}};KM.className="sigmoid";oe.registerClass(KM);var XM=class extends Ln{apply(e){return MY(e)}};XM.className="hardSigmoid";oe.registerClass(XM);var QM=class extends Ln{apply(e){return Bu(e)}};QM.className="softplus";oe.registerClass(QM);var JM=class extends Ln{apply(e){return DY(e)}};JM.className="softsign";oe.registerClass(JM);var ZM=class extends Ln{apply(e){return Pi(e)}};ZM.className="tanh";oe.registerClass(ZM);var mI=class extends Ln{apply(e,t=-1){return io(e,t)}};mI.className="softmax";oe.registerClass(mI);var YM=class extends Ln{apply(e,t=-1){return Jb(e,t)}};YM.className="logSoftmax";oe.registerClass(YM);var eO=class extends Ln{apply(e){return j(()=>j(()=>{let t=Math.sqrt(2),n=W(.5,te(1,Kb(be(e,t))));return W(e,n)}))}};eO.className="gelu";oe.registerClass(eO);var tO=class extends Ln{apply(e){return j(()=>W(.5,W(e,te(1,Pi(W(wn(be(2,Math.PI)),te(e,W(.044715,ds(e,3)))))))))}};tO.className="gelu_new";oe.registerClass(tO);var nO=class extends Ln{apply(e){return j(()=>W(e,Pi(Bu(e))))}};nO.className="mish";oe.registerClass(nO);var rO=class extends Ln{apply(e,t=1){return j(()=>W(ma(W(e,t)),e))}};rO.className="swish";oe.registerClass(rO);function Wi(e){return e.getClassName()}function qx(e,t={}){return dm(e,oe.SerializationMap.getMap().classNameMap,t,"activation")}function Ui(e){if(e==null){let t={};return t.className="linear",t.config={},qx(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},qx(t)}else return e instanceof Ln?e:qx(e)}function gI(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var aO=class extends oe.Serializable{},mm=class extends aO{constructor(e){super(),gI(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return j(()=>{let t=Dt([1]);return this.hasL1&&(t=te(t,ke(W(this.l1,Xt(e))))),this.hasL2&&(t=te(t,ke(W(this.l2,pm(e))))),V(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};mm.className="L1L2";oe.registerClass(mm);function mte(e){return gI(e),new mm({l1:e!=null?e.l1:null,l2:0})}function gte(e){return gI(e),new mm({l2:e!=null?e.l2:null,l1:0})}var yE={l1l2:"L1L2"};function vt(e){return qS(e)}function bE(e,t={}){return dm(e,oe.SerializationMap.getMap().classNameMap,t,"regularizer")}function $t(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in yE?yE[e]:e,config:{}};return bE(t)}else return e instanceof aO?e:bE(e)}var yI=class extends qe{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Re(e);let n=ut(e);return this.maxValue!=null&&(n=On(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};yI.className="ReLU";oe.registerClass(yI);var bI=class extends qe{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Re(e);return Yf(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};bI.className="LeakyReLU";oe.registerClass(bI);var vI=class extends qe{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=_t(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=$t(e.alphaRegularizer),this.alphaConstraint=dn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new H(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=rt(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Jt({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Re(e),sm(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Mt(this.alphaInitializer),alphaRegularizer:vt(this.alphaRegularizer),alphaConstraint:un(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};vI.className="PReLU";oe.registerClass(vI);var xI=class extends qe{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ge(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Re(e);return fp(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};xI.className="ELU";oe.registerClass(xI);var wI=class extends qe{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Re(e);return W(n,ue(nr(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};wI.className="ThresholdedReLU";oe.registerClass(wI);var kI=class extends qe{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new mI().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return j(()=>{let n=Re(e),r=t.mask;if(r!=null){let a=W(me(ur(n.shape),ue(r,n.dtype)),Ce(-1e9));n=te(n,a)}return this.axis instanceof Array?this.axis.length>1?Pn(me(n,tm(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};kI.className="Softmax";oe.registerClass(kI);function _d(e,t,n){if(typeof e=="number")return ul(e,t);if(e.length!==t)throw new H(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!_Y(a))throw new H(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function Da(e,t,n,r,a=1){if(e==null)return e;let s=t+(t-1)*(a-1),i;return n==="same"?i=e:i=e-s+1,Math.floor((i+r-1)/r)}function es(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+Bi([n-t,0]);else if(r==="same")e=e*t;else throw new H(`Unsupport padding mode: ${r}.`);return e}function SI(e,t){return j(()=>(Ht(t),t==="channelsFirst"?Ue(e,[0,2,3,1]):e))}function sO(e,t){return j(()=>(Ht(t),t==="channelsFirst"?Ue(e,[0,2,3,4,1]):e))}function yte(e,t,n,r=1,a="valid",s,i=1){return j(()=>{if(s==null&&(s=Pa()),Ht(s),e.shape.length!==3)throw new H(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new H(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new H(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s==="channelsFirst"&&(e=Ue(e,[0,2,1])),a==="causal")throw new Ge("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=jb(e,t,r,a==="same"?"same":"valid","NWC",i);return n!=null&&(o=Va(o,n)),o})}function vE(e,t,n,r=[1,1],a="valid",s,i,o=null){return j(()=>{if(s==null&&(s=Pa()),Ht(s),e.rank!==3&&e.rank!==4)throw new H(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new H(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=SI(e,s);if(a==="causal")throw new Ge("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Xd.conv2d({x:l,filter:t,strides:r,pad:a==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(l=Ue(l,[0,3,1,2])),l})}function bte(e,t,n,r=[1,1,1],a="valid",s,i){return j(()=>{if(s==null&&(s=Pa()),Ht(s),e.rank!==4&&e.rank!==5)throw new H(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new H(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=sO(e,s);if(a==="causal")throw new Ge("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Jk(o,t,r,a==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Va(o,n)),s==="channelsFirst"&&(o=Ue(o,[0,4,1,2,3])),o})}var iO=class oO extends qe{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",oO.verifyArgs(n),this.rank=t,vn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ge(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=_d(n.kernelSize,t,"kernelSize"),this.strides=_d(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,sa(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Ht(this.dataFormat),this.activation=Ui(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=_t(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=dn(n.biasConstraint),this.biasRegularizer=$t(n.biasRegularizer),this.activityRegularizer=$t(n.activityRegularizer),this.dilationRate=_d(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new H(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new H(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new H(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Ya("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!KS(t.kernelSize,"number",1,3))throw new H(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Wi(this.activation),useBias:this.useBias,biasInitializer:Mt(this.biasInitializer),biasRegularizer:vt(this.biasRegularizer),activityRegularizer:vt(this.activityRegularizer),biasConstraint:un(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},Dv=class lO extends iO{constructor(t,n){super(t,n),this.kernel=null,lO.verifyArgs(n),this.filters=n.filters,vn(this.filters,"filters"),this.kernelInitializer=_t(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=dn(n.kernelConstraint),this.kernelRegularizer=$t(n.kernelRegularizer)}build(t){t=rt(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new H(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],a=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return j(()=>{t=Re(t);let r,a=this.bias==null?null:this.bias.read(),s=dM(this.activation.getClassName());if(s!=null&&this.rank===2)r=vE(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=yte(t,this.kernel.read(),a,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=vE(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=bte(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ge("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=rt(t);let n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<r.length;++s){let i=Da(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);n.push(i)}let a=[t[0]];return this.dataFormat==="channelsLast"?(a=a.concat(n),a.push(this.filters)):(a.push(this.filters),a=a.concat(n)),a}getConfig(){let t={filters:this.filters,kernelInitializer:Mt(this.kernelInitializer),kernelRegularizer:vt(this.kernelRegularizer),kernelConstraint:un(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new H(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},Mv=class uO extends Dv{constructor(t){super(2,t),uO.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!KS(t.kernelSize,"number",1,2))throw new H(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};Mv.className="Conv2D";oe.registerClass(Mv);var Ov=class dO extends Dv{constructor(t){super(3,t),dO.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new H(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};Ov.className="Conv3D";oe.registerClass(Ov);var II=class extends Mv{constructor(e){if(super(e),this.inputSpec=[new Jt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=rt(e),e.length!==4)throw new H("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Jt({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return j(()=>{let n=Re(e);if(n.shape.length!==4)throw new H(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i;this.dataFormat==="channelsFirst"?(s=2,i=3):(s=1,i=2);let o=r[s],l=r[i],d=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],p=this.strides[1],h=es(o,c,d,this.padding),f=es(l,p,u,this.padding),m=[a,h,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Ue(n,[0,2,3,1]));let g=Hb(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Ue(g,[0,3,1,2])),this.bias!=null&&(g=Va(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=rt(e);let t=e.slice(),n,r,a;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3):(n=3,r=1,a=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=es(t[r],o,s,this.padding),t[a]=es(t[a],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};II.className="Conv2DTranspose";oe.registerClass(II);var NI=class extends Ov{constructor(e){if(super(e),this.inputSpec=[new Jt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=rt(e),e.length!==5)throw new H("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Jt({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return j(()=>{let n=Re(e);if(n.shape.length!==5)throw new H(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i,o;this.dataFormat==="channelsFirst"?(o=2,s=3,i=4):(o=1,s=2,i=3);let l=r[o],d=r[s],u=r[i],c=this.kernelSize[0],p=this.kernelSize[1],h=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],y=es(l,f,c,this.padding),b=es(d,m,p,this.padding),v=es(u,g,h,this.padding),x=[a,y,b,v,this.filters];this.dataFormat!=="channelsLast"&&(n=Ue(n,[0,2,3,4,1]));let w=Zk(n,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=Ue(w,[0,4,1,2,3])),this.bias!==null&&(w=Va(w,this.bias.read(),this.dataFormat)),this.activation!==null&&(w=this.activation.apply(w)),w})}computeOutputShape(e){e=rt(e);let t=e.slice(),n,r,a,s;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],d=this.strides[0],u=this.strides[1],c=this.strides[2];return t[n]=this.filters,t[r]=es(t[r],d,i,this.padding),t[a]=es(t[a],u,o,this.padding),t[s]=es(t[s],c,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};NI.className="Conv3DTranspose";oe.registerClass(NI);var cO=class extends Dv{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new H("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new H("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new H(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=_t(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=$t(t.depthwiseRegularizer),this.depthwiseConstraint=dn(t.depthwiseConstraint),this.pointwiseInitializer=_t(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=$t(t.pointwiseRegularizer),this.pointwiseConstraint=dn(t.pointwiseConstraint)}build(e){if(e=rt(e),e.length<this.rank+2)throw new H(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new H(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Jt({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return j(()=>{e=Re(e);let n;if(this.rank===1)throw new Ge("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ue(e,[0,2,3,1])),n=bp(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Va(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Ue(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Mt(this.depthwiseInitializer),e.pointwiseInitializer=Mt(this.pointwiseInitializer),e.depthwiseRegularizer=vt(this.depthwiseRegularizer),e.pointwiseRegularizer=vt(this.pointwiseRegularizer),e.depthwiseConstraint=un(this.depthwiseConstraint),e.pointwiseConstraint=un(this.pointwiseConstraint),e}};cO.className="SeparableConv";var CI=class extends cO{constructor(e){super(2,e)}};CI.className="SeparableConv2D";oe.registerClass(CI);var TI=class pO extends Dv{constructor(t){super(1,t),pO.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!KS(t.kernelSize,"number",1,1))throw new H(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};TI.className="Conv1D";oe.registerClass(TI);var EI=class extends qe{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return j(()=>{if(e=Re(e),this.dataFormat==="channelsLast"){let n=dg(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return dg(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=dg(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return dg(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};EI.className="Cropping2D";oe.registerClass(EI);var _I=class extends qe{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ht(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,CY(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return j(()=>{let n=Re(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Ue(n,[0,2,3,1]);let a=this.size[0]*r[2],s=this.size[1]*r[3],i=this.interpolation==="nearest"?qr.resizeNearestNeighbor(n,[a,s]):qr.resizeBilinear(n,[a,s]);return Ue(i,[0,3,1,2])}else{let a=this.size[0]*r[1],s=this.size[1]*r[2];return this.interpolation==="nearest"?qr.resizeNearestNeighbor(n,[a,s]):qr.resizeBilinear(n,[a,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};_I.className="UpSampling2D";oe.registerClass(_I);function vte(e,t,n=[1,1],r="valid",a,s){return j(()=>{a==null&&(a=Pa()),Ht(a);let i=SI(e,a);if(e.rank!==4)throw new H(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new H(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=zu(i,t,n,r==="same"?"same":"valid","NHWC",s),a==="channelsFirst"&&(i=Ue(i,[0,3,1,2])),i})}var $I=class extends iO{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=_t(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=dn(e.depthwiseConstraint),this.depthwiseRegularizer=$t(e.depthwiseRegularizer)}build(e){if(e=rt(e),e.length<4)throw new H(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new H(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return j(()=>{e=Re(e);let n=vte(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Va(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=rt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=Da(t,this.kernelSize[0],this.padding,this.strides[0]),s=Da(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Mt(this.depthwiseInitializer),e.depthwiseRegularizer=vt(this.depthwiseRegularizer),e.depthwiseConstraint=un(this.depthwiseRegularizer),e}};$I.className="DepthwiseConv2D";oe.registerClass($I);function hO(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new H("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(s){return s==null||Array.isArray(s)?s:[s]}return t=a(t),n=a(n),{inputs:e,initialState:t,constants:n}}function fO(e,t,n,r=!1,a,s,i=!1,o=!1){return j(()=>{let l=t.shape.length;if(l<3)throw new H(`Input should be at least 3D, but is ${l}D.`);let d=[1,0].concat(Oa(2,l));t=Ue(t,d),s!=null,i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),a!=null&&(a=ue(ue(a,"bool"),"float32"),a.rank===l-1&&(a=yn(a,-1)),a=Ue(a,d)),r&&(t=na(t,0),a!=null&&(a=na(a,0)));let u=[],c,p=n,h=t.shape[0],f=Ut(t),m;a!=null&&(m=Ut(a));for(let y=0;y<h;++y){let b=f[y],v=j(()=>e(b,p));if(a==null)c=v[0],p=v[1];else{let x=j(()=>{let w=m[y],I=me(Lr(w),w),N=te(W(v[0],w),W(p[0],I)),T=p.map((A,R)=>te(W(v[1][R],w),W(A,I)));return{output:N,newStates:T}});c=x.output,p=x.newStates}o&&u.push(c)}let g;return o&&(g=en(u,1)),[c,g,p]})}var qs=class mO extends qe{constructor(t){super(t);let n;if(t.cell==null)throw new H("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new zv({cells:t.cell}):n=t.cell,n.stateSize==null)throw new H("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Jt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Oa(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){$w(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0],a;if(this.returnSequences?a=[t[0],t[1],r]:a=[t[0],r],this.returnState){let s=[];for(let i of n)s.push([t[0],i]);return[a].concat(s)}else return a}computeMask(t,n){return j(()=>{Array.isArray(n)&&(n=n[0]);let r=this.returnSequences?n:null;if(this.returnState){let a=this.states.map(s=>null);return[r].concat(a)}else return r})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Ge("Constants support is not implemented in RNN yet.");$w(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Jt({shape:[n,null,...r]});let a=[t[0]].concat(t.slice(2));this.cell.build(a);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!k.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new H(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new Jt({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){j(()=>{if(!this.stateful)throw new ii("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>Dt([r,a])):this.states_=[Dt([r,this.cell.stateSize])];else if(t==null)Fe(this.states_),this.keptStates!=null&&(Fe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>Dt([r,a])):this.states_[0]=Dt([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Fe(this.states_);for(let a=0;a<this.states_.length;++a){let s=t[a],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[a]:this.cell.stateSize,o=[r,i];if(!k.arraysEqual(s.shape,o))throw new H(`State ${a} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[a]=s}}this.states_=this.states_.map(a=>sn(a.clone()))})}apply(t,n){let r=n==null?null:n.initialState,a=n==null?null:n.constants;n==null&&(n={});let s=hO(t,r,a,this.numConstants);t=s.inputs,r=s.initialState,a=s.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(let l of r)this.stateSpec.push(new Jt({shape:l.shape}));o=o.concat(this.stateSpec)}if(a!=null&&(n.constants=a,i=i.concat(a),this.numConstants=a.length),i[0]instanceof La){let l=[t].concat(i),d=this.inputSpec.concat(o),u=this.inputSpec;this.inputSpec=d;let c=super.apply(l,n);return this.inputSpec=u,c}else return super.apply(t,n)}call(t,n){return j(()=>{let r=n==null?null:n.mask,a=n==null?null:n.training,s=n==null?null:n.initialState;t=Re(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new H(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:a},l=fO((h,f)=>{let m=this.cell.call([h].concat(f),o);return[m[0],m.slice(1)]},t,s,this.goBackwards,r,null,this.unroll,this.returnSequences),d=l[0],u=l[1],c=l[2];this.stateful&&this.resetStates(c,a);let p=this.returnSequences?u:d;return this.returnState?[p].concat(c):p})}getInitialState(t){return j(()=>{let n=Dt(t.shape);return n=ke(n,[1,2]),n=cm(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?Ew(n,[1,r]):n):this.cell.stateSize>1?[Ew(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===mO.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){let a=n.cell,s=Fa(a,r);return new t(Object.assign(n,{cell:s}))}};qs.className="RNN";oe.registerClass(qs);var gm=class extends qe{},Pv=class extends gm{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vn(this.units,"units"),this.activation=Ui(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=_t(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=_t(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=_t(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=$t(e.kernelRegularizer),this.recurrentRegularizer=$t(e.recurrentRegularizer),this.biasRegularizer=$t(e.biasRegularizer),this.kernelConstraint=dn(e.kernelConstraint),this.recurrentConstraint=dn(e.recurrentConstraint),this.biasConstraint=dn(e.biasConstraint),this.dropout=Qd([1,Bi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Qd([1,Bi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=rt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return j(()=>{if(e=e,e.length!==2)throw new H(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vi({ones:()=>Lr(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vi({ones:()=>Lr(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?a=ls(W(e,s),this.kernel.read()):a=ls(e,this.kernel.read()),this.bias!=null&&(a=Va(a,this.bias.read())),i!=null&&(n=W(n,i));let o=te(a,ls(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Wi(this.activation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:vt(this.kernelRegularizer),recurrentRegularizer:vt(this.recurrentRegularizer),biasRegularizer:vt(this.biasRegularizer),activityRegularizer:vt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),recurrentConstraint:un(this.recurrentConstraint),biasConstraint:un(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};Pv.className="SimpleRNNCell";oe.registerClass(Pv);var AI=class extends qs{constructor(e){e.cell=new Pv(e),super(e)}call(e,t){return j(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return new e(t)}};AI.className="SimpleRNN";oe.registerClass(AI);var Lv=class extends gm{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new H("GRUCell does not support reset_after parameter set to true.");this.units=e.units,vn(this.units,"units"),this.activation=Ui(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ui(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=_t(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=_t(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=_t(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=$t(e.kernelRegularizer),this.recurrentRegularizer=$t(e.recurrentRegularizer),this.biasRegularizer=$t(e.biasRegularizer),this.kernelConstraint=dn(e.kernelConstraint),this.recurrentConstraint=dn(e.recurrentConstraint),this.biasConstraint=dn(e.biasConstraint),this.dropout=Qd([1,Bi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Qd([1,Bi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=rt(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return j(()=>{if(e=e,e.length!==2)throw new H(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vi({ones:()=>Lr(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vi({ones:()=>Lr(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,s=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=W(e,a[0]));let d=ls(e,this.kernel.read());this.useBias&&(d=Va(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=W(r,s[0]));let u=this.recurrentKernel.read(),[c,p]=cr(u,[2*this.units,this.units],u.rank-1),h=ls(r,c),[f,m,g]=cr(d,3,d.rank-1),[y,b]=cr(h,2,h.rank-1);i=this.recurrentActivation.apply(te(f,y)),o=this.recurrentActivation.apply(te(m,b));let v=ls(W(o,r),p);l=this.activation.apply(te(g,v));let x=te(W(i,r),W(te(1,St(i)),l));return[x,x]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Wi(this.activation),recurrentActivation:Wi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:vt(this.kernelRegularizer),recurrentRegularizer:vt(this.recurrentRegularizer),biasRegularizer:vt(this.biasRegularizer),activityRegularizer:vt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),recurrentConstraint:un(this.recurrentConstraint),biasConstraint:un(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};Lv.className="GRUCell";oe.registerClass(Lv);var RI=class extends qs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Lv(e),super(e)}call(e,t){return j(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};RI.className="GRU";oe.registerClass(RI);var ym=class extends gm{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vn(this.units,"units"),this.activation=Ui(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ui(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=_t(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=_t(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=_t(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=$t(e.kernelRegularizer),this.recurrentRegularizer=$t(e.recurrentRegularizer),this.biasRegularizer=$t(e.biasRegularizer),this.kernelConstraint=dn(e.kernelConstraint),this.recurrentConstraint=dn(e.recurrentConstraint),this.biasConstraint=dn(e.biasConstraint),this.dropout=Qd([1,Bi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Qd([1,Bi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=rt(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let a=this.biasInitializer,s=this.units;r=new(t=class extends xa{apply(i,o){let l=a.apply([s]),d=new Sv().apply([s]),u=a.apply([s*2]);return rE(rE(l,d),u)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return j(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new H(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vi({ones:()=>Lr(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vi({ones:()=>Lr(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,l,d,u;0<this.dropout&&this.dropout<1&&(e=W(e,s[0]));let c=ls(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=W(r,i[0])),c=te(c,ls(r,this.recurrentKernel.read())),this.useBias&&(c=Va(c,this.bias.read()));let[p,h,f,m]=cr(c,4,c.rank-1);o=this.recurrentActivation.apply(p),l=this.recurrentActivation.apply(h),d=te(W(l,a),W(o,this.activation.apply(f))),u=this.recurrentActivation.apply(m);let g=W(u,this.activation.apply(d));return[g,g,d]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Wi(this.activation),recurrentActivation:Wi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:vt(this.kernelRegularizer),recurrentRegularizer:vt(this.recurrentRegularizer),biasRegularizer:vt(this.biasRegularizer),activityRegularizer:vt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),recurrentConstraint:un(this.recurrentConstraint),biasConstraint:un(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};ym.className="LSTMCell";oe.registerClass(ym);var FI=class extends qs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ym(e),super(e)}call(e,t){return j(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};FI.className="LSTM";oe.registerClass(FI);var zv=class extends gm{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return j(()=>{e=e;let n=e.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),a.push(s.slice(1))}n=[];for(let i of a.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){$w(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{Wo(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let a of t.cells)r.push(Fa(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Aw(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],a[s]])}rI(t)}};zv.className="StackedRNNCells";oe.registerClass(zv);function Vi(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):yM(t(),n),o=()=>hm(i,t,r);return!a||a<=1?sn(o().clone()):Array(a).fill(void 0).map(o).map(l=>sn(l.clone()))}var xte=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]]);return n},gO=class extends qs{constructor(e){if(e.unroll)throw new Ge("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ge("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Jt({ndim:5})]}call(e,t){return j(()=>{if(this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new H("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return j(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],s=Dt(a);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){j(()=>{if(!this.stateful)throw new ii("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(n[0]==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Dt(a)):this.states_=[Dt(a)];else if(e==null)Fe(this.states_),this.keptStates!=null&&(Fe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Dt(a)):this.states_[0]=Dt(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Fe(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=a;if(!k.arraysEqual(i.shape,o))throw new H(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>sn(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],d=e[o?4:3],u=Da(l,r[0],a,s[0],i[0]),c=Da(d,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,u,c]:[u,c,n]]}};gO.className="ConvRNN2D";var Bv=class extends ym{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,vn(this.filters,"filters"),this.kernelSize=_d(n,2,"kernelSize"),this.kernelSize.forEach(o=>vn(o,"kernelSize")),this.strides=_d(r||1,2,"strides"),this.strides.forEach(o=>vn(o,"strides")),this.padding=a||"valid",sa(this.padding),this.dataFormat=s||"channelsLast",Ht(this.dataFormat),this.dilationRate=_d(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>vn(o,"dilationRate"))}build(e){var t;e=rt(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new H(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=4,s=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,d=this.filters;o=new(t=class extends xa{apply(u,c){let p=l.apply([d]),h=ur([d]),f=l.apply([d*2]);return XS([p,h,f])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return j(()=>{if(e.length!==3)throw new H(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vi({ones:()=>Lr(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(q,Q,J)=>!Q||!Q[J]?q:W(Q[J],q),d=l(r,o,0),u=l(r,o,1),c=l(r,o,2),p=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vi({ones:()=>Lr(a),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,f=l(a,h,0),m=l(a,h,1),g=l(a,h,2),y=l(a,h,3),b=3,[v,x,w,I]=cr(this.kernel.read(),i,b),[N,T,A,R]=this.useBias?cr(this.bias.read(),i):[null,null,null,null];d=this.inputConv(d,v,N,this.padding),u=this.inputConv(u,x,T,this.padding),c=this.inputConv(c,w,A,this.padding),p=this.inputConv(p,I,R,this.padding);let[F,C,M,B]=cr(this.recurrentKernel.read(),i,b);f=this.recurrentConv(f,F),m=this.recurrentConv(m,C),g=this.recurrentConv(g,M),y=this.recurrentConv(y,B);let U=this.recurrentActivation.apply(te(d,f)),G=this.recurrentActivation.apply(te(u,m)),X=te(W(G,s),W(U,this.activation.apply(te(c,g)))),P=W(this.recurrentActivation.apply(te(p,y)),this.activation.apply(X));return[P,P,X]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=xte(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=Jn(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Va(a,n,this.dataFormat):a}recurrentConv(e,t){return Jn(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Bv.className="ConvLSTM2DCell";oe.registerClass(Bv);var DI=class extends gO{constructor(e){let t=new Bv(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};DI.className="ConvLSTM2D";oe.registerClass(DI);var Wv=class extends qe{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Re(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,a=this.getNoiseShape(n);return hm(()=>yM(n,this.rate,a,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Wv.className="Dropout";oe.registerClass(Wv);var MI=class extends Wv{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};MI.className="SpatialDropout1D";oe.registerClass(MI);var OI=class extends qe{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,vn(this.units,"units"),this.activation=Ui(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=_t(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=_t(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=dn(e.kernelConstraint),this.biasConstraint=dn(e.biasConstraint),this.kernelRegularizer=$t(e.kernelRegularizer),this.biasRegularizer=$t(e.biasRegularizer),this.activityRegularizer=$t(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=rt(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=rt(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Re(e),r=dM(this.activation.getClassName()),a;return r!=null?a=ls(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=ls(n,this.kernel.read()),this.bias!=null&&(a=Va(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){let e={units:this.units,activation:Wi(this.activation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:vt(this.kernelRegularizer),biasRegularizer:vt(this.biasRegularizer),activityRegularizer:vt(this.activityRegularizer),kernelConstraint:un(this.kernelConstraint),biasConstraint:un(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};OI.className="Dense";oe.registerClass(OI);var PI=class extends qe{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=rt(e);for(let t of e.slice(1))if(t==null)throw new H(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],_i(e,1)]}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Re(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let a=2;a<n.rank;++a)r.push(a);r.push(1),n=Ue(n,r)}return RY(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};PI.className="Flatten";oe.registerClass(PI);var LI=class extends qe{constructor(e){super(e),this.supportsMasking=!0,this.activation=Ui(e.activation)}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Re(e);return this.activation.apply(n)})}getConfig(){let e={activation:Wi(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};LI.className="Activation";oe.registerClass(LI);var zI=class extends qe{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return j(()=>(e=Re(e),$Y(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};zI.className="RepeatVector";oe.registerClass(zI);var BI=class extends qe{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let l=r[o];if(this.isUnknown(l))if(s===null)s=o;else throw new H("Can only specifiy one unknown dimension.");else a*=l}let i=_i(e);if(s!==null){if(a===0||i%a!==0)throw new H(n);r[s]=i/a}else if(i!==a)throw new H(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Re(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return V(n,a)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};BI.className="Reshape";oe.registerClass(BI);var WI=class extends qe{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Oa(1,e.dims.length+1);if(!k.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Jt({ndim:this.dims.length+1})]}computeOutputShape(e){e=rt(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Ue(Re(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};WI.className="Permute";oe.registerClass(WI);var UI=class extends qe{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Re(e);return Jh(ol(n,this.maskValue),-1)}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Re(e),r=Jh(ol(n,this.maskValue),-1,!0);return W(n,ue(r,n.dtype))})}};UI.className="Masking";oe.registerClass(UI);var VI=class extends qe{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(lt(e.inputLength))}this.inputDim=e.inputDim,vn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,vn(this.outputDim,"outputDim"),this.embeddingsInitializer=_t(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=$t(e.embeddingsRegularizer),this.activityRegularizer=$t(e.activityRegularizer),this.embeddingsConstraint=dn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return j(()=>this.maskZero?(e=Re(e),ol(e,Ze(e))):null)}computeOutputShape(e){if(e=rt(e),this.inputLength==null)return[...e,this.outputDim];let t=lt(this.inputLength);if(t.length!==e.length-1)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(a!=null&&s!=null&&a!==s)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Re(e);n.dtype!=="int32"&&(n=zs(n,"int32"));let r=gM(this.embeddings.read(),V(n,[n.size]));return V(r,rt(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Mt(this.embeddingsInitializer),embeddingsRegularizer:vt(this.embeddingsRegularizer),activityRegularizer:vt(this.activityRegularizer),embeddingsConstraint:un(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};VI.className="Embedding";oe.registerClass(VI);var ju=class extends qe{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ge}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(a==null||s==null||a<0||s<0)n.push(null);else if(a===1)n.push(s);else if(s===1)n.push(a);else{if(a!==s)throw new H("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[rt(e)]),e=e,e.length<2)throw new H(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)a!=null&&a[0]!==null&&t.push(a[0]);if(t=Ei(t),t.length>1)throw new H(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){let s=e[a]==null?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let r=e.map(a=>a.length);e.indexOf(null)===-1&&Ei(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return j(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(a=>a.rank);if(r.indexOf(null)===-1){let a=Bi(r);for(let s of e){let i=s.rank;for(let o=0;o<a-i;++o)s=cm(s,1);n.push(s)}return this.mergeFunction(n)}else{let a=!1;for(let o of e){let l=o.rank;if(l==null){let d=o.shape,u=d[0],c=d.slice(1).concat([u]),p=V(o,[u].concat(_i(d.slice(1))));p=Ue(p,[1,0]),p=V(p,c),n.push(p),a=!0}else if(l>1){let d=Oa(1,l).concat([0]);n.push(Ue(o,d)),a=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(a){if(i==null){let o=s.shape,l=o.length,d=o[l-1],u=[d].concat(o.slice(0,o.length-1));s=V(Ue(V(s,[-1,d]),[1,0]),u)}else if(i>1){let o=[i-1].concat(Oa(0,i-1));s=Ue(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let a=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=Ei(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return j(()=>{if(t==null)return null;if(!Array.isArray(t))throw new H("`mask` should be an Array");if(!Array.isArray(e))throw new H("`inputs` should be an Array");if(t.length!==e.length)throw new H(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:yn(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=ba(n,t[r]);return n})}},jI=class extends ju{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=te(t,e[n]);return t})}};jI.className="Add";oe.registerClass(jI);var HI=class extends ju{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=W(t,e[n]);return t})}};HI.className="Multiply";oe.registerClass(HI);var GI=class extends ju{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=te(t,e[n]);return W(1/e.length,t)})}};GI.className="Average";oe.registerClass(GI);var qI=class extends ju{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ms(t,e[n]);return t})}};qI.className="Maximum";oe.registerClass(qI);var KI=class extends ju{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Li(t,e[n]);return t})}};KI.className="Minimum";oe.registerClass(KI);var XI=class extends ju{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new H("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let a=e[r].slice();a.splice(this.axis,1);let s=!1;for(let i of n)if(k.arraysEqual(i,a)){s=!0;break}s||n.push(a)}if(n.length>1)throw new H("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return j(()=>XS(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new H("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(n[r]==null||a[r]==null){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new H("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new H("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new H(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return j(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let r=[];for(let s=0;s<e.length;++s)t[s]==null?r.push(ue(Lr(e[s]),"bool")):t[s].rank<e[s].rank?r.push(yn(t[s],-1)):r.push(t[s]);let a=gt(r,this.axis);return Vb(a,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};XI.className="Concatenate";oe.registerClass(XI);function Qp(e,t){for(;e<0;)e+=t;return e}function wte(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Ge("batchDot is not implemented for tensors of 4D or higher rank yet");if(k.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),k.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Ge("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;n==null&&(n=[r-1,a-2]);let s=n;return j(()=>{let i;if(r>a){i=r-a;let l=[];for(let d=0;d<i;++d)l.push(1);t=V(t,t.shape.concat(l))}else if(a>r){i=a-r;let l=[];for(let d=0;d<i;++d)l.push(1);e=V(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=ke(W(e,t),s[0]):o=ke(W(Ue(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,d=s[1]===t.shape.length-1;o=We(e,t,l,d)}if(i>0){let l;r>a?l=r+a-3:l=r-1;let d=[];for(let u=l;u<l+i;++u)d.push(u);o=oo(o,d)}return o.shape.length===1&&(o=yn(o,1)),o})}var QI=class extends ju{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){k.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Ge("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new H(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new H(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((a,s)=>Qp(a,e[s].shape.length)):r=[Qp(this.axes,t.shape.length),Qp(this.axes,n.shape.length)],this.normalize&&(t=Ry(t,r[0]),n=Ry(n,r[1])),wte(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Qp(this.axes,e.length),Qp(this.axes,t.length)],n}computeOutputShape(e){k.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Ge("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return a.length===1&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};QI.className="Dot";oe.registerClass(QI);var JI=class extends qe{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Re(e);return hm(()=>te(kv(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};JI.className="GaussianNoise";oe.registerClass(JI);var ZI=class extends qe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return j(()=>{this.invokeCallHook(e,t);let n=Re(e);return this.rate>0&&this.rate<1?hm(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return W(n,kv(n.shape,1,r))},()=>n,t.training||!1):n})}};ZI.className="GaussianDropout";oe.registerClass(ZI);var YI=class extends qe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Re(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return j(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return hm(()=>{let r=Re(e),a=-1.6732632423543772*1.0507009873554805,s=js(so(n),this.rate);s=zs(s,"float32");let i=((1-this.rate)*(1+this.rate*a**2))**-.5,o=-i*a*this.rate,l=te(W(r,s),W(te(s,-1),a));return te(W(l,i),o)},()=>Re(e),t.training||!1)}return e})}};YI.className="AlphaDropout";oe.registerClass(YI);function rf(e,t,n,r,a,s=.001){let i;if(e.rank===2)i=Wk(e,t,n,r,a,s);else if(e.rank===3)i=Uk(e,t,n,r,a,s);else if(e.rank===4)i=Vk(e,t,n,r,a,s);else throw new Ge(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function kte(e,t,n,r,a=.001){return j(()=>{let s=rm(e,r),i=s.mean,o=s.variance;return[rf(e,i,o,n,t,a),i,o]})}function Ste(e,t,n,r,a=.001){return j(()=>{let s=rm(e,r),i=s.mean,o=s.variance,l=[];for(let h of Oa(0,e.rank))r.indexOf(h)!==-1?l.push(1):l.push(e.shape[h]);let d=V(i,l),u=V(o,l),c=t==null?null:V(t,l),p=n==null?null:V(n,l);return[rf(e,d,u,p,c,a),i,o]})}function Ite(e,t,n,r,a=.001){return k.arraysEqual(r.slice().sort(),Oa(0,e.rank-1))?kte(e,t,n,r,a):Ste(e,t,n,r,a)}var e2=class extends qe{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=_t(e.betaInitializer||"zeros"),this.gammaInitializer=_t(e.gammaInitializer||"ones"),this.movingMeanInitializer=_t(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=_t(e.movingVarianceInitializer||"ones"),this.betaConstraint=dn(e.betaConstraint),this.gammaConstraint=dn(e.gammaConstraint),this.betaRegularizer=$t(e.betaRegularizer),this.gammaRegularizer=$t(e.gammaRegularizer)}build(e){e=rt(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new H(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Jt({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return j(()=>{let n=t.training==null?!1:t.training,r=Re(e),a=r.shape,s=a.length,i=Oa(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=ul(1,s);l[o]=a[o];let d=i.slice();d.sort();let u=!k.arraysEqual(d,Oa(0,s).slice(0,s-1)),c=()=>{if(u){let g=V(this.movingMean.read(),l),y=V(this.movingVariance.read(),l),b=this.center?V(this.beta.read(),l):null,v=this.scale?V(this.gamma.read(),l):null;return rf(r,g,y,b,v,this.epsilon)}else return rf(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return c();let[p,h,f]=Ite(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(g,y,b)=>{j(()=>{let v=1-b,x=g.read(),w=W(me(x,y),v);g.write(me(x,w))})};return m(this.movingMean,h,this.momentum),m(this.movingVariance,f,this.momentum),p})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mt(this.betaInitializer),gammaInitializer:Mt(this.gammaInitializer),movingMeanInitializer:Mt(this.movingMeanInitializer),movingVarianceInitializer:Mt(this.movingVarianceInitializer),betaRegularizer:vt(this.betaRegularizer),gammaRegularizer:vt(this.gammaRegularizer),betaConstraint:un(this.betaConstraint),gammaConstraint:un(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};e2.className="BatchNormalization";oe.registerClass(e2);var t2=class extends qe{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=_t(e.betaInitializer||"zeros"),this.gammaInitializer=_t(e.gammaInitializer||"ones"),this.betaRegularizer=$t(e.betaRegularizer),this.gammaRegularizer=$t(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=rt(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==Ei(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(a=>e[a]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Re(e),r=n.shape,a=r.length;return j(()=>{let{mean:s,variance:i}=rm(n,this.axis,!0),o=ul(1,a);for(let h of this.axis)o[h]=r[h];let l=h=>h!=null&&h.shape.length!==a?V(h,o):h,d=this.scale?l(this.gamma.read()):null,u=this.center?l(this.beta.read()):null,c=[],p=[];for(let h=0;h<a;++h)this.axis.indexOf(h)!==-1?(c.push(r[h]),p.push(1)):(c.push(1),p.push(r[h]));return s=Er(s,c),i=Er(i,c),d!=null&&(d=Er(d,p)),u!=null&&(u=Er(u,p)),rf(n,s,i,u,d,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mt(this.betaInitializer),gammaInitializer:Mt(this.gammaInitializer),betaRegularizer:vt(this.betaRegularizer),gammaRegularizer:vt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};t2.className="LayerNormalization";oe.registerClass(t2);function Nte(e,t,n){return j(()=>{if(e.rank!==4)throw new H(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new H("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Pa()),n!=="channelsLast"&&n!=="channelsFirst")throw new H(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],Ua(e,r)})}var n2=class extends qe{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Pa():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new H(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new H(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new H(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Jt({ndim:4})]}computeOutputShape(e){e=rt(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return j(()=>Nte(Re(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};n2.className="ZeroPadding2D";oe.registerClass(n2);function Uv(e,t,n,r,a,s){return j(()=>{Ht(a),pM(s),sa(r),n==null&&(n=[1,1]),r==null&&(r="valid"),a==null&&(a=Pa()),s==null&&(s="max"),e=SI(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=hn(e,t,n,o):i=Vs(e,t,n,o),a==="channelsFirst"&&(i=Ue(i,[0,3,1,2])),i})}function yO(e,t,n,r,a,s){return j(()=>{Ht(a),pM(s),sa(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),a==null&&(a=Pa()),s==null&&(s="max"),e=sO(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=hS(e,t,n,o):i=Bk(e,t,n,o),a==="channelsFirst"&&(i=Ue(i,[0,4,1,2,3])),i})}var bO=class extends qe{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new H(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(vn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new H(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);vn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,sa(this.padding),this.inputSpec=[new Jt({ndim:3})]}computeOutputShape(e){e=rt(e);let t=Da(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return j(()=>{this.invokeCallHook(e,t),e=cm(Re(e),2);let n=this.poolingFunction(Re(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return oo(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},r2=class extends bO{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ht(a),sa(r),Uv(e,t,n,r,a,"max")}};r2.className="MaxPooling1D";oe.registerClass(r2);var a2=class extends bO{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ht(a),sa(r),Uv(e,t,n,r,a,"avg")}};a2.className="AveragePooling1D";oe.registerClass(a2);var vO=class extends qe{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new H(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];vn(this.poolSize,"poolSize"),vn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ht(this.dataFormat),sa(this.padding),this.inputSpec=[new Jt({ndim:4})]}computeOutputShape(e){e=rt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Da(t,this.poolSize[0],this.padding,this.strides[0]),n=Da(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return j(()=>(this.invokeCallHook(e,t),this.poolingFunction(Re(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},s2=class extends vO{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ht(a),sa(r),Uv(e,t,n,r,a,"max")}};s2.className="MaxPooling2D";oe.registerClass(s2);var i2=class extends vO{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ht(a),sa(r),Uv(e,t,n,r,a,"avg")}};i2.className="AveragePooling2D";oe.registerClass(i2);var xO=class extends qe{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new H(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];vn(this.poolSize,"poolSize"),vn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ht(this.dataFormat),sa(this.padding),this.inputSpec=[new Jt({ndim:5})]}computeOutputShape(e){e=rt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Da(t,this.poolSize[0],this.padding,this.strides[0]),n=Da(n,this.poolSize[1],this.padding,this.strides[1]),r=Da(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return j(()=>(this.invokeCallHook(e,t),this.poolingFunction(Re(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},o2=class extends xO{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ht(a),sa(r),yO(e,t,n,r,a,"max")}};o2.className="MaxPooling3D";oe.registerClass(o2);var l2=class extends xO{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Ht(a),sa(r),yO(e,t,n,r,a,"avg")}};l2.className="AveragePooling3D";oe.registerClass(l2);var wO=class extends qe{constructor(e){super(e),this.inputSpec=[new Jt({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ge}},u2=class extends wO{constructor(e){super(e||{})}call(e,t){return j(()=>{let n=Re(e);return Ft(n,1)})}};u2.className="GlobalAveragePooling1D";oe.registerClass(u2);var d2=class extends wO{constructor(e){super(e||{})}call(e,t){return j(()=>{let n=Re(e);return Zr(n,1)})}};d2.className="GlobalMaxPooling1D";oe.registerClass(d2);var kO=class extends qe{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Ht(this.dataFormat),this.inputSpec=[new Jt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ge}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},c2=class extends kO{call(e,t){return j(()=>{let n=Re(e);return this.dataFormat==="channelsLast"?Ft(n,[1,2]):Ft(n,[2,3])})}};c2.className="GlobalAveragePooling2D";oe.registerClass(c2);var p2=class extends kO{call(e,t){return j(()=>{let n=Re(e);return this.dataFormat==="channelsLast"?Zr(n,[1,2]):Zr(n,[2,3])})}};p2.className="GlobalMaxPooling2D";oe.registerClass(p2);var SO=class extends qe{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,a=Fa(r,n);delete t.layer;let s={layer:a};return Object.assign(s,t),new e(s)}},h2=class extends SO{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=rt(e),e.length<3)throw new H(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=rt(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return j(()=>(e=Re(e),fO((n,r)=>[Re(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};h2.className="TimeDistributed";oe.registerClass(h2);function Cte(e){Uu(NY,"BidirectionalMergeMode",e)}var Tte="concat",f2=class extends SO{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Fa(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Fa(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Tte:e.mergeMode,Cte(this.mergeMode),e.weights)throw new Ge("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,a;return this.returnState&&(a=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(a).concat(a.slice()):[n].concat(a).concat(a.slice()):lr(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let a=hO(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new H("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let d=n.map(u=>new Jt({shape:u.shape}));this.forwardLayer.stateSpec=d.slice(0,l/2),this.backwardLayer.stateSpec=d.slice(l/2),i.push(...d)}if(r!=null)throw new Ge("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof La;for(let l of s)if(l instanceof La!==o)throw new H("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(s),d=this.inputSpec.concat(i),u=this.inputSpec;this.inputSpec=d;let c=super.apply(l,t);return this.inputSpec=u,c}else return super.apply(e,t)}call(e,t){return j(()=>{let n=t.initialState,r,a;if(n==null)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let s;this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=na(a,1));let i;return this.mergeMode==="concat"?i=XS([r,a]):this.mergeMode==="sum"?i=te(r,a):this.mergeMode==="ave"?i=W(.5,te(r,a)):this.mergeMode==="mul"?i=W(r,a):this.mergeMode==null&&(i=[r,a]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Wo(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Wo(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Fa(t.layer);if(delete t.layer,t.numConstants!=null)throw new Ge("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};f2.className="Bidirectional";oe.registerClass(f2);var m2=class extends qe{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return j(()=>(e=Re(e),e.dtype!=="float32"&&(e=zs(e,"float32")),te(W(e,this.scale),this.offset)))}};m2.className="Rescaling";oe.registerClass(m2);var{resizeBilinear:Ete,cropAndResize:_te}=qr,g2=class extends qe{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return j(()=>{let l,d=!1,u=t/s,c=n/i,p=(r+t)/s,h=(a+n)/i,f=[u,c,p,h],m=[];e.rank===3?(d=!0,l=en([e])):l=e;for(let v=0;v<l.shape[0];v++)m.push(f);let g=Xn(m,[m.length,4]),y=ll(0,m.length,1,"int32"),b=_te(l,g,y,[r,a],"nearest");return zs(d?Re(Ut(b)):b,o)})}upsize(e,t,n,r){return j(()=>{let a=Ete(e,[t,n]);return zs(a,r)})}call(e,t){return j(()=>{let n=Re(e),r=n.dtype,a=n.shape,s=a[a.length-3],i=a[a.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,s,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=rt(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};g2.className="CenterCrop";oe.registerClass(g2);function $te(e,t,n,r){let a=Re(e);if(a.dtype!=="int32"&&(a=zs(a,"int32")),t==="int")return a;let s=a.shape;if(a.rank===0&&(a=yn(a,-1)),t==="oneHot"&&a.shape[a.shape.length-1]!==1&&(a=yn(a,-1)),a.rank>2)throw new H(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i=["multiHot","oneHot"].includes(t),o=a,l;if(typeof r<"u"&&t==="count"?l=Cy(o,r,n,i):l=Cy(o,[],n,i),t!=="tfIdf")return l;if(r)return W(l,r);throw new H("When outputMode is 'tfIdf', weights must be provided.")}var y2=class extends qe{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=rt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return j(()=>{e=Re(e),e.dtype!=="int32"&&(e=zs(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new H(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Re(t.countWeights)}let r=Zr(e),a=Vd(e),s=nr(this.numTokens,r).bufferSync().get(0),i=js(a,0).bufferSync().get(0);if(!(s&&i))throw new H(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return $te(e,this.outputMode,this.numTokens,n)})}};y2.className="CategoryEncoding";oe.registerClass(y2);var Ate=["bilinear","nearest"],xE=new Set(Ate),b2=class extends qe{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(xE.has(e.interpolation))this.interpolation=e.interpolation;else throw new H(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=rt(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return j(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return qr.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return qr.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...xE]} are supported`)})}};b2.className="Resizing";oe.registerClass(b2);var IO=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};IO.className="RandomSeed";var NO=class extends qe{constructor(e){super(e),this.randomGenerator=new IO(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};NO.className="BaseRandomLayer";var Rte=["bilinear","nearest"],wE=new Set(Rte),v2=class extends NO{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new H(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new H(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new H(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(wE.has(n))this.interpolation=n;else throw new H(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=rt(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return j(()=>{let n=Re(e);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=so([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*r;a=Math.round(a);let s=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return qr.resizeBilinear(e,s);case"nearest":return qr.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...wE]} are supported`)}})}};v2.className="RandomWidth";oe.registerClass(v2);function Fte(e){return new wp(e)}function Dte(e){return new xI(e)}function Mte(e){return new yI(e)}function Ote(e){return new bI(e)}function Pte(e){return new vI(e)}function Lte(e){return new kI(e)}function zte(e){return new wI(e)}function Bte(e){return new TI(e)}function Wte(e){return new Mv(e)}function Ute(e){return new II(e)}function Vte(e){return new Ov(e)}function jte(e){return new NI(e)}function Hte(e){return new CI(e)}function Gte(e){return new EI(e)}function qte(e){return new _I(e)}function Kte(e){return new $I(e)}function Xte(e){return new LI(e)}function Qte(e){return new OI(e)}function Jte(e){return new Wv(e)}function Zte(e){return new MI(e)}function Yte(e){return new PI(e)}function ene(e){return new zI(e)}function tne(e){return new BI(e)}function nne(e){return new WI(e)}function rne(e){return new VI(e)}function ane(e){return new jI(e)}function sne(e){return new GI(e)}function ine(e){return new XI(e)}function one(e){return new qI(e)}function lne(e){return new KI(e)}function une(e){return new HI(e)}function dne(e){return new QI(e)}function cne(e){return new e2(e)}function pne(e){return new t2(e)}function hne(e){return new n2(e)}function x2(e){return new a2(e)}function fne(e){return x2(e)}function mne(e){return x2(e)}function w2(e){return new i2(e)}function gne(e){return w2(e)}function yne(e){return w2(e)}function k2(e){return new l2(e)}function bne(e){return k2(e)}function vne(e){return k2(e)}function xne(e){return new u2(e)}function wne(e){return new c2(e)}function CO(e){return new d2(e)}function TO(e){return new p2(e)}function EO(e){return new r2(e)}function _O(e){return new s2(e)}function kne(e){return new o2(e)}function Sne(e){return new RI(e)}function Ine(e){return new Lv(e)}function Nne(e){return new FI(e)}function Cne(e){return new ym(e)}function Tne(e){return new AI(e)}function Ene(e){return new Pv(e)}function _ne(e){return new DI(e)}function $ne(e){return new Bv(e)}function Ane(e){return new qs(e)}function Rne(e){return new zv(e)}function Fne(e){return new f2(e)}function Dne(e){return new h2(e)}var Mne=CO,One=TO,Pne=EO,Lne=_O;function zne(e){return new JI(e)}function Bne(e){return new ZI(e)}function Wne(e){return new YI(e)}function Une(e){return new UI(e)}function Vne(e){return new m2(e)}function jne(e){return new g2(e)}function Hne(e){return new b2(e)}function Gne(e){return new y2(e)}function qne(e){return new v2(e)}var $O={};De($O,{MAPE:()=>are,MSE:()=>ore,binaryAccuracy:()=>Kne,binaryCrossentropy:()=>Xne,categoricalAccuracy:()=>Jne,categoricalCrossentropy:()=>Zne,cosineProximity:()=>tre,mape:()=>sre,meanAbsoluteError:()=>nre,meanAbsolutePercentageError:()=>rre,meanSquaredError:()=>ire,mse:()=>lre,precision:()=>Yne,r2Score:()=>ure,recall:()=>ere,sparseCategoricalAccuracy:()=>Qne});function Kne(e,t){return cI(e,t)}function Xne(e,t){return FM(e,t)}function Qne(e,t){return DM(e,t)}function Jne(e,t){return pI(e,t)}function Zne(e,t){return hI(e,t)}function Yne(e,t){return RM(e,t)}function ere(e,t){return Aee(e,t)}function tre(e,t){return dI(e,t)}function nre(e,t){return Av(e,t)}function rre(e,t){return kp(e,t)}function are(e,t){return kp(e,t)}function sre(e,t){return kp(e,t)}function ire(e,t){return Vu(e,t)}function ore(e,t){return Vu(e,t)}function lre(e,t){return Vu(e,t)}function ure(e,t){return Ree(e,t)}var AO={};De(AO,{modelFromJSON:()=>lte});var RO={};De(RO,{l1:()=>cre,l1l2:()=>dre,l2:()=>pre});function dre(e){return new mm(e)}function cre(e){return mte(e)}function pre(e){return gte(e)}var FO=class extends Jd{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Rs))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function pg(e,t){return e<t}function kE(e,t){return e>t}var DO=class extends FO{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Ge("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=pg:this.mode==="max"?this.monitorFunc=kE:this.monitor.indexOf("acc")!==-1?this.monitorFunc=kE:this.monitorFunc=pg,this.monitorFunc===pg&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===pg?1/0:-1/0}async onEpochEnd(e,t){await ni(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function hre(e){return new DO(e)}var fre={earlyStopping:hre},mre=K();mre.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var kr;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(kr||(kr={}));var SE;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(SE||(SE={}));var S2={};function gre(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};S2[e]=n}function MO(e){return S2[e]}function yre(e){delete S2[e]}function S(e,t,n,r,a){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,d=o<0?t.inputNames.length+o:o;if(s.type==="tensor")return En(t.inputNames[d],n,r,a);if(s.type==="tensors"){let p=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((h,f)=>{var m;return((m=p[f])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(h=>En(h,n,r,a))}let u=En(t.inputNames[d],n,r,a),c=u.dataSync();return s.type==="number"?c[0]:k.toNestedArray(u.shape,c)}let i=t.attrParams[e];return i&&i.value}function En(e,t,n,r){let[a,s]=Ir(e,n);if(r!=null){let o=r.getHashTableHandleByName(a);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[Py(a,o)]);return i!==void 0?t[Py(a,i)][s]:void 0}function IE(e,t,n){return t[Py(e,n.currentContextId)]}function Ns(e,t){let[n,r,a]=Ir(e,t);return[Py(n,t&&t.currentContextId),r,a]}function Py(e,t){return t?`${e}-${t}`:e}function Ir(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let r=e.split(":"),a;if(r.length===1)a=[e,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);a=[s,o,i]}return n&&t.parseNodeNameCache.set(e,a),a}function Bg(e,t,n){let r=S("pad",e,t,n);if(r==="explicit"){r=S("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)a[s][0]=r[s*2],a[s][1]=r[s*2+1];return a}return r}function Cs(e){return e.kept?e:is(e)}var OO={};De(OO,{json:()=>bre});var bre=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],PO={};De(PO,{json:()=>vre});var vre=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LO={};De(LO,{json:()=>xre});var xre=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],zO={};De(zO,{json:()=>wre});var wre=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],BO={};De(BO,{json:()=>kre});var kre=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],WO={};De(WO,{json:()=>Sre});var Sre=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],UO={};De(UO,{json:()=>Ire});var Ire=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],VO={};De(VO,{json:()=>Nre});var Nre=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],jO={};De(jO,{json:()=>Cre});var Cre=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],HO={};De(HO,{json:()=>Tre});var Tre=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],GO={};De(GO,{json:()=>Ere});var Ere=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],qO={};De(qO,{json:()=>_re});var _re=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],KO={};De(KO,{json:()=>$re});var $re=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],XO={};De(XO,{json:()=>Are});var Are=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],QO={};De(QO,{json:()=>Rre});var Rre=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],JO={};De(JO,{json:()=>Fre});var Fre=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],ZO={};De(ZO,{json:()=>Dre});var Dre=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],YO={};De(YO,{json:()=>Mre});var Mre=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],e3={};De(e3,{json:()=>Ore});var Ore=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],NE=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[OO,PO,LO,zO,BO,WO,UO,VO,jO,HO,GO,qO,KO,XO,QO,JO,ZO,YO,e3],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],a=[],s=[],i=n.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(f[m.name]):m.op==="Const"?a.push(f[m.name]):(m.input==null||m.input.length===0)&&s.push(f[m.name]),f),{}),o=[],l=[],d={},u={};t!=null&&(d=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));let c=Object.keys(i);c.forEach(f=>{let m=i[f];m.inputNames.forEach((g,y)=>{let[b,,v]=Ns(g),x=i[b];if(x.outputs!=null){let w=x.outputs.indexOf(v);if(w!==-1){let I=`${b}:${w}`;m.inputNames[y]=I}}m.inputs.push(x),x.children.push(m)})}),Object.keys(u).length===0?c.forEach(f=>{let m=i[f];m.children.length===0&&l.push(m)}):Object.keys(u).forEach(f=>{let[m]=Ns(f),g=i[m];g!=null&&(g.signatureKey=u[f],l.push(g))}),Object.keys(d).length>0?Object.keys(d).forEach(f=>{let[m]=Ns(f),g=i[m];g&&(g.signatureKey=d[f],o.push(g))}):o=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let h={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:p};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=MO(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,a)=>{let s=a.type,i;switch(a.type){case"string":i=Pw(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Pw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=jw(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=jw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=zw(e.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=zw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=Vw(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Vw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Lw(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Lw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=Gw(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Gw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=Uw(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Uw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=Hw(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Hw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=Bw(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Bw(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=Ww(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Ww(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=CE(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=CE(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:i,type:s},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],a={};t!=null&&(a=t.reduce((d,u)=>(d[u.name]=this.mapNode(u),u.op==="Const"&&r.push(d[u.name]),d),{}));let s=[],i=[];e.signature.inputArg.forEach(d=>{let[u]=Ns(d.name),c={name:u,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:I2(d.type),type:"dtype"}},children:[]};c.signatureKey=d.name,s.push(c),a[u]=c}),Object.keys(a).forEach(d=>{let u=a[d];u.inputNames.forEach((c,p)=>{let[h,,f]=Ns(c),m=a[h];if(m.outputs!=null){let g=m.outputs.indexOf(f);if(g!==-1){let y=`${h}:${g}`;u.inputNames[p]=y}}u.inputs.push(m),m.children.push(u)})});let o=e.ret;e.signature.outputArg.forEach(d=>{let[u,c]=Ns(o[d.name]),p=a[u];p!=null&&(p.defaultOutput=c,i.push(p))});let l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function Pre(e){let t=K().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function t3(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):Pre(e);return t?n:n.toLowerCase()}function Pw(e,t,n,r=!1){let a=e[t];return a!=null?t3(a.s,r):n}function Lw(e,t,n){let r=e[t];return r?r.b:n}function zw(e,t,n){let r=e[t]||{},a=r.i!=null?r.i:r.f!=null?r.f:n;return typeof a=="number"?a:parseInt(a,10)}function I2(e){switch(typeof e=="string"&&(e=kr[e]),e){case kr.DT_FLOAT:case kr.DT_HALF:return"float32";case kr.DT_INT32:case kr.DT_INT64:case kr.DT_INT8:case kr.DT_UINT8:return"int32";case kr.DT_BOOL:return"bool";case kr.DT_DOUBLE:return"float32";case kr.DT_STRING:return"string";case kr.DT_COMPLEX64:case kr.DT_COMPLEX128:return"complex64";default:return null}}function CE(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function Bw(e,t,n){let r=e[t];return r&&r.type?I2(r.type):n}function Ww(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(a=>I2(a)):n}function n3(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function Uw(e,t,n){let r=e[t];return r&&r.shape?n3(r.shape):n}function Vw(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(a=>typeof a=="number"?a:parseInt(a,10)):n}function jw(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map(s=>t3(s,r)):n}function Hw(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(a=>n3(a)):n}function Gw(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var Lre=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return En(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return En(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return zw(this.node.rawAttrs,e,t);if(n.s!=null)return Pw(this.node.rawAttrs,e,t);if(n.b!=null)return Lw(this.node.rawAttrs,e,t);if(n.shape!=null)return Uw(this.node.rawAttrs,e,t);if(n.type!=null)return Bw(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Vw(this.node.rawAttrs,e,t);if(n.list.s!=null)return jw(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Hw(this.node.rawAttrs,e,t);if(n.list.b!=null)return Gw(this.node.rawAttrs,e,t);if(n.list.type!=null)return Ww(this.node.rawAttrs,e,t)}return t}},Sn={};De(Sn,{OP_SCOPE_SUFFIX:()=>Ck,abs:()=>Xt,acos:()=>Ak,acosh:()=>Rk,add:()=>te,addN:()=>gF,all:()=>Vb,any:()=>Jh,argMax:()=>al,argMin:()=>Fk,asin:()=>Dk,asinh:()=>Mk,atan:()=>Ok,atan2:()=>Pk,atanh:()=>Lk,avgPool:()=>Vs,avgPool3d:()=>Bk,basicLSTMCell:()=>xF,batchNorm:()=>Lu,batchNorm2d:()=>Wk,batchNorm3d:()=>Uk,batchNorm4d:()=>Vk,batchToSpaceND:()=>Qf,bincount:()=>jk,bitwiseAnd:()=>wF,booleanMaskAsync:()=>dD,broadcastArgs:()=>kF,broadcastTo:()=>Bo,buffer:()=>Ve,cast:()=>ue,ceil:()=>Hk,clipByValue:()=>On,clone:()=>is,complex:()=>Ls,concat:()=>gt,concat1d:()=>Gk,concat2d:()=>qk,concat3d:()=>Kk,concat4d:()=>Xk,conv1d:()=>jb,conv2d:()=>Jn,conv2dTranspose:()=>Hb,conv3d:()=>Jk,conv3dTranspose:()=>Zk,cos:()=>Jf,cosh:()=>Gb,cosineWindow:()=>mv,cumprod:()=>ef,cumsum:()=>qb,denseBincount:()=>Cy,depthToSpace:()=>Yk,depthwiseConv2d:()=>zu,diag:()=>IF,dilation2d:()=>eS,div:()=>be,divNoNan:()=>tS,dot:()=>nS,dropout:()=>AS,einsum:()=>To,elu:()=>fp,enclosingPowerOfTwo:()=>RS,ensureShape:()=>CF,equal:()=>Or,erf:()=>Kb,euclideanNorm:()=>sS,exp:()=>Pn,expandDims:()=>yn,expm1:()=>iS,eye:()=>Xb,fft:()=>om,fill:()=>Dr,floor:()=>gp,floorDiv:()=>Ub,fused:()=>Xd,gather:()=>yp,gatherND:()=>fD,greater:()=>nr,greaterEqual:()=>js,ifft:()=>Kd,imag:()=>Zf,image:()=>qr,inTopKAsync:()=>mD,irfft:()=>lv,isFinite:()=>oS,isInf:()=>lS,isNaN:()=>uS,leakyRelu:()=>Yf,less:()=>jd,lessEqual:()=>ao,linalg:()=>MS,linspace:()=>AF,localResponseNormalization:()=>dS,log:()=>Pr,log1p:()=>em,logSigmoid:()=>cS,logSoftmax:()=>Jb,logSumExp:()=>tm,logicalAnd:()=>ba,logicalNot:()=>nm,logicalOr:()=>Zb,logicalXor:()=>pS,losses:()=>TD,lowerBound:()=>FF,matMul:()=>We,max:()=>Zr,maxPool:()=>hn,maxPool3d:()=>hS,maxPoolWithArgmax:()=>DF,maximum:()=>ms,mean:()=>Ft,meshgrid:()=>MF,min:()=>Vd,minimum:()=>Li,mirrorPad:()=>fS,mod:()=>mS,moments:()=>rm,movingAverage:()=>cD,mul:()=>W,multiRNNCell:()=>OF,multinomial:()=>PF,neg:()=>St,norm:()=>mp,notEqual:()=>ol,oneHot:()=>Hd,ones:()=>ur,onesLike:()=>Lr,op:()=>z,outerProduct:()=>LF,pad:()=>Ua,pad1d:()=>zF,pad2d:()=>BF,pad3d:()=>WF,pad4d:()=>UF,pool:()=>gS,pow:()=>ds,prelu:()=>sm,print:()=>$k,prod:()=>yS,raggedGather:()=>VF,raggedRange:()=>jF,raggedTensorToTensor:()=>HF,rand:()=>GF,randomGamma:()=>QF,randomNormal:()=>ev,randomStandardNormal:()=>JF,randomUniform:()=>so,randomUniformInt:()=>ZF,range:()=>ll,real:()=>Gd,reciprocal:()=>kS,relu:()=>ut,relu6:()=>tv,reshape:()=>V,reverse:()=>na,reverse1d:()=>YF,reverse2d:()=>eD,reverse3d:()=>tD,reverse4d:()=>nD,rfft:()=>lm,round:()=>nv,rsqrt:()=>rv,scalar:()=>Ce,scatterND:()=>pD,searchSorted:()=>Yb,selu:()=>av,separableConv2d:()=>bp,setdiff1dAsync:()=>rD,sigmoid:()=>ma,sign:()=>SS,signal:()=>CD,sin:()=>sv,sinh:()=>iv,slice:()=>Xe,slice1d:()=>im,slice2d:()=>ov,slice3d:()=>vp,slice4d:()=>qd,softmax:()=>io,softplus:()=>Bu,spaceToBatchND:()=>am,sparse:()=>ED,sparseToDense:()=>hD,spectral:()=>ND,split:()=>cr,sqrt:()=>wn,square:()=>ft,squaredDifference:()=>uv,squeeze:()=>oo,stack:()=>en,step:()=>Wu,stridedSlice:()=>IS,string:()=>_D,sub:()=>me,sum:()=>ke,tan:()=>NS,tanh:()=>Pi,tensor:()=>Xn,tensor1d:()=>ot,tensor2d:()=>os,tensor3d:()=>dv,tensor4d:()=>zi,tensor5d:()=>aD,tensor6d:()=>sD,tensorScatterUpdate:()=>oD,tile:()=>Er,topk:()=>TS,transpose:()=>Ue,truncatedNormal:()=>hv,unique:()=>ES,unsortedSegmentSum:()=>fv,unstack:()=>Ut,upperBound:()=>lD,variable:()=>_S,where:()=>xn,whereAsync:()=>$S,zeros:()=>Dt,zerosLike:()=>Ze});var zre=(e,t,n,r=Sn)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(S("a",e,t,n),S("b",e,t,n))];case"AddN":return[r.addN(S("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(S("a",e,t,n),S("b",e,t,n))];case"Mul":return[r.mul(S("a",e,t,n),S("b",e,t,n))];case"RealDiv":case"Div":return[r.div(S("a",e,t,n),S("b",e,t,n))];case"DivNoNan":return[r.divNoNan(S("a",e,t,n),S("b",e,t,n))];case"FloorDiv":return[r.floorDiv(S("a",e,t,n),S("b",e,t,n))];case"Sub":return[r.sub(S("a",e,t,n),S("b",e,t,n))];case"Minimum":return[r.minimum(S("a",e,t,n),S("b",e,t,n))];case"Maximum":return[r.maximum(S("a",e,t,n),S("b",e,t,n))];case"Pow":return[r.pow(S("a",e,t,n),S("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(S("a",e,t,n),S("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Bre=(e,t,n,r=Sn)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(S("x",e,t,n))];case"Acos":return[r.acos(S("x",e,t,n))];case"Acosh":return[r.acosh(S("x",e,t,n))];case"Asin":return[r.asin(S("x",e,t,n))];case"Asinh":return[r.asinh(S("x",e,t,n))];case"Atan":return[r.atan(S("x",e,t,n))];case"Atan2":return[r.atan2(S("x",e,t,n),S("y",e,t,n))];case"Atanh":return[r.atanh(S("x",e,t,n))];case"Ceil":return[r.ceil(S("x",e,t,n))];case"Complex":return[r.complex(S("real",e,t,n),S("imag",e,t,n))];case"Cos":return[r.cos(S("x",e,t,n))];case"Cosh":return[r.cosh(S("x",e,t,n))];case"Elu":return[r.elu(S("x",e,t,n))];case"Erf":return[r.erf(S("x",e,t,n))];case"Exp":return[r.exp(S("x",e,t,n))];case"Expm1":return[r.expm1(S("x",e,t,n))];case"Floor":return[r.floor(S("x",e,t,n))];case"Log":return[r.log(S("x",e,t,n))];case"Log1p":return[r.log1p(S("x",e,t,n))];case"Imag":return[r.imag(S("x",e,t,n))];case"Neg":return[r.neg(S("x",e,t,n))];case"Reciprocal":return[r.reciprocal(S("x",e,t,n))];case"Real":return[r.real(S("x",e,t,n))];case"Relu":return[r.relu(S("x",e,t,n))];case"Round":return[r.round(S("x",e,t,n))];case"Selu":return[r.selu(S("x",e,t,n))];case"Sigmoid":return[r.sigmoid(S("x",e,t,n))];case"Sin":return[r.sin(S("x",e,t,n))];case"Sign":return[r.sign(S("x",e,t,n))];case"Sinh":return[r.sinh(S("x",e,t,n))];case"Softplus":return[r.softplus(S("x",e,t,n))];case"Sqrt":return[r.sqrt(S("x",e,t,n))];case"Square":return[r.square(S("x",e,t,n))];case"Tanh":return[r.tanh(S("x",e,t,n))];case"Tan":return[r.tan(S("x",e,t,n))];case"ClipByValue":return[r.clipByValue(S("x",e,t,n),S("clipValueMin",e,t,n),S("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(S("x",e,t,n))];case"Rsqrt":return[r.rsqrt(En(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(S("x",e,t,n),S("alpha",e,t,n))];case"Prelu":return[r.prelu(S("x",e,t,n),S("alpha",e,t,n))];case"IsNan":return[r.isNaN(En(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(En(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(En(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function da(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){k.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let a=e[r],s=t[r];k.assert(a<0||s<0||a===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function TE(e){return!(typeof e=="number"||e.some(t=>t<0))}function Jp(e,t,n){let r=qw(e,n),a=!TE(r);if(a&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach(s=>{r=qw(s.shape,r)}),!TE(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function qw(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var Wre=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Ce(0),sn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),da(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,sn(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Xn([],[0].concat(this.elementShape));let n=this.readMany(e);return da(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),en(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Xn([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return da(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),gt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Ut(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=n===0?0:t.size/n,s=[];j(()=>{t=V(t,[1,n,a]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:r[o-1],0],d=[1,e[o],a];s[o]=V(Xe(t,l,d),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},Vv=class Kw{get id(){return this.idTensor.id}constructor(t,n,r,a=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t!=null&&t.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);da(n,s.shape,"TensorList shape mismatch: "),sn(s)}),this.idTensor=Ce(0),this.maxNumElements=a,sn(this.idTensor)}copy(){return new Kw([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);da(t,this.elementShape,"TensorList shape mismatch: ");let a=Jp(this.elementShape,this.tensors,t);return j(()=>{let s=this.tensors.map(i=>V(i,a));return en(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=Jp(this.elementShape,this.tensors,t),a=this.tensors.pop();return a.kept=!1,da(a.shape,t,"TensorList shape mismatch: "),V(a,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(da(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");sn(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new Kw([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)n.tensors[r]=this.tensors[r];return n}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);da(this.tensors[t].shape,n,"TensorList shape mismatch: ");let a=Jp(this.elementShape,this.tensors,n);return V(this.tensors[t],a)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);da(this.elementShape,n.shape,"TensorList shape mismatch: "),sn(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);da(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let a=Jp(this.elementShape,this.tensors,r);return t.length===0?Xn([],[0].concat(a)):j(()=>{let s=t.map(i=>V(this.tensors[i],a));return en(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);da(this.elementShape,n,"TensorList shape mismatch: ");let r=Jp(this.elementShape,this.tensors,n);return this.size()===0?Xn([],[0].concat(r)):j(()=>{let a=this.tensors.map(s=>V(s,r));return gt(a,0)})}};function Ure(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let a=e.shape.slice(1);da(a,t,"TensorList shape mismatch: ");let s=Ut(e);return new Vv(s,t,r)}function Vre(e,t,n,r){return new Vv([],e,t,r)}function jre(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(r!=null&&r!==-1&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new Vv([],n,e.dtype,r),i=Ut(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function Hre(e,t,n){let r=0,a=t.map(u=>(r+=u,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=qw(s,n),o=r===0?0:e.size/r,l=j(()=>{let u=[];e=V(e,[1,r,o]);for(let c=0;c<t.length;++c){let p=[0,c===0?0:a[c-1],0],h=[1,t[c],o];u[c]=V(Xe(e,p,h),i)}return e.dispose(),u}),d=new Vv([],n,e.dtype,t.length);for(let u=0;u<l.length;u++)d.setItem(u,l[u]);return d}var Gre=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=S("thenBranch",e,t,n),a=S("elseBranch",e,t,n),s=S("cond",e,t,n),i=S("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=S("body",e,t,n),a=S("cond",e,t,n),s=S("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(u=>u.id),l=await i[0].data();i.forEach(u=>{!u.kept&&o.indexOf(u.id)===-1&&u.dispose()});let d=s;for(;l[0];){let u=d;d=await n.functionMap[r].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap);let c=d.map(h=>h.id);u.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&c.indexOf(h.id)===-1&&h.dispose()});let p=await n.functionMap[a].executeFunctionAsync(d,n.tensorArrayMap,n.tensorListMap);l=await p[0].data(),p.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&c.indexOf(h.id)===-1&&h.dispose()})}return d}case"LoopCond":{let r=S("pred",e,t,n);return[Cs(r)]}case"Switch":{let r=S("pred",e,t,n),a=S("data",e,t,n);return a.kept||(a=Cs(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find(a=>En(a,t,n)!==void 0);if(r){let a=En(r,t,n);return[Cs(a)]}return}case"Enter":{let r=S("frameName",e,t,n),a=S("tensor",e,t,n);return n.enterFrame(r),[Cs(a)]}case"Exit":{let r=S("tensor",e,t,n);return n.exitFrame(),[Cs(r)]}case"NextIteration":{let r=S("tensor",e,t,n);return n.nextIteration(),[Cs(r)]}case"TensorArrayV3":{let r=S("size",e,t,n),a=S("dtype",e,t,n),s=S("elementShape",e,t,n),i=S("dynamicSize",e,t,n),o=S("clearAfterRead",e,t,n),l=S("identicalElementShapes",e,t,n),d=S("name",e,t,n),u=new Wre(d,a,r,s,l,i,o);return n.addTensorArray(u),[u.idTensor,Ce(1)]}case"TensorArrayWriteV3":{let r=S("tensorArrayId",e,t,n),a=S("index",e,t,n),s=S("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=S("tensorArrayId",e,t,n),a=S("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=S("tensorArrayId",e,t,n),a=S("indices",e,t,n),s=S("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=S("tensorArrayId",e,t,n),a=S("indices",e,t,n),s=S("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=S("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=S("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=S("tensorArrayId",e,t,n),a=S("tensor",e,t,n),s=S("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=S("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[Ce(a.size(),"int32")]}case"TensorArrayCloseV3":{let r=S("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=S("tensorListId",e,t,n),a=S("index",e,t,n),s=S("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=S("tensorListId",e,t,n),a=S("index",e,t,n),s=S("elementShape",e,t,n),i=S("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=S("indices",e,t,n),a=S("tensor",e,t,n),s=S("elementShape",e,t,n),i=S("numElements",e,t,n),o=jre(a,r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=S("elementShape",e,t,n),a=S("elementDType",e,t,n),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=S(s,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=Vre(r,a,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=S("tensorListId",e,t,n),a=S("indices",e,t,n),s=S("elementShape",e,t,n),i=S("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=S("tensorListId",e,t,n),a=S("elementShape",e,t,n),s=S("elementDType",e,t,n),i=S("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=S("tensor",e,t,n),a=S("elementShape",e,t,n),s=S("elementDType",e,t,n),i=Ure(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=S("tensorListId",e,t,n),a=n.getTensorList(r.id),s=S("dtype",e,t,n),i=S("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=S("tensorListId",e,t,n),a=S("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=S("tensorListId",e,t,n),a=S("elementShape",e,t,n),s=S("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=S("tensor",e,t,n),a=S("elementShape",e,t,n),s=S("lengths",e,t,n),i=Hre(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=S("tensorListId",e,t,n),a=n.getTensorList(r.id);return[Ce(a.size(),"int32")]}case"TensorListResize":{let r=S("tensorListId",e,t,n),a=S("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function EE(e,t,n){let[r,a]=S("fusedOps",e,t,n),s=r==="biasadd",i=!s,o=a==="prelu",l=r==="fusedbatchnorm",d=S("numArgs",e,t,n);if(s){if(o&&d!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&d!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=S("strides",e,t,n),c=Bg(e,t,n),p=S("dataFormat",e,t,n).toUpperCase(),h=S("dilations",e,t,n),[f,m]=S("args",e,t,n);i&&(m=f,f=void 0);let g=S("leakyreluAlpha",e,t,n);return{stride:u,pad:c,dataFormat:p,dilations:h,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:g}}var qre=(e,t,n,r=Sn)=>{switch(e.op){case"Conv1D":{let a=S("stride",e,t,n),s=S("pad",e,t,n),i=S("dataFormat",e,t,n).toUpperCase(),o=S("dilation",e,t,n);return[r.conv1d(S("x",e,t,n),S("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=S("strides",e,t,n),s=Bg(e,t,n),i=S("dataFormat",e,t,n).toUpperCase(),o=S("dilations",e,t,n);return[r.conv2d(S("x",e,t,n),S("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:d,activationFunc:u,leakyreluAlpha:c}=EE(e,t,n);return[r.fused.conv2d({x:S("x",e,t,n),filter:S("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:d,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:d,activationFunc:u,leakyreluAlpha:c}=EE(e,t,n);return[r.fused.depthwiseConv2d({x:S("x",e,t,n),filter:S("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:d,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=S("outputShape",e,t,n),s=S("strides",e,t,n),i=Bg(e,t,n);return[r.conv2dTranspose(S("x",e,t,n),S("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=S("strides",e,t,n),s=Bg(e,t,n),i=S("dilations",e,t,n),o=S("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(S("input",e,t,n),S("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("dataFormat",e,t,n).toUpperCase(),o=S("dilations",e,t,n);return[r.conv3d(S("x",e,t,n),S("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n);return[r.avgPool(S("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n);return[r.maxPool(S("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n),o=S("includeBatchInIndex",e,t,n),{result:l,indexes:d}=r.maxPoolWithArgmax(S("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,d]}case"AvgPool3D":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n);return[r.avgPool3d(S("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("kernelSize",e,t,n);return[r.maxPool3d(S("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=S("strides",e,t,n),s=S("pad",e,t,n),i=S("dilations",e,t,n),o=a[1],l=a[2],d=i[1],u=i[2];return[r.dilation2d(S("x",e,t,n),S("filter",e,t,n),[o,l],s,[d,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Kre=(e,t,n,r=Sn)=>{switch(e.op){case"Fill":{let a=S("shape",e,t,n),s=S("dtype",e,t,n),i=S("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=S("start",e,t,n),s=S("stop",e,t,n),i=S("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=S("logits",e,t,n),s=S("numSamples",e,t,n),i=S("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=S("indices",e,t,n),s=S("depth",e,t,n),i=S("onValue",e,t,n),o=S("offValue",e,t,n),l=S("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(S("shape",e,t,n),S("dtype",e,t,n))];case"OnesLike":return[r.onesLike(S("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(S("shape",e,t,n),S("dtype",e,t,n),S("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(S("shape",e,t,n),S("minval",e,t,n),S("maxval",e,t,n),S("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(S("shape",e,t,n),S("minval",e,t,n),S("maxval",e,t,n),S("seed",e,t,n))];case"Range":{let a=S("start",e,t,n),s=S("stop",e,t,n),i=S("step",e,t,n);return[r.range(a,s,i,S("dtype",e,t,n))]}case"TruncatedNormal":{let a=S("shape",e,t,n),s=S("mean",e,t,n),i=S("stdDev",e,t,n),o=S("seed",e,t,n);return[r.truncatedNormal(a,s,i,S("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(S("shape",e,t,n),S("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(S("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Kx(e,t,n){let r=S("boxes",e,t,n),a=S("scores",e,t,n),s=S("maxOutputSize",e,t,n),i=S("iouThreshold",e,t,n),o=S("scoreThreshold",e,t,n),l=S("softNmsSigma",e,t,n);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var Xre=async(e,t,n,r,a=Sn)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:d,softNmsSigma:u}=Kx(e,t,n),c=await a.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,d,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:d}=Kx(e,t,n),u=S("padToMaxOutputSize",e,t,n),c=await a.image.nonMaxSuppressionPaddedAsync(s,i,o,l,d,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:d}=Kx(e,t,n);return[await a.image.nonMaxSuppressionAsync(s,i,o,l,d)]}case"Where":{let s=a.cast(S("condition",e,t,n),"bool"),i=[await a.whereAsync(s)];return s.dispose(),i}case"ListDiff":return a.setdiff1dAsync(S("x",e,t,n),S("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},Qre=(e,t,n,r=Sn)=>{switch(e.op){case"LowerBound":{let a=S("sortedSequence",e,t,n),s=S("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=S("x",e,t,n),s=S("k",e,t,n),i=S("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=S("sortedSequence",e,t,n),s=S("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=S("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=S("x",e,t,n),s=S("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Jre=(e,t,n,r=Sn)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=S("default",e,t,n);return[En(e.name,t,n)||a];case"Placeholder":return[En(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=S("x",e,t,n);return[Cs(u)]}case"IdentityN":return S("x",e,t,n).map(u=>Cs(u));case"Snapshot":let s=S("x",e,t,n);return[Cs(s)];case"Shape":return[r.tensor1d(S("x",e,t,n).shape,"int32")];case"ShapeN":return S("x",e,t,n).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(S("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(S("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=S("x",e,t,n),o=S("data",e,t,n),l=S("message",e,t,n),d=S("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<o.length;u++)console.log(Array.prototype.slice.call(o[u].dataSync()).slice(0,d));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Zre=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Ce(0),this.tensorMap=new Map,sn(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ce(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),j(()=>{let r=Ut(t),a=n.length,s=r.length;k.assert(a===s,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${s} elements.`);for(let i=0;i<a;i++){let o=n[i],l=r[i];sn(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return j(()=>{let r=[];for(let a=0;a<n.length;a++){let s=n[a],i=this.findWithDefault(s,t);r.push(i)}return en(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},Yre=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(a!=null)return[a];{let s=S("keyDType",e,t,n),i=S("valueDType",e,t,n),o=new Zre(s,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=S("tableHandle",e,t,n,r),s=S("keys",e,t,n),i=S("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=S("tableHandle",e,t,n,r),s=S("keys",e,t,n),i=S("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=S("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},eae=(e,t,n,r=Sn)=>{switch(e.op){case"ResizeBilinear":{let a=S("images",e,t,n),s=S("size",e,t,n),i=S("alignCorners",e,t,n),o=S("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=S("images",e,t,n),s=S("size",e,t,n),i=S("alignCorners",e,t,n),o=S("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=S("image",e,t,n),s=S("boxes",e,t,n),i=S("boxInd",e,t,n),o=S("cropSize",e,t,n),l=S("method",e,t,n),d=S("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,d)]}case"ImageProjectiveTransformV3":{let a=S("images",e,t,n),s=S("transforms",e,t,n),i=S("outputShape",e,t,n),o=S("fillValue",e,t,n),l=S("interpolation",e,t,n),d=S("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),d.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},tae=(e,t,n,r=Sn)=>{switch(e.op){case"Equal":return[r.equal(S("a",e,t,n),S("b",e,t,n))];case"NotEqual":return[r.notEqual(S("a",e,t,n),S("b",e,t,n))];case"Greater":return[r.greater(S("a",e,t,n),S("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(S("a",e,t,n),S("b",e,t,n))];case"Less":return[r.less(S("a",e,t,n),S("b",e,t,n))];case"LessEqual":return[r.lessEqual(S("a",e,t,n),S("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(S("a",e,t,n),S("b",e,t,n))];case"LogicalNot":return[r.logicalNot(S("a",e,t,n))];case"LogicalOr":return[r.logicalOr(S("a",e,t,n),S("b",e,t,n))];case"Select":case"SelectV2":return[r.where(S("condition",e,t,n),S("a",e,t,n),S("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(S("a",e,t,n),S("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},nae=(e,t,n,r=Sn)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(S("a",e,t,n),S("b",e,t,n),S("transposeA",e,t,n),S("transposeB",e,t,n))];case"Einsum":return[r.einsum(S("equation",e,t,n),...S("tensors",e,t,n))];case"Transpose":return[r.transpose(S("x",e,t,n),S("perm",e,t,n))];case"_FusedMatMul":let[a,s]=S("fusedOps",e,t,n),i=a==="biasadd",o=s==="prelu",l=S("numArgs",e,t,n),d=S("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,c]=S("args",e,t,n);return[r.fused.matMul({a:S("a",e,t,n),b:S("b",e,t,n),transposeA:S("transposeA",e,t,n),transposeB:S("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:c,leakyreluAlpha:d})];case"MatrixBandPart":return[r.linalg.bandPart(S("a",e,t,n),S("numLower",e,t,n),S("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},rae=(e,t,n,r=Sn)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(S("x",e,t,n),S("axis",e,t,n),S("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(S("x",e,t,n),S("mean",e,t,n),S("variance",e,t,n),S("offset",e,t,n),S("scale",e,t,n),S("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(S("x",e,t,n),S("mean",e,t,n),S("variance",e,t,n),S("offset",e,t,n),S("scale",e,t,n),S("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(S("x",e,t,n),S("radius",e,t,n),S("bias",e,t,n),S("alpha",e,t,n),S("beta",e,t,n))];case"Softmax":return[r.softmax(S("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(S("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},aae=(e,t,n,r=Sn)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(S("paramsNestedSplits",e,t,n),S("paramsDenseValues",e,t,n),S("indices",e,t,n),S("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(S("starts",e,t,n),S("limits",e,t,n),S("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(S("shape",e,t,n),S("values",e,t,n),S("defaultValue",e,t,n),S("rowPartitionTensors",e,t,n),S("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},sae=(e,t,n,r=Sn)=>{switch(e.op){case"Max":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.max(S("x",e,t,n),o,l)]}case"Mean":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.mean(S("x",e,t,n),o,l)]}case"Min":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.min(S("x",e,t,n),o,l)]}case"Sum":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.sum(S("x",e,t,n),o,l)]}case"All":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.all(S("x",e,t,n),o,l)]}case"Any":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.any(S("x",e,t,n),o,l)]}case"ArgMax":{let o=S("axis",e,t,n);return[r.argMax(S("x",e,t,n),o)]}case"ArgMin":{let o=S("axis",e,t,n);return[r.argMin(S("x",e,t,n),o)]}case"Prod":{let o=S("axis",e,t,n),l=S("keepDims",e,t,n);return[r.prod(S("x",e,t,n),o,l)]}case"Cumprod":{let o=S("axis",e,t,n),l=S("exclusive",e,t,n),d=S("reverse",e,t,n);return[r.cumprod(S("x",e,t,n),o,l,d)]}case"Cumsum":{let o=S("axis",e,t,n),l=S("exclusive",e,t,n),d=S("reverse",e,t,n);return[r.cumsum(S("x",e,t,n),o,l,d)]}case"Bincount":let a=S("x",e,t,n),s=S("weights",e,t,n),i=S("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let o=S("x",e,t,n),l=S("weights",e,t,n),d=S("size",e,t,n),u=S("binaryOutput",e,t,n);return[r.denseBincount(o,l,d,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},iae=(e,t,n,r=Sn)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=S("n",e,t,n),s=S("axis",e,t,n),i=S("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=S("x",e,t,n),s=S("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=S("axis",e,t,n),s=S("batchDims",e,t,n),i=S("x",e,t,n),o=S("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=S("dims",e,t,n),s=[];for(let o=0;o<a.length;o++)a[o]&&s.push(o);let i=S("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=S("axis",e,t,n),s=S("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=S("begin",e,t,n),s=S("size",e,t,n);return[r.slice(S("x",e,t,n),a,s)]}case"StridedSlice":{let a=S("begin",e,t,n),s=S("end",e,t,n),i=S("strides",e,t,n),o=S("beginMask",e,t,n),l=S("endMask",e,t,n),d=S("ellipsisMask",e,t,n),u=S("newAxisMask",e,t,n),c=S("shrinkAxisMask",e,t,n),p=S("x",e,t,n);return[r.stridedSlice(p,a,s,i,o,l,d,u,c)]}case"Pack":return j(()=>{let a=S("axis",e,t,n),s=S("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map(d=>{let u=k.arraysEqual(d.shape,i);if(!u&&!k.arraysEqual(r.squeeze(d).shape,o))throw new Error("the input tensors shape does not match");return u?d:r.reshape(d,i)});return[r.stack(l,a)]});case"Unpack":{let a=S("axis",e,t,n),s=S("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=S("reps",e,t,n);return[r.tile(S("x",e,t,n),a)]}case"Split":case"SplitV":{let a=S("axis",e,t,n),s=S("numOrSizeSplits",e,t,n),i=S("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=S("indices",e,t,n),s=S("values",e,t,n),i=S("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=S("x",e,t,n),s=S("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=S("sparseIndices",e,t,n),s=S("outputShape",e,t,n),i=S("sparseValues",e,t,n),o=S("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=S("indices",e,t,n),s=S("values",e,t,n),i=S("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},oae=(e,t,n,r=Sn)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(S("indices",e,t,n),S("values",e,t,n),S("denseShape",e,t,n),S("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(S("inputIndices",e,t,n),S("inputShape",e,t,n),S("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(S("data",e,t,n),S("indices",e,t,n),S("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(S("data",e,t,n),S("indices",e,t,n),S("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},lae=(e,t,n,r=Sn)=>{switch(e.op){case"FFT":return[r.fft(S("x",e,t,n))];case"IFFT":return[r.ifft(S("x",e,t,n))];case"RFFT":return[r.rfft(S("x",e,t,n))];case"IRFFT":return[r.irfft(S("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},uae=(e,t,n,r=Sn)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(S("input",e,t,n),S("pattern",e,t,n),S("rewrite",e,t,n),S("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(S("data",e,t,n),S("dataSplits",e,t,n),S("separator",e,t,n),S("nGramWidths",e,t,n),S("leftPad",e,t,n),S("rightPad",e,t,n),S("padWidth",e,t,n),S("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(S("input",e,t,n),S("delimiter",e,t,n),S("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(S("input",e,t,n),S("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},dae=(e,t,n,r=Sn)=>{switch(e.op){case"Cast":return[r.cast(S("x",e,t,n),S("dtype",e,t,n))];case"ExpandDims":{let a=S("axis",e,t,n);return[r.expandDims(S("x",e,t,n),a)]}case"Squeeze":{let a=S("axis",e,t,n);return[r.squeeze(S("x",e,t,n),a)]}case"Reshape":return[r.reshape(S("x",e,t,n),S("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(S("x",e,t,n),S("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(S("x",e,t,n),S("padding",e,t,n),S("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(S("x",e,t,n),S("padding",e,t,n),S("constantValue",e,t,n))];case"SpaceToBatchND":{let a=S("blockShape",e,t,n),s=S("paddings",e,t,n);return[r.spaceToBatchND(S("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=S("blockShape",e,t,n),s=S("crops",e,t,n);return[r.batchToSpaceND(S("x",e,t,n),a,s)]}case"DepthToSpace":{let a=S("blockSize",e,t,n),s=S("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(S("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(S("x",e,t,n),S("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(S("s0",e,t,n),S("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function _E(e,t,n,r,a=j){let s=((i,o,l)=>{switch(i.category){case"arithmetic":return a(()=>zre(i,o,l));case"basic_math":return a(()=>Bre(i,o,l));case"control":return Gre(i,o,l);case"convolution":return a(()=>qre(i,o,l));case"creation":return a(()=>Kre(i,o,l));case"dynamic":return Xre(i,o,l);case"evaluation":return a(()=>Qre(i,o,l));case"image":return a(()=>eae(i,o,l));case"graph":return a(()=>Jre(i,o,l));case"logical":return a(()=>tae(i,o,l));case"matrices":return a(()=>nae(i,o,l));case"normalization":return a(()=>rae(i,o,l));case"ragged":return a(()=>aae(i,o,l));case"reduction":return a(()=>sae(i,o,l));case"slice_join":return a(()=>iae(i,o,l));case"sparse":return a(()=>oae(i,o,l));case"spectral":return a(()=>lae(i,o,l));case"string":return a(()=>uae(i,o,l));case"transformation":return a(()=>dae(i,o,l));case"hash_table":return Yre(i,o,l,r);case"custom":let d=MO(i.op);if(d&&d.customExecutor)return d.customExecutor(new Lre(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return k.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var $E=class{constructor(e={},t={},n={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function AE(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,d=new Set(Object.keys(e).map(p=>Ir(p)[0]));r=r||[];let u=new Set(r.map(p=>Ir(p.name)[0])),c=[...t];for(;c.length>0;){let p=c.pop();if((_o(p)||bae(p)||vae(p))&&i==null&&(i=p,o=i.children.map(h=>h.name).filter(h=>a.has(h))),a.add(p.name),n[p.name]==null&&!d.has(p.name)&&!u.has(p.name)){if(p.inputs.length===0){s.push(p.name);continue}p.inputs.forEach(h=>{l.has(h.name)||(l.add(h.name),c.push(h))})}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function cae(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map(g=>Ir(g)[0]).map(g=>e.nodes[g]),s=e.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function o(g){return[...new Map(g.map(y=>[y.name,y])).values()]}let l=o([...a,...e.weights,...s]).filter(i),d=o([...l,...Object.values(e.nodes)]).filter(i),u=new Map(d.map(g=>[g.name,g])),c={};for(let g of d){c[g.name]=c[g.name]||0;for(let y of g.children)i(y)||(c[y.name]=Number.POSITIVE_INFINITY),c[y.name]=(c[y.name]||0)+1}let p=Object.entries(c).filter(([,g])=>g===0).map(([g])=>g),h=[...p];for(;p.length>0;){let g=p.pop(),y=u.get(g);for(let b of y.children.filter(i))--c[b.name]===0&&(h.push(b.name),p.push(b.name))}let f=h.map(g=>u.get(g)),m=pae(f,l);return hae(m,l),m}function pae(e,t){let n=new Map(e.map(s=>[s.name,s])),r=t.map(s=>s.name),a=new Set(r);for(;r.length>0;){let s=r.pop(),i=n.get(s);for(let o of i.children)!n.has(o.name)||a.has(o.name)||(a.add(o.name),r.push(o.name))}return e.filter(s=>a.has(s.name))}var hg=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function hae(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),a=o=>r.has(typeof o=="string"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new hg(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new hg(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!a(o))for(let l of o.inputs){if(!n.has(l.name))throw new hg(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new hg(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function fae(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,l)=>_o(o)?n:l),a=o=>{let l=r[t.get(o.name)];return l??-1},s=e.map((o,l)=>o.children.map(a).reduce((d,u)=>Math.max(d,u),r[l])),i=new Map;for(let o=0;o<e.length;++o){let l=s[o];if(l===n)continue;let d=e[o],u=e[l];i.has(u.name)||i.set(u.name,[]),i.get(u.name).push(d)}return i}var mae=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),gae=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),yae=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function _o(e){return mae.has(e.op)}function bae(e){return gae.has(e.op)}function vae(e){return yae.has(e.op)}var RE=class r3{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(r=>t[r].map(a=>a.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new r3(t.functions[r],this)})}getCompilationKey(t,n){let r=t.map(s=>s.name).sort(),a=n.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(t,n){let r=AE(t,n,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(a.length>0){let d=n.map(c=>c.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${d}] from the provided inputs [${u}]. Missing the following inputs: [${a}]`)}let o=cae(this.graph,r),l=fae(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return sn(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let a=r.map(p=>this.graph.nodes[Ir(p)[0]]),s=n.map(p=>Ir(p)[0]),i=new Set(s),o=s.map(p=>this.graph.nodes[p]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(a,o),d=this.compiledMap.get(l);d==null&&(d=this.compile(t,o),this.compiledMap.set(l,d));try{this.keepIntermediateTensors=K().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let u={},c={};return j(()=>{let p=new $E(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{let[b,v]=Ir(y,p),x=[];x[v]=t[y],h[b]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(x))});let f=this.getFrozenTensorIds(h),{orderedNodes:m,nodeLiveUntilMap:g}=d;for(let y of m){if(h[y.name])continue;let b=_E(y,h,p,this._resourceManager);if(k.isPromise(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);h[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,h,p,f,i,g.get(y.name))}return this.parent==null&&p.dispose(f),n.map(y=>En(y,h,p))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(a=>a.id)));return new Set(n)}checkTensorForDisposal(t,n,r,a,s,i,o){if(!(_o(n)||i.has(t))){for(let l of r[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(_o(l))continue;let d=IE(l.name,r,a);if(d!=null)for(let u of d){if(!u||u.kept||s.has(u.id))continue;let c=o[u.id];c===1?(u.dispose(),delete o[u.id]):c!=null&&o[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,r,a,s,i){function o(l){return _o(l)||s.has(l.name)}if(!(_o(t)||i==null))for(let l of i){if(o(l))continue;let d=IE(l.name,n,r);for(let u of d)!u||u.kept||a.has(u.id)||u.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,r=!1,a={},s={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=K().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}let i=new $E(this.weightMap,a,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,r),l=n.map(p=>En(p,o,i)),d=l.map(p=>p.id),u=Object.keys(t).map(p=>t[p].id),c=new Set([...d,...u,...this.weightIds]);return Object.values(o).forEach(p=>{p.forEach(h=>{h&&!h.isDisposed&&!c.has(h.id)&&h.dispose()})}),this.parent==null&&i.dispose(c),l}async executeFunctionAsync(t,n,r){let a=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(a,this.outputNodes,!0,n,r)}async executeWithControlFlow(t,n,r,a){let s=Object.keys(t),i=s.map(x=>this.graph.nodes[Ir(x)[0]]),o=r.map(x=>Ir(x)[0]),l=new Set(o),d=o.map(x=>this.graph.nodes[x]);d.length===0&&(d=this._outputs);let{usedNodes:u,missingInputs:c,dynamicNode:p,syncInputs:h}=AE(t,d,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:n.currentContext})),m=Object.assign({},this.weightMap);Object.keys(t).forEach(x=>{let[w,I]=Ir(x),N=[];N[I]=t[x],m[w]=N});let g={},y=this.getFrozenTensorIds(m),b={};for(;f.length>0;){let x=this.processStack(i,f,n,m,b,y,l,g,u);await Promise.all(x)}p==null&&!a&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let v=d.filter(x=>!_o(x)&&!En(x.name,m,n)).map(x=>x.name);if(v.length>0){let x="";throw p!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${x}`)}return m}processStack(t,n,r,a,s,i,o,l,d){let u=[];for(;n.length>0;){let c=n.pop();r.currentContext=c.contexts;let p="";if(c.node.op==="Enter"&&S("isConstant",c.node,a,r)&&([p]=Ns(c.node.name,r)),a[c.node.name]==null){let h=_E(c.node,a,r,this._resourceManager);p||([p]=Ns(c.node.name,r));let f=r.currentContext;k.isPromise(h)?u.push(h.then(m=>(a[p]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(m)),r.currentContext=f,this.checkTensorForDisposal(p,c.node,a,r,i,o,l),this.processChildNodes(c.node,n,r,a,s,d),m))):(a[p]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(h)),this.checkTensorForDisposal(p,c.node,a,r,i,o,l),this.processChildNodes(c.node,n,r,a,s,d))}else this.processChildNodes(c.node,n,r,a,s,d)}return u}processChildNodes(t,n,r,a,s,i){t.children.forEach(o=>{let[l]=Ns(o.name,r);s[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(d=>!!En(d,a,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(d=>!!En(d,a,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let r=t[n],[a]=Ir(n),s=this.graph.nodes[a];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===r.shape.length&&r.shape.every((l,d)=>i[d]===-1||i[d]===l);k.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&k.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var n,r;let a={};for(let s in t){let i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[s];i!=null?a[i.name]=t[s]:a[s]=t[s]}return a}checkInputs(t){let n=Object.keys(t).filter(r=>{let[a]=Ir(r);return this.graph.nodes[a]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var r,a;let s=(a=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||a===void 0?void 0:a[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{let[r]=Ir(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}},xae=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},wae="?tfjs-format=file",kae="model.json",N2=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=$n){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new xae}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return k.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await iF(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new RE(NE.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let a=NE.Instance.transformGraph(e.modelInitializer);this.initializer=new RE(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Pe?[e]:e,n={};return t.forEach((r,a)=>n[this.structuredOutputKeys[a]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Pe)&&!Array.isArray(e)){let a=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(a!=null)for(let s in a){let i=a[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,s)=>{var i,o,l;let d=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return d!=null?a[s]=this.resourceIdToCapturedInput[d]:a[s]=e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=n[r],s=t[a];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Fe(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function Sae(e,t={},n=$n){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=Nae(e));let r=new N2(e,t,n);return await r.load(),r}function Iae(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,a]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!a||!(a instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let s=$n.getWeightSpecs(r.weightsManifest),i=$n.getModelArtifactsForJSONSync(r,s,a);t=$n.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=$n.fromMemorySync(e);else throw new Error("Unknown model format");let n=new N2(t);return n.load(),n}function Nae(e){return e.endsWith("/")||(e=e+"/"),`${e}${kae}${wae}`}var Cae="4.22.0",a3={};De(a3,{CSVDataset:()=>m3,Dataset:()=>Sp,FileDataSource:()=>k3,TextLineDataset:()=>f3,URLDataSource:()=>S3,array:()=>Xae,csv:()=>lse,func:()=>use,generator:()=>dse,microphone:()=>pse,version_data:()=>hse,webcam:()=>cse,zip:()=>Qae});var Tae=Zi(kb()),Eae=Zi(kb());function _ae(e,t){return Ly(e,t)}function Ly(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse)if(Zd(e)){let s=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=e[i],l=Ly(o,t,n,r);s[i]=l}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,a.value),a.value}function $ae(e,t=i3){return s3(e,t)}function s3(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse)if(Zd(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let o=e.map(d=>d[i]),l=s3(o,t,n);s[i]=l}return n.delete(r),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return a.value}function i3(e){return e===null?null:Zd(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function o3(e,t){let n=new Map;Ly(e,t,n);for(let r of Array.from(n.keys())){let a=n.get(r);if(k.isPromise(a)){let s=await a;n.set(r,s)}}return Ly(e,t,n)}function Zd(e){let t=!1;if(K().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=CR();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Pe)&&!(e instanceof Promise)&&!t)}function Aae(e){return e==null||Rae(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Pe||k.isTypedArray(e)}function Rae(e){return e===null||typeof e!="object"&&typeof e!="function"}function Fae(e){return _ae(e,Dae)}function Dae(e){return e instanceof Pe?{value:e.clone(),recurse:!1}:Zd(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var l3=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},u3=class d3 extends l3{constructor(){super(d3.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),r=this.length();for(let a=0;a<r;a++)n[a]=this.get(this.wrap(this.begin+a));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};u3.INITIAL_CAPACITY=32;function c3(e){return new Pae(e)}function C2(e){return new Lae(e)}function Mae(e,t){return new p3(e,t)}function Oae(e,t=gi.FAIL){return new qae(e,t)}var kn=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new Hae(this,e)}filter(e){return new Vae(this,e)}map(e){return new jae(this,e)}mapAsync(e){return new FE(this,e)}serialMapAsync(e){return new FE(this,e).serial()}flatmap(e){return new Gae(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new Uae(this,e,t)}columnMajorBatch(e,t=!0,n=i3){return this.rowMajorBatch(e,t).map(r=>$ae(r,n))}concatenate(e,t){return new p3(c3([this,e]),t)}take(e){return e<0||e==null?this:new Wae(this,e)}skip(e){return e<0||e==null?this:new Bae(this,e)}prefetch(e){return new h3(this,e)}shuffle(e,t){return new Kae(this,e,t)}serial(){return new zae(this)}},Pae=class extends kn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:Fae(e),done:!1}}},Lae=class extends kn{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},zae=class extends kn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},Bae=class extends kn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Fe(e.value)}return this.upstream.next()}},Wae=class extends kn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},Uae=class extends kn{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},Vae=class extends kn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Fe(e.value)}}},jae=class extends kn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ra.getTensorsInContainer(e.value),n=this.transform(e.value),r=Ra.getTensorsInContainer(n);for(let a of t)Ra.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},Hae=class extends kn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},FE=class extends kn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ra.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Ra.getTensorsInContainer(n);for(let a of t)Ra.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},T2=class extends kn{constructor(){super(),this.outputQueue=new u3,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},Gae=class extends T2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Ra.getTensorsInContainer(e.value),n=this.transform(e.value),r=Ra.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)Ra.isTensorInList(a,r)||a.dispose();return!0}},p3=class extends kn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},gi;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(gi||(gi={}));var qae=class extends kn{constructor(e,t=gi.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(s){return s instanceof kn?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let a=await o3(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case gi.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case gi.SHORTEST:return{value:null,done:!0};case gi.LONGEST:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},h3=class extends kn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new l3(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},Kae=class extends h3{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Eae.alea(n||k.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},Sp=class{constructor(){this.size=null}batch(e,t=!0){let n=this;k.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),Sr(async()=>(await n.iterator()).columnMajorBatch(e,t,Jae),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Sr(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Sr(async()=>(await t.iterator()).filter(r=>j(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Sr(async()=>(await t.iterator()).map(n=>j(()=>e(n))),this.size)}mapAsync(e){let t=this;return Sr(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Sr(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Sr(async()=>{let r=C2(async()=>({value:await t.iterator(),done:!1}));return Mae(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Sr(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=Tae.alea(t||k.now().toString());return Sr(async()=>{let s=a.int32();return n&&(s+=a.int32()),(await r.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Sr(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Sp.MAX_BUFFER_SIZE=1e4;function Sr(e,t=null){return new class extends Sp{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function Xae(e){return Sr(async()=>c3(e),e.length)}function Qae(e){if(!Zd(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Sr(async()=>{let n=await o3(e,r=>{if(r instanceof Sp)return{value:r.iterator(),recurse:!1};if(Zd(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return Oae(n,gi.SHORTEST)},t)}function Jae(e){if(e===null)return null;let t=e[0];return Aae(t)?{value:Zae(e),recurse:!1}:{value:null,recurse:!0}}function Zae(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Pe?en(e):Xn(e)}var f3=class extends Sp{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},fg='"',Zp=Symbol("out"),DE=Symbol("field"),mg=Symbol("quote"),Xx=Symbol("quoteafterquote"),ME=Symbol("quoteinquote"),m3=class extends Sp{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&k.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,a)=>(r[a]=r[a]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(k.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new f3(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(k.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[a],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let d=Number(o);if(isNaN(d))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=d;else switch(i.dtype){case"float32":l=d;break;case"int32":l=Math.floor(d);break;case"bool":l=this.getBoolean(o);break;default:l=d}}i&&i.isLabel?r[s]=l:n[s]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=Zp;for(let i=0;i<a;i++)switch(s){case Zp:switch(e.charAt(i)){case fg:r=i+1,s=mg;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),s=Zp;break;default:s=DE,r=i;break}break;case DE:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),s=Zp,r=i+1;break}break;case mg:switch(e.charAt(i)){case fg:s=Xx;break}break;case Xx:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=Zp,r=i+1;break;case fg:s=mg;break;default:s=ME;break}break;case ME:switch(e.charAt(i)){case fg:s=mg;break}break}if(s===Xx?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},Yae=class g3 extends kn{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!K().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new g3(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,r=await this.getAudioData();if(this.includeSpectrogram){let a=this.flattenQueue(r.freqDataQueue);t=this.getTensorFromAudioDataArray(a,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let a=this.flattenQueue(r.timeDataQueue);n=this.getTensorFromAudioDataArray(a,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],r=0;return new Promise(a=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&a({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(s),a({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,r=new Float32Array(t.length*n);return t.forEach((a,s)=>r.set(a,s*n)),r}getTensorFromAudioDataArray(t,n){let r=new Float32Array(k.sizeFromShape(n));return r.set(t,r.length-t.length),Xn(r,n)}},ese=class y3 extends kn{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=ot([0],"int32"),this.webcamConfig.centerCrop){let r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,a=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-r)/2,i=(1-a)/2,o=s+r,l=a+i;this.cropBox=os([i,s,l,o],[1,4])}else this.cropBox=os([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!K().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new y3(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&k.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=um.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return j(()=>{let n=yn(ue(t,"float32"),0),r;r=qr.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let a=r.shape;return V(r,a.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},b3=class{},v3=class extends kn{split(e){return new tse(this,e)}},tse=class extends v3{constructor(e,t){super(),this.upstream=e,this.impl=new nse(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},nse=class extends T2{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},rse=class extends kn{decodeUTF8(){return new ase(this)}},ase=class extends v3{constructor(e){super(),this.upstream=e,this.impl=new sse(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},sse=class extends T2{constructor(e){if(super(),this.upstream=e,K().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=CR();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return K().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},x3=class extends rse{constructor(e,t={}){super(),this.file=e,this.options=t,k.assert(e instanceof Uint8Array||(K().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=s=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=s=>t(new Error("Aborted")),r.onerror=s=>t(new Error(s.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n}),done:!1}}};async function ise(e,t={},n){let r,a;typeof e=="string"?r=e:(r=e.url,a=ose(e));let s=await(0,k.fetch)(r,a);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new x3(i,t)}else throw new Error(s.statusText)}var ose=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function w3(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var k3=class extends b3{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(w3(this.input)&&K().get("IS_NODE")){let e=bk();this.input=e.readFileSync(this.input.slice(7))}return new x3(this.input,this.options)}},S3=class extends b3{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return w3(this.url)?new k3(this.url,this.fileOptions).iterator():ise(this.url,this.fileOptions)}};function lse(e,t={}){return new m3(new S3(e),t)}function use(e){let t=C2(e);return Sr(async()=>t)}function dse(e){return Sr(async()=>{let t=await e();return C2(()=>t.next())})}async function cse(e,t){return ese.create(e,t)}async function pse(e){return Yae.create(e)}var hse="4.22.0";function Ie(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&k.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var fse=gs.whereImpl,E2=class I3 extends wf{nextDataId(){return I3.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Sb(this,ua())}write(t,n,r){this.firstUse&&(this.firstUse=!1,K().get("IS_NODE")&&E.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let a={id:this.nextDataId()};return this.data.set(a,{values:t,dtype:r,refCount:1}),a}makeTensorInfo(t,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&k.isString(r[0])){let s=r.map(i=>k.encodeString(i));a=this.write(s,t,n)}else a=this.write(r,t,n);return{dataId:a,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,r,a,s){this.data.set(t,{values:n,dtype:a,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){let a=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId);return E.mergeRealAndImagArrays(a,s)}return k.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(a=>k.decodeString(a));return Ve(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ve(t.shape,t.dtype,n)}makeOutput(t,n,r){return ua().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=k.now();return t(),{kernelMs:k.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Ie([t],"where");let n=this.readSync(t.dataId);return fse(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};E2.nextDataId=0;var _2={};De(_2,{addImpl:()=>T3,bincountImpl:()=>A2,bincountReduceImpl:()=>E3,bitwiseAndImpl:()=>_3,castImpl:()=>C3,ceilImpl:()=>$3,concatImpl:()=>R2,equalImpl:()=>A3,expImpl:()=>F3,expm1Impl:()=>M3,floorDivImpl:()=>P3,floorImpl:()=>O3,gatherNdImpl:()=>L3,gatherV2Impl:()=>z3,greaterEqualImpl:()=>W3,greaterImpl:()=>B3,lessEqualImpl:()=>V3,lessImpl:()=>U3,linSpaceImpl:()=>j3,logImpl:()=>H3,maxImpl:()=>G3,maximumImpl:()=>q3,minimumImpl:()=>K3,multiplyImpl:()=>F2,negImpl:()=>X3,notEqualImpl:()=>Q3,prodImpl:()=>J3,raggedGatherImpl:()=>Z3,raggedRangeImpl:()=>Y3,raggedTensorToTensorImpl:()=>eP,rangeImpl:()=>M2,rsqrtImpl:()=>tP,scatterImpl:()=>Oo,sigmoidImpl:()=>hie,simpleAbsImpl:()=>N3,sliceImpl:()=>By,sparseFillEmptyRowsImpl:()=>rP,sparseReshapeImpl:()=>aP,sparseSegmentReductionImpl:()=>O2,sqrtImpl:()=>gie,squaredDifferenceImpl:()=>sP,staticRegexReplaceImpl:()=>iP,stridedSliceImpl:()=>oP,stringNGramsImpl:()=>P2,stringSplitImpl:()=>L2,stringToHashBucketFastImpl:()=>z2,subImpl:()=>lP,tileImpl:()=>uP,topKImpl:()=>cP,transposeImpl:()=>D2,uniqueImpl:()=>W2});function N3(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var mse=e=>{let{x:t}=e.inputs,n=e.backend;Ie(t,"abs");let r=new Float32Array(k.sizeFromShape(t.shape)),a=n.data.get(t.dataId).values;return r=N3(a),n.makeOutput(r,t.shape,t.dtype)},gse={kernelName:cc,backendName:"cpu",kernelFunc:mse};function Gt(e){return(t,n,r,a,s)=>{let i=E.assertAndGetBroadcastShape(t,n),o=i.length,l=k.computeStrides(i),d=k.sizeFromShape(i),u=k.getTypedArrayFromDType(s,d),c=t.length,p=n.length,h=k.computeStrides(t),f=k.computeStrides(n),m=E.getBroadcastDims(t,i),g=E.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<u.length;++y){let b=k.indexToLoc(y,o,l),v=b.slice(-c);m.forEach(N=>v[N]=0);let x=k.locToIndex(v,c,h),w=b.slice(-p);g.forEach(N=>w[N]=0);let I=k.locToIndex(w,p,f);u[y]=e(r[x],a[I])}return[u,i]}}function Cr(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var yse={kernelName:Cb,backendName:"cpu",kernelFunc:Cr};function zy(e,t,n="float32"){if(n==="complex64"){let a=zy(e,t,"float32"),s=zy(e,t,"float32");return Cr({inputs:{real:a,imag:s},backend:e})}let r=k.makeZerosTypedArray(k.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function ps(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var bse={kernelName:Xl,backendName:"cpu",kernelFunc:ps};function dl(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var vse={kernelName:Lb,backendName:"cpu",kernelFunc:dl};function C3(e,t,n,r){if(r==="int32"){let a=Int32Array.from(e);return[t,"int32",a]}if(r==="bool"){let a=k.toTypedArray([0],n),[s,i]=Gt((o,l)=>o!==l?1:0)(t,[],e,a,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function ji(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return ps({inputs:{x:a},backend:n});let u=zy(n,a.shape,a.dtype),c=ji({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),p=Cr({inputs:{real:c,imag:u},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),p}if(a.dtype==="complex64"){let u=dl({inputs:{input:a},backend:n}),c=ji({inputs:{x:u},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(u),c}if(!k.hasEncodingLoss(a.dtype,s)){let u=ps({inputs:{x:a},backend:n});return{dataId:u.dataId,shape:u.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,d]=C3(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,d)}var xse={kernelName:$l,backendName:"cpu",kernelFunc:ji};function cn(e,t,n,r){return n==null?({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;Ie([i,o],e);let d=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,c=i.dtype==="string"?E.fromUint8ToStringArray(d):d,p=i.dtype==="string"?E.fromUint8ToStringArray(u):u,h=r||i.dtype,[f,m]=t(i.shape,o.shape,c,p,h);return l.makeTensorInfo(m,h,f)}:({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;if(i.dtype==="complex64"||o.dtype==="complex64"){let d=ji({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(d.dataId),c=u.complexTensorInfos.real,p=u.complexTensorInfos.imag,h=l.data.get(c.dataId).values,f=l.data.get(p.dataId).values,m=ji({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,v=l.data.get(y.dataId).values,x=l.data.get(b.dataId).values,[w,I,N]=n(i.shape,o.shape,h,f,v,x),T=l.makeTensorInfo(N,"float32",w),A=l.makeTensorInfo(N,"float32",I),R=Cr({inputs:{real:T,imag:A},backend:l});return l.disposeIntermediateTensorInfo(d),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(T),l.disposeIntermediateTensorInfo(A),R}else{let d=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,c=r||i.dtype,[p,h]=t(i.shape,o.shape,d,u,c);return l.makeTensorInfo(h,c,p)}}}function $2(e){return(t,n,r,a,s,i)=>{let o=E.assertAndGetBroadcastShape(t,n),l=k.sizeFromShape(o),d=o.length,u=k.computeStrides(o),c=k.getTypedArrayFromDType("float32",l),p=k.getTypedArrayFromDType("float32",l),h=E.getBroadcastDims(t,o),f=E.getBroadcastDims(n,o),m=E.mergeRealAndImagArrays(r,a),g=E.mergeRealAndImagArrays(s,i),y=t.length,b=k.computeStrides(t),v=n.length,x=k.computeStrides(n);if(h.length+f.length===0)for(let w=0;w<c.length;w++){let I=w%m.length,N=w%g.length,T=e(m[I*2],m[I*2+1],g[N*2],g[N*2+1]);c[w]=T.real,p[w]=T.imag}else for(let w=0;w<c.length;w++){let I=k.indexToLoc(w,d,u),N=I.slice(-y);h.forEach(C=>N[C]=0);let T=k.locToIndex(N,y,b),A=I.slice(-v);f.forEach(C=>A[C]=0);let R=k.locToIndex(A,v,x),F=e(m[T*2],m[T*2+1],g[R*2],g[R*2+1]);c[w]=F.real,p[w]=F.imag}return[c,p,o]}}var T3=Gt((e,t)=>e+t),wse=$2((e,t,n,r)=>({real:e+n,imag:t+r})),Yd=cn(Yi,T3,wse),kse={kernelName:Yi,backendName:"cpu",kernelFunc:Yd};function A2(e,t,n,r,a){let s=k.sizeFromShape(r),i=k.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=a||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function E3(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=Ve([a,n],t.dtype);for(let o=0;o<a;o++)for(let l=0;l<s;l++){let d=e.get(o,l);if(d<0)throw new Error("Input x must be non-negative!");d>=n||(r?i.set(1,o,d):t.size>0?i.set(i.get(o,d)+t.get(o,l),o,d):i.set(i.get(o,d)+1,o,d))}return i}var _3=Gt((e,t)=>e&t),Sse=cn(vc,_3),Ise={kernelName:vc,backendName:"cpu",kernelFunc:Sse};function ys(e){return(t,n,r)=>{let a=k.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function ct(e,t,n){let r=ys(t);return lo(e,r,n)}function lo(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;Ie(i,e);let o=s,l=o.data.get(i.dataId).values,d;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");d=E.fromUint8ToStringArray(l)}else d=l;let u=n||i.dtype,c=t(d,u,a);return o.makeTensorInfo(i.shape,u,c)}}var $3=ys(e=>Math.ceil(e)),Nse=lo(Al,$3),Cse={kernelName:Al,backendName:"cpu",kernelFunc:Nse};function R2(e,t,n,r){let a=k.getArrayFromDType(n,k.sizeFromShape(t));if(r&&n!=="string"){let s=0;e.forEach(i=>{let o=k.sizeFromShape(i.shape);a.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n==="string"?E.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let d=0;d<i.shape[0];++d){let u=d*t[1]+s;for(let c=0;c<i.shape[1];++c)a[u+c]=o[l++]}s+=i.shape[1]})}return a}var A3=Gt((e,t)=>e===t?1:0),R3=cn(Tc,A3,null,"bool"),Tse={kernelName:Tc,backendName:"cpu",kernelFunc:R3},F3=ys(e=>Math.exp(e)),D3=lo(Vl,F3,"float32"),Ese={kernelName:Vl,backendName:"cpu",kernelFunc:D3},M3=ys(e=>Math.expm1(e)),_se=lo(jl,M3),$se={kernelName:jl,backendName:"cpu",kernelFunc:_se},O3=ys(e=>Math.floor(e)),Ase=lo(Hl,O3),Rse={kernelName:Hl,backendName:"cpu",kernelFunc:Ase},P3=Gt((e,t)=>Math.floor(e/t)),Fse=cn(Gl,P3,null,"int32"),Dse={kernelName:Gl,backendName:"cpu",kernelFunc:Fse};function L3(e,t,n,r,a,s,i,o,l){let d=Ve([r,s],n);for(let u=0;u<r;u++){let c=[],p=0;for(let h=0;h<a;h++){let f=e[u*a+h];p+=f*i[h],c.push(f)}if(p<0||p>=l/s)throw new Error(`Invalid indices: ${c} does not index into ${o}`);for(let h=0;h<s;h++)d.values[u*s+h]=t.get(...t.indexToLoc(p*s+h))}return d}function z3(e,t,n){let r=Ve(n,e.dtype);for(let a=0;a<r.size;++a){let s=r.indexToLoc(a).slice(),i=s[0],o=s[2],l=t.locToIndex([i,o]);s[2]=t.values[l];let d=e.locToIndex(s);0<=d&&d<e.values.length&&(r.values[a]=e.values[d])}return r}var B3=Gt((e,t)=>e>t?1:0),Mse=cn(Rc,B3,null,"bool"),Ose={kernelName:Rc,backendName:"cpu",kernelFunc:Mse},W3=Gt((e,t)=>e>=t?1:0),Pse=cn(Kl,W3,null,"bool"),Lse={kernelName:Kl,backendName:"cpu",kernelFunc:Pse},U3=Gt((e,t)=>e<t?1:0),zse=cn(Fc,U3,null,"bool"),Bse={kernelName:Fc,backendName:"cpu",kernelFunc:zse},V3=Gt((e,t)=>e<=t?1:0),Wse=cn(Dc,V3,null,"bool"),Use={kernelName:Dc,backendName:"cpu",kernelFunc:Wse};function j3(e,t,n){let r=(t-e)/(n-1),a=k.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var H3=ys(e=>Math.log(e)),Vse=lo(eu,H3),jse={kernelName:eu,backendName:"cpu",kernelFunc:Vse};function G3(e,t,n,r){let a=k.getTypedArrayFromDType(r,k.sizeFromShape(n));for(let s=0;s<a.length;++s){let i=s*t,o=e[i];for(let l=0;l<t;++l){let d=e[i+l];(Number.isNaN(d)||d>o)&&(o=d)}a[s]=o}return a}var q3=Gt((e,t)=>Math.max(e,t)),Hse=cn(au,q3),Gse={kernelName:au,backendName:"cpu",kernelFunc:Hse},K3=Gt((e,t)=>Math.min(e,t)),qse=cn(lu,K3),Kse={kernelName:lu,backendName:"cpu",kernelFunc:qse},F2=Gt((e,t)=>e*t),Xse=$2((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),jv=cn(cu,F2,Xse),Qse={kernelName:cu,backendName:"cpu",kernelFunc:jv};function X3(e,t,n){let r=k.createScalarValue(-1,n);return F2([],t,r,e,n)}function Jse(e){let{inputs:t,backend:n}=e,{x:r}=t;Ie(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=X3(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}var Zse={kernelName:Uc,backendName:"cpu",kernelFunc:Jse},Q3=Gt((e,t)=>e!==t?1:0),Yse=cn(Vc,Q3,null,"bool"),eie={kernelName:Vc,backendName:"cpu",kernelFunc:Yse};function D2(e,t,n,r,a){let s=t.length,i=k.sizeFromShape(t),o=k.computeStrides(t),l=k.computeStrides(a),d=k.getTypedArrayFromDType(n,k.sizeFromShape(a));for(let u=0;u<i;++u){let c=k.indexToLoc(u,s,o),p=new Array(c.length);for(let f=0;f<p.length;f++)p[f]=c[r[f]];let h=k.locToIndex(p,s,l);d[h]=e[u]}return d}function mr(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;Ie(a,"transpose");let i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];let l=r.data.get(a.dataId).values,d=D2(l,a.shape,a.dtype,s,o);return{dataId:r.write(d,o,a.dtype),shape:o,dtype:a.dtype}}var tie={kernelName:As,backendName:"cpu",kernelFunc:mr};function J3(e,t,n,r){let[a,s]=E.computeOutAndReduceShapes(e,r),i=ea(t,"int32"),o=k.makeZerosTypedArray(k.sizeFromShape(a),i),l=k.sizeFromShape(s);for(let d=0;d<o.length;++d){let u=d*l,c=1;for(let p=0;p<l;++p)c*=n[u+p];o[d]=c}return{outVals:o,outShape:a,outDtype:i}}function nie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"prod");let o=a.shape.length,l=k.parseAxisParam(s,a.shape),d=E.getAxesPermutation(l,o),u=l,c=a,p=[];d!=null&&(c=mr({inputs:{x:a},backend:n,attrs:{perm:d}}),p.push(c),u=E.getInnerMostAxes(u.length,o));let h=n.data.get(c.dataId).values,{outVals:f,outShape:m,outDtype:g}=J3(c.shape,c.dtype,h,u),y=m;return i&&(y=E.expandShapeToKeepDim(m,l)),p.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(y,g,f)}var rie={kernelName:gu,backendName:"cpu",kernelFunc:nie};function aie(e,t,n){e.forEach((r,a)=>{if(r<0||r>=n){let s=k.indexToLoc(a,t.length,k.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${n})`)}})}function sie(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function iie(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);sie(n,r);let l=1;for(let d=0;d<t.length-1;++d){l*=t[d];let u=t[d+1];for(let c=1;c<l+1;++c)o[d].push(c*u)}for(let d=0;d<e.length;++d){let u=e[d],c=e[d]+1;for(let p=0;p<n.length;++p){let h=n[p],f=p+t.length-1;if(f>=0){let m=o[f],g=m[m.length-1]-h[u];for(let y=u;y<c;++y)o[f].push(h[y+1]+g)}u=h[u],c=h[c]}c!==u&&(a.push([u,c]),s+=c-u)}return{outSplits:o,valueSlices:a,numValues:s}}function oie(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=k.getArrayFromDType("int32",r);t.push(a),e[n].forEach((s,i)=>a[i]=s)}return t}function OE(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function lie(e,t,n,r,a,s){let i=OE(t,2)[1],o=OE(s,2)[1],l=0;for(let d of n)for(let u=d[0];u<d[1];++u){for(let c=0;c<r;++c)a[l*o+c]=e[u*i+c];++l}}function uie(e,t,n,r,a){let s=t.slice();s[0]=a;let i=k.getArrayFromDType(n,k.sizeFromShape(s)),o=e.length,l=o===0?0:o/t[0];return lie(e,t,r,l,i,s),[i,s]}function Z3(e,t,n,r,a,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(aie(s,i,l),r.length===0)throw new Error("params.rank must be nonzero");let d=r[0],{outSplits:u,valueSlices:c,numValues:p}=iie(s,i,e,d),h=oie(u),f=uie(n,r,a,c,p);return[h,f[0],f[1]]}var PE=2147483647;function Y3(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=a.length===0,d=i.length===0,u=[];o||u.push(t[0]),l||u.push(a[0]),d||u.push(i[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");let c=u.length===0?1:u[0],p=k.getArrayFromDType("int32",c+1);p[0]=0;for(let g=0;g<c;++g){let y=o?e[0]:e[g],b=l?r[0]:r[g],v=d?s[0]:s[g];if(v===0)throw new Error("Requires delta != 0");let x;if(v>0&&b<y||v<0&&b>y)x=0;else if(x=Math.ceil(Math.abs((b-y)/v)),x>PE)throw new Error(`Requires ((limit - start) / delta) <= ${PE}`);p[g+1]=p[g]+x}let h=p[c],f=k.getArrayFromDType(n,h),m=0;for(let g=0;g<c;++g){let y=p[g+1]-p[g],b=o?e[0]:e[g],v=d?s[0]:s[g];for(let x=0;x<y;++x)f[m++]=b,b+=v}return[p,f]}var la=E.RowPartitionType,die=class Xw{constructor(t,n,r,a,s,i,o,l,d,u){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=a,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=E.getRowPartitionTypesHelper(u),this.raggedRank=E.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===la.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===la.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case la.VALUE_ROWIDS:return Xw.getMaxWidthValueRowID(n);case la.ROW_SPLITS:return Xw.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${la[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let r=0;for(let a=0;a<n-1;++a){let s=t[a+1]-t[a];s>r&&(r=s)}return r}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let r=0,a=t[0],s=0;for(let i=1;i<n;++i){let o=t[i];o!==a&&(a=o,s=Math.max(i-r,s),r=i)}return Math.max(n-r,s)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return zE(t,r)}calculateOutputSize(t){let n=this.valuesShape,r=this.defaultValueShape;E.validateDefaultValueShape(r,n);let a=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=E.combineRaggedTensorToTensorShapes(this.raggedRank,a,n);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,n,r){let a=Math.min(t,r),s=[],i=0;for(let o=0;o<a;++o,i+=n)s.push(i);for(let o=a;o<t;++o)s.push(-1);return k.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,n,r,a){let s=t.length,i=[];for(let o=0;o<s-1;++o){let l=t[o+1]-t[o],d=Math.min(a,l),u=n[o];u===-1&&(d=0);for(let c=0;c<d;++c)i.push(u),u+=r;for(let c=0;c<l-d;++c)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,a){let s=t.length,i=[];if(s===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let d=n[l];i.push(d);for(let u=1;u<s;++u){let c=t[u];if(c===l)d>=0&&(++o,o<a?d+=r:d=-1);else{if(o=0,l=c,c>=n.length)throw new Error(`Got nextValueRowId=${c} which is not less than ${n.length}`);d=n[c]}i.push(d)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,a){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case la.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,r,a);case la.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,r,a);default:throw new Error(`Unsupported partition type: ${la[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case la.FIRST_DIM_SIZE:return t[0];case la.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case la.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${la[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let i=r.length-2;i>=0;--i)r[i]=r[i+1]*n[i+1];let a=zE(n,!1),s=k.getArrayFromDType(this.valuesDType,k.sizeFromShape(a));if(r[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,r[o],n[o]);this.setOutput(this.raggedRank,i,s,a)}return[a,s]}setOutput(t,n,r,a){if(r.length===0)return;let s=this.values,i=r,o=a.slice();o=o.slice(t+1);let l=k.sizeFromShape(o),d=n.length,u=this.defaultValue;if(u.length!==l&&u.length!==1){let f=this.defaultValueShape;j(()=>{let m=V(u,f);u=Bo(m,o).dataSync()})}let c=0,p=0,h=0;for(let f=0;f<=d;++f){let m=f<d?n[f]:-1;if(m===h){++h;continue}if(p<h){let g=s.subarray(c*l),y=i.subarray(p*l),b=(h-p)*l;LE(y,g,b)}if(f>=d){let g=r.length;m=Math.floor(g/l)}if(m>h)if(this.defaultValue.length===1)i.subarray(h*l,m*l).fill(this.defaultValue[0]),h=m;else for(;m>h;){let g=i.slice(h*l);LE(g,u,l),++h}m<0?(c=f+1,p=h):(c=f,p=h,h=p+1)}}};function LE(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function zE(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function eP(e,t,n,r,a,s,i,o,l,d){return new die(e,t,n,r,a,s,i,o,l,d).compute()}function M2(e,t,n,r){let a=e===t,s=e<t&&n<0,i=t<e&&n>1;if(a||s||i)return k.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=k.makeZerosTypedArray(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let d=1;d<l.length;d++)l[d]=l[d-1]+n;return l}var tP=ys(e=>1/Math.sqrt(e)),cie=lo(Iu,tP),pie={kernelName:Iu,backendName:"cpu",kernelFunc:cie};function Oo(e,t,n,r,a,s,i,o,l,d){let u=[r/a,a],c=e.values,p=t.values;if(r===0)return Ve(n,t.dtype);let h=l instanceof Yt?l:Ve(u,t.dtype);typeof l=="string"||typeof l=="number"?h.values.fill(l):typeof l=="boolean"&&h.values.fill(+l);for(let f=0;f<s;f++){let m=[],g=0;for(let y=0;y<i;y++){let b=c[f*i+y];m.push(b),g+=b*o[y]}if(g<0||g>=r/a)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<a;y++)d?h.values[g*a+y]+=p[f*a+y]:h.values[g*a+y]=t.rank===0?p[0]:p[f*a+y]}return h}var hie=ys(e=>1/(1+Math.exp(-e))),nP=ct(_u,e=>1/(1+Math.exp(-e))),fie={kernelName:_u,backendName:"cpu",kernelFunc:nP};function By(e,t,n,r,a){let s=ln.isSliceContinous(r,t,n),i=k.sizeFromShape(n),o=k.computeStrides(r);if(s){let c=ln.computeFlatOffset(t,o);return a==="string"?e.slice(c,c+i):e.subarray(c,c+i)}let l=a==="string"?E.fromUint8ToStringArray(e):e,d=Ve(r,a,l),u=Ve(n,a);for(let c=0;c<u.size;++c){let p=u.indexToLoc(c),h=p.map((f,m)=>f+t[m]);u.set(d.get(...h),...p)}return a==="string"?E.fromStringArrayToUint8(u.values):u.values}function cl(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;Ie(a,"slice");let[o,l]=ln.parseSliceParams(a,s,i);ln.assertParamsValid(a,o,l);let d=n.data.get(a.dataId).values,u=By(d,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var mie={kernelName:np,backendName:"cpu",kernelFunc:cl};function rP(e,t,n,r,a,s,i){let o=t[0],l=s[0],d=new Array(l),u=new Array(o),c=t[1];if(l===0){if(o!==0)throw new Error(E.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=k.getArrayFromDType(n,0),y=k.getArrayFromDType(a,0);return[g,[0,c],y,d,u]}let p=!0,h=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let y=e[g*c];if(y<0)throw new Error(E.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=l)throw new Error(E.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,l));++f[y],p=p&&y>=h,h=y}let m=!0;for(let g=0;g<l;++g){let y=f[g]===0;d[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&p){let g=e,y=r;for(let b=0;b<o;++b)u[b]=b;return[g,[o,c],y,d,u]}else{let g=f[l-1],y=k.getArrayFromDType(n,g*c),b=k.getArrayFromDType(a,g),v=new Array(l).fill(0);for(let x=0;x<o;++x){let w=e[x*c],I=v[w],N=(w===0?0:f[w-1])+I;v[w]++;for(let T=0;T<c;++T)y[N*c+T]=e[x*c+T];b[N]=r[x],u[x]=N}for(let x=0;x<l;++x)if(v[x]===0){let w=x===0?0:f[x-1];y[w*c+0]=x;for(let I=1;I<c;++I)y[w*c+I]=0;b[w]=i}return[y,[g,c],b,d,u]}}function aP(e,t,n,r,a){let s=k.sizeFromShape(r),i=t[0],o=a.length,l=[],d=1,u=-1;for(let m=0;m<o;++m){let g=a[m];if(g===-1){if(u!==-1)throw new Error(E.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,m));u=m,l.push(1)}else{if(g<0)throw new Error(E.getSparseReshapeNegativeOutputDimErrorMessage(m,g));d*=g,l.push(g)}}if(u!==-1){if(d<=0)throw new Error(E.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(s/d);if(d*m!==s)throw new Error(E.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[u]=m}if(k.sizeFromShape(l)!==s)throw new Error(E.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let c=r.length,p=[];if(c>0){p[c-1]=1;for(let m=c-2;m>=0;--m)p[m]=p[m+1]*r[m+1]}let h=[];if(o>0){h[o-1]=1;for(let m=o-2;m>=0;--m)h[m]=h[m+1]*l[m+1]}let f=k.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let g=0;for(let y=0;y<c;++y)g+=e[m*c+y]*p[y];for(let y=0;y<o;++y)f[m*o+y]=Math.trunc(g/h[y]),g%=h[y]}return[f,[i,o],l]}function O2(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],d=l[1],u=o>0?a[o-1]+1:0;if(u<0)throw new Error(E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=t.slice();c[0]=u;let p=c.reduce((b,v)=>b*v,1),h=k.getArrayFromDType(n,p);if(o===0)return u>0&&h.fill(i),[h,c];if(u<=0)throw new Error(E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let b=0;if(m<o){if(b=a[m],y===b){++m;continue}if(y>=b)throw new Error(E.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=u)throw new Error(E.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,u));y>g&&h.fill(i,g*d,y*d);for(let v=f;v<m;++v){let x=r[v];if(x<0||x>=l[0])throw new Error(E.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v,r[v],l[0]));for(let w=0;w<d;w++)h[y*d+w]+=e[x*d+w]}if(s)for(let v=0;v<d;v++)h[y*d+v]/=m-f;if(f=m,++m,g=y+1,y=b,m>o)break}return g<u&&h.fill(i,g*d,u*d),[h,c]}var gie=ys(e=>Math.sqrt(e)),yie=ct(Au,e=>Math.sqrt(e)),bie={kernelName:Au,backendName:"cpu",kernelFunc:yie},sP=Gt((e,t)=>{let n=e-t;return n*n}),vie=cn(Du,sP),xie={kernelName:Du,backendName:"cpu",kernelFunc:vie},iP=ys((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)}),wie=lo(Lf,iP),kie={kernelName:Lf,backendName:"cpu",kernelFunc:wie};function oP(e,t,n,r){let a=Ve(e,t.dtype);for(let s=0;s<a.size;s++){let i=a.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];a.set(t.get(...o),...i)}return a}var Sie=class{constructor(e,t,n,r,a,s){this.separator=k.encodeString(e),this.nGramWidths=t,this.leftPad=k.encodeString(n),this.rightPad=k.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),d=Math.max(0,o-(a-(i+1))),u=s-(l+d),c=t+(l>0?0:i-o),p=0;p+=l*this.leftPad.length;for(let y=0;y<u;++y)p+=e[c+y].length;p+=d*this.rightPad.length;let h=l+d+u-1;p+=h*this.separator.length,n[r+i]=new Uint8Array(p);let f=n[r+i],m=0,g=y=>y.forEach(b=>f[m++]=b);for(let y=0;y<l;++y)g(this.leftPad),g(this.separator);for(let y=0;y<u-1;++y)g(e[c+y]),g(this.separator);if(u>0){g(e[c+u-1]);for(let y=0;y<d;++y)g(this.separator),g(this.rightPad)}else{for(let y=0;y<d-1;++y)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let d=t[l]>=o;if(d=d&&t[l]<=n,!d)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let a=r-1,s=k.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let l=0;l<=a;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=a;++o){let l=t[o]-t[o-1],d=0;this.nGramWidths.forEach(u=>{d+=this.getNumNGrams(l,u)}),this.preserveShort&&l>0&&d===0&&(d=1),s[o]=s[o-1]+d}let i=new Array(s[a]);for(let o=0;o<a;++o){let l=t[o],d=s[o];if(this.nGramWidths.forEach(u=>{let c=t[o+1]-t[o],p=this.getNumNGrams(c,u);this.createNGrams(e,l,i,d,p,u),d+=p}),this.preserveShort&&d===s[o]){let u=t[o+1]-t[o];if(u===0)continue;let c=u+2*this.padWidth;this.createNGrams(e,l,i,d,1,c)}}return[i,s]}};function P2(e,t,n,r,a,s,i,o){return new Sie(n,r,a,s,i,o).compute(e,t)}function Iie(e,t,n,r){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)r.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&r.push(e);return}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(a,s);(!n||i.length!==0)&&r.push(i),a=s+1}}function L2(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let p=0;p<r;++p){let h=a.length;Iie(e[p],t,n,a);let f=a.length-h;o[p]=f,s+=f,i=Math.max(i,f)}let l=k.getArrayFromDType("int32",s*2),d=new Array(s),u=[r,i],c=0;for(let p=0;p<r;++p)for(let h=0;h<o[p];++h)l[c*2]=p,l[c*2+1]=h,d[c]=a[c],++c;return[l,d,u]}function z2(e,t){let n=k.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=k.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var lP=Gt((e,t)=>e-t),Nie=$2((e,t,n,r)=>({real:e-n,imag:t-r})),B2=cn(Mu,lP,Nie),Cie={kernelName:Mu,backendName:"cpu",kernelFunc:B2};function uP(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=Ve(n,e.dtype);for(let a=0;a<r.values.length;++a){let s=r.indexToLoc(a),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let o=e.locToIndex(i);r.values[a]=e.values[o]}return r}var ih=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function dP(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=t-n+1,d=Math.log(o),u=.5*Math.exp(2*d/3),c=.5*Math.sqrt(d*u*(o-u)/o)*Math.sign(l-o/2),p=Math.max(n,Math.floor(t-l*u/o+c)),h=Math.min(r,Math.floor(t+(o-l)*u/o+c));dP(e,t,p,h)}let a=e[t],s=n,i=r;for(k.swap(e,n,t),ih(e[r],a)>0&&k.swap(e,n,r);s<i;){for(k.swap(e,s,i),s++,i--;ih(e[s],a)<0;)s=s+1;for(;ih(e[i],a)>0;)i=i-1}ih(e[n],a)===0?k.swap(e,n,i):(i=i+1,k.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function cP(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=k.getTypedArrayFromDType(n,i*r),d=k.getTypedArrayFromDType("int32",i*r);for(let c=0;c<i;c++){let p=c*o,h=e.subarray(p,p+o),f=new Array(h.length);h.forEach((b,v)=>f[v]={value:b,index:v}),r<f.length&&(dP(f,r),f=f.slice(0,r)),a&&f.sort(ih);let m=c*r,g=l.subarray(m,m+r),y=d.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=f[b].value,y[b]=f[b].index}let u=t.slice();return u[u.length-1]=r,[Ve(u,n,l),Ve(u,"int32",d)]}function W2(e,t,n,r){let a=k.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i=new Map,o=new Int32Array(n[a]),l=new Yt(s,r,e),d=[],u=s[0]===1&&s[2]===1;for(let f=0;f<n[a];f++){let m;if(u)m=e[f].toString();else{let y=[];for(let b=0;b<s[0];b++)for(let v=0;v<s[2];v++)y.push(l.get(b,f,v));m=y.join(",")}let g=i.get(m);if(g!=null)o[f]=g;else{let y=i.size;i.set(m,y),o[f]=y,d.push(f)}}let c=s.slice();c[1]=i.size;let p=new Yt(c,r);d.forEach((f,m)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)p.set(l.get(g,f,y),g,m,y)});let h=n.slice();return h[a]=c[1],{outputValues:p.values,outputShape:h,indices:o}}var Tie="4.22.0";Wb("cpu",()=>new E2,1);var pP=ct(Wl,e=>e>=0?e:Math.exp(e)-1),Eie={kernelName:Wl,backendName:"cpu",kernelFunc:pP};function hP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;Ie([a],"leakyRelu");let i=k.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=k.getTypedArrayFromDType("float32",i);for(let d=0;d<o.length;d++)l[d]=o[d]<0?s*o[d]:o[d];return n.makeTensorInfo(a.shape,"float32",l)}var _ie={kernelName:Yl,backendName:"cpu",kernelFunc:hP},$ie=Gt((e,t)=>e<0?t*e:e);function fP(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;Ie([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=$ie(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var Aie={kernelName:mu,backendName:"cpu",kernelFunc:fP},mP=ct(bu,e=>Math.max(0,e)),Rie={kernelName:bu,backendName:"cpu",kernelFunc:mP},gP=ct(wu,e=>Math.min(Math.max(0,e),6)),Fie={kernelName:wu,backendName:"cpu",kernelFunc:gP};function Wy(e,t,n,r,a){if(n==="linear")return ps({inputs:{x:t},backend:e});if(n==="relu")return mP({inputs:{x:t},backend:e});if(n==="elu")return pP({inputs:{x:t},backend:e});if(n==="relu6")return gP({inputs:{x:t},backend:e});if(n==="prelu")return fP({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return hP({inputs:{x:t},backend:e,attrs:{alpha:a}});if(n==="sigmoid")return nP({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function It(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=k.sizeFromShape(a.shape),o=k.inferFromImplicitShape(s,i),l=k.sizeFromShape(o);k.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(a.dataId);let d=n.data.get(a.dataId);if(d.complexTensorInfos!=null){let u=d.complexTensorInfos.real,c=d.complexTensorInfos.imag;u.shape=o,c.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var Die={kernelName:Xc,backendName:"cpu",kernelFunc:It};function yP(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;Ie([a,s],"matMul");let l=a.shape.length,d=s.shape.length,u=i?a.shape[l-2]:a.shape[l-1],c=o?s.shape[d-1]:s.shape[d-2],p=i?a.shape[l-1]:a.shape[l-2],h=o?s.shape[d-2]:s.shape[d-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=k.sizeFromShape(f),y=k.sizeFromShape(m),b=hp.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([p,h]);k.assert(u===c,()=>`Error in matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let v=i?[g,u,p]:[g,p,u],x=o?[y,h,c]:[y,c,h],w=It({inputs:{x:a},backend:n,attrs:{shape:v}}),I=It({inputs:{x:s},backend:n,attrs:{shape:x}}),N=i?w.shape[1]:w.shape[2],T=i?w.shape[2]:w.shape[1],A=o?I.shape[1]:I.shape[2],R=Math.max(g,y),F=n.data.get(w.dataId).values,C=n.data.get(I.dataId).values,M=k.computeStrides(w.shape),B=k.computeStrides(I.shape),[U,G,X]=i?[M[0],1,M[1]]:[M[0],M[1],1],[P,q,Q]=o?[1,B[1],B[0]]:[B[1],1,B[0]],J=T*A,re=Ve([R,T,A],w.dtype),ae=re.values,ie=n.blockSize;for(let le=0;le<R;le++){let xe=le%g,we=le%y;for(let ge=0;ge<T;ge+=ie){let Ee=Math.min(ge+ie,T);for(let Ae=0;Ae<A;Ae+=ie){let Le=Math.min(Ae+ie,A);for(let He=0;He<N;He+=ie){let pt=Math.min(He+ie,N);for(let Qe=ge;Qe<Ee;Qe++)for(let tt=Ae;tt<Le;tt++){let Me=0;for(let it=He;it<pt;it++){let xt=F[xe*U+Qe*G+it*X],vr=C[it*P+tt*q+we*Q];Me+=xt*vr}ae[le*J+(Qe*A+tt)]+=Me}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(I),n.makeTensorInfo(b,re.dtype,re.values)}var Mie={kernelName:_l,backendName:"cpu",kernelFunc:yP};function Oie(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:d,activation:u,leakyreluAlpha:c}=r,p,h,f,m=[];p=yP({inputs:{a,b:s},attrs:{transposeA:l,transposeB:d},backend:n}),i&&(h=Yd({inputs:{a:p,b:i},backend:n}),m.push(p),p=h),u&&(f=Wy(n,p,u,o,c),m.push(p),p=f);for(let g of m)n.disposeIntermediateTensorInfo(g);return p}var Pie={kernelName:Jo,backendName:"cpu",kernelFunc:Oie},Lie=ct(xl,e=>Math.acos(e)),zie={kernelName:xl,backendName:"cpu",kernelFunc:Lie},Bie=ct(wl,e=>Math.acosh(e)),Wie={kernelName:wl,backendName:"cpu",kernelFunc:Bie};function Uie(e){let{inputs:t,backend:n}=e,r=t;Ie(t,"addN");let a=r.map(o=>n.data.get(o.dataId).values),s=Ve(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let l=a[o];for(let d=0;d<i.length;d++)i[d]+=l[d]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var Vie={kernelName:kl,backendName:"cpu",kernelFunc:Uie};function jie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"all");let o=k.parseAxisParam(s,a.shape),l=o,d=E.getAxesPermutation(l,a.shape.length),u=a;d!=null&&(u=mr({inputs:{x:a},backend:n,attrs:{perm:d}}),l=E.getInnerMostAxes(l.length,a.shape.length)),E.assertAxesAreInnerMostDims("all",l,u.shape.length);let[c,p]=E.computeOutAndReduceShapes(u.shape,l),h=k.sizeFromShape(p),f=k.makeZerosTypedArray(k.sizeFromShape(c),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*h,v=m[b];for(let x=0;x<h;++x){let w=m[b+x];v=v&&w}f[y]=v}d!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(c,u.dtype,f);if(i){let y=E.expandShapeToKeepDim(c,o),b=It({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var Hie={kernelName:pc,backendName:"cpu",kernelFunc:jie};function Gie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"any");let o=k.parseAxisParam(s,a.shape),l=o,d=E.getAxesPermutation(l,a.shape.length),u=a;d!=null&&(u=mr({inputs:{x:a},backend:n,attrs:{perm:d}}),l=E.getInnerMostAxes(l.length,a.shape.length)),E.assertAxesAreInnerMostDims("any",l,u.shape.length);let[c,p]=E.computeOutAndReduceShapes(u.shape,l),h=k.sizeFromShape(p),f=k.makeZerosTypedArray(k.sizeFromShape(c),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*h,v=m[b];for(let x=0;x<h;++x){let w=m[b+x];v=v||w}f[y]=v}d!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(c,u.dtype,f);if(i){let y=E.expandShapeToKeepDim(c,o),b=It({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var qie={kernelName:hc,backendName:"cpu",kernelFunc:Gie};function Kie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;Ie(a,"argMax");let i=k.parseAxisParam(s,a.shape),o=E.getAxesPermutation(i,a.shape.length),l=a,d=[];o!=null&&(l=mr({inputs:{x:a},backend:n,attrs:{perm:o}}),d.push(l),i=E.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],E.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[u,c]=E.computeOutAndReduceShapes(l.shape,i),p=k.sizeFromShape(u),h=k.makeZerosTypedArray(p,"int32"),f=k.sizeFromShape(c),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let y=g*f,b=m[y],v=0;for(let x=0;x<f;++x){let w=m[y+x];w>b&&(b=w,v=x)}h[g]=v}return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(u,"int32",h)}var Xie={kernelName:fc,backendName:"cpu",kernelFunc:Kie};function Qie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;Ie(a,"argMin");let i=k.parseAxisParam(s,a.shape),o=E.getAxesPermutation(i,a.shape.length),l=a,d=[];o!=null&&(l=mr({inputs:{x:a},backend:n,attrs:{perm:o}}),d.push(l),i=E.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],E.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[u,c]=E.computeOutAndReduceShapes(l.shape,i),p=k.sizeFromShape(u),h=k.makeZerosTypedArray(p,"int32"),f=k.sizeFromShape(c),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let y=g*f,b=m[y],v=0;for(let x=0;x<f;++x){let w=m[y+x];w<b&&(b=w,v=x)}h[g]=v}return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(u,"int32",h)}var Jie={kernelName:mc,backendName:"cpu",kernelFunc:Qie},Zie=ct(Sl,e=>Math.asin(e)),Yie={kernelName:Sl,backendName:"cpu",kernelFunc:Zie},eoe=ct(Il,e=>Math.asinh(e)),toe={kernelName:Il,backendName:"cpu",kernelFunc:eoe},noe=ct(Nl,e=>Math.atan(e)),roe={kernelName:Nl,backendName:"cpu",kernelFunc:noe},aoe=Gt((e,t)=>Math.atan2(e,t)),soe=cn(Tl,aoe),ioe={kernelName:Tl,backendName:"cpu",kernelFunc:soe},ooe=ct(Cl,e=>Math.atanh(e)),loe={kernelName:Cl,backendName:"cpu",kernelFunc:ooe};function U2(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,d=a.dilationWidth,u=a.effectiveFilterHeight,c=a.effectiveFilterWidth,p=a.padInfo.top,h=a.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Ve(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){let w=x*y,I=x*r[0];for(let N=0;N<a.inChannels;++N)for(let T=0;T<a.outHeight;++T){let A=T*i-p,R=Math.max(0,A),F=Math.min(a.inHeight,u+A),C=w+T*b;for(let M=0;M<a.outWidth;++M){let B=M*o-h,U=Math.max(0,B),G=Math.min(a.inWidth,c+B),X=f,P=0,q=0;for(let J=R;J<F;J+=l){let re=I+J*r[1];for(let ae=U;ae<G;ae+=d){let ie=re+ae*r[2],le=e[ie+N];s==="max"&&le>X?X=le:s==="avg"&&(P+=le,q++)}if(isNaN(X))break}let Q=C+M*v+N;g[Q]=s==="avg"?P/q:X}}}return m}function bP(e,t,n,r,a=!1,s=!1){let i=Ve(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,d=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,p=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,m=Ve(t,n,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){let v=b*o-h,x=v;for(;x<0;)x+=d;let w=Math.min(r.inHeight,c+v);for(let I=0;I<r.outWidth;++I){let N=I*l-f,T=N;for(;T<0;)T+=u;let A=Math.min(r.inWidth,p+N),R=Number.NEGATIVE_INFINITY,F=-1;for(let C=x;C<w;C+=d){let M=C-v;for(let B=T;B<A;B+=u){let U=B-N,G=m.get(g,C,B,y);G>R&&(R=G,a?F=s?((g*r.inHeight+C)*r.inWidth+B)*r.inChannels+y:(C*r.inWidth+B)*r.inChannels+y:F=M*p+U)}}i.set(F,g,b,I,y)}}return i}function vP(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,d=a.dilationDepth,u=a.dilationHeight,c=a.dilationWidth,p=a.effectiveFilterDepth,h=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Ve(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],I=a.outShape[2]*a.outShape[3]*a.outShape[4],N=a.outShape[3]*a.outShape[4],T=a.outShape[4];for(let A=0;A<a.batchSize;++A){let R=A*w,F=A*r[0];for(let C=0;C<a.inChannels;++C)for(let M=0;M<a.outDepth;++M){let B=M*i-m,U=B;for(;U<0;)U+=d;let G=Math.min(a.inDepth,p+B),X=R+M*I;for(let P=0;P<a.outHeight;++P){let q=P*o-g,Q=q;for(;Q<0;)Q+=u;let J=Math.min(a.inHeight,h+q),re=X+P*N;for(let ae=0;ae<a.outWidth;++ae){let ie=ae*l-y,le=ie;for(;le<0;)le+=c;let xe=Math.min(a.inWidth,f+ie),we=re+ae*T,ge=b,Ee=0,Ae=0;for(let He=U;He<G;He+=d){let pt=F+He*r[1];for(let Qe=Q;Qe<J;Qe+=u){let tt=pt+Qe*r[2];for(let Me=le;Me<xe;Me+=c){let it=tt+Me*r[3],xt=e[it+C];if(s==="max"&&xt>ge?ge=xt:s==="avg"&&(Ee+=xt,Ae++),isNaN(ge))break}if(isNaN(ge))break}if(isNaN(ge))break}let Le=we+C;x[Le]=s==="avg"?Ee/Math.max(Ae,1):ge}}}}return v}function uoe(e,t){let n=Ve(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,d=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-p,v=b;for(;v<0;)v+=i;let x=Math.min(t.inDepth,d+b);for(let w=0;w<t.outHeight;++w){let I=w*a-h,N=I;for(;N<0;)N+=o;let T=Math.min(t.inHeight,u+I);for(let A=0;A<t.outWidth;++A){let R=A*s-f,F=R;for(;F<0;)F+=l;let C=Math.min(t.inWidth,c+R),M=Number.NEGATIVE_INFINITY,B=-1;for(let U=v;U<x;U+=i){let G=U-b;for(let X=N;X<T;X+=o){let P=X-I;for(let q=F;q<C;q+=l){let Q=q-R,J=e.get(m,U,X,q,g);J>=M&&(M=J,B=G*u*c+P*u+Q)}}}n.set(B,m,y,w,A,g)}}}return n}function doe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Ie(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,d=1;k.assert(E.eitherStridesOrDilationsAreOne(i,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let u=E.computePool2DInfo(a.shape,s,i,d,o,l),c;if(u.filterWidth===1&&u.filterHeight===1&&k.arraysEqual(u.inShape,u.outShape))c=ps({inputs:{x:a},backend:n});else{let p=n.data.get(a.dataId).values,h=k.computeStrides(a.shape),f=U2(p,a.shape,a.dtype,h,u,"avg");c=n.makeTensorInfo(u.outShape,a.dtype,f.values)}return c}var coe={kernelName:El,backendName:"cpu",kernelFunc:doe};function poe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:d}=r;Ie(a,"avgPool3d");let u=E.computePool3DInfo(a.shape,s,i,1,o,l,d),c=n.data.get(a.dataId).values,p=vP(c,a.shape,a.dtype,k.computeStrides(a.shape),u,"avg");return n.makeTensorInfo(p.shape,"float32",p.values)}var hoe={kernelName:gc,backendName:"cpu",kernelFunc:poe};function foe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:d}=r;Ie([a,s],"avgPool3DGrad");let u=E.computePool3DInfo(s.shape,i,o,1,l,d),c=u.strideDepth,p=u.strideHeight,h=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,v=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,I=u.effectiveFilterWidth,N=x-1-u.padInfo.front,T=I-1-u.padInfo.left,A=w-1-u.padInfo.top,R=Ve(s.shape,"float32"),F=1/(f*m*g),C=n.bufferSync(a);for(let M=0;M<u.batchSize;++M)for(let B=0;B<u.inChannels;++B)for(let U=0;U<u.inDepth;++U)for(let G=0;G<u.inHeight;++G)for(let X=0;X<u.inWidth;++X){let P=U-N,q=G-A,Q=X-T,J=0;for(let re=0;re<x;re+=y){let ae=(P+re)/c;if(!(ae<0||ae>=u.outDepth||Math.floor(ae)!==ae))for(let ie=0;ie<w;ie+=b){let le=(q+ie)/p;if(!(le<0||le>=u.outHeight||Math.floor(le)!==le))for(let xe=0;xe<I;xe+=v){let we=(Q+xe)/h;if(we<0||we>=u.outWidth||Math.floor(we)!==we)continue;let ge=C.get(M,ae,le,we,B);J+=ge}}}R.set(J*F,M,U,G,X,B)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}var moe={kernelName:If,backendName:"cpu",kernelFunc:foe};function goe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;Ie([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:d}=r,u=E.computePool2DInfo(i.shape,o,l,1,d),c=u.strideHeight,p=u.strideWidth,h=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,v=b-1-u.padInfo.left,x=y-1-u.padInfo.top,w=Ve(i.shape,"float32"),I=1/(h*f),N=n.data.get(a.dataId).values,T=Ve(a.shape,"float32",N);for(let A=0;A<u.batchSize;++A)for(let R=0;R<u.inChannels;++R)for(let F=0;F<u.inHeight;++F)for(let C=0;C<u.inWidth;++C){let M=F-x,B=C-v,U=0;for(let G=0;G<y;G+=m){let X=(M+G)/c;if(!(X<0||X>=u.outHeight||Math.floor(X)!==X))for(let P=0;P<b;P+=g){let q=(B+P)/p;if(q<0||q>=u.outWidth||Math.floor(q)!==q)continue;let Q=T.get(A,X,q,R);U+=Q}}w.set(U*I,A,F,C,R)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var yoe={kernelName:Sf,backendName:"cpu",kernelFunc:goe};function boe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;k.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ie([a,o,l,s,i],"batchNorm");let{varianceEpsilon:d}=r;d==null&&(d=.001);let u=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values,p=n.data.get(l.dataId).values,h=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=h.length,b=p.length,v=c.length,x=0,w=0,I=0,N=0;for(let T=0;T<u.length;++T)m[T]=f[x++]+(u[T]-c[w++])*h[I++]/Math.sqrt(p[N++]+d),x>=g&&(x=0),w>=v&&(w=0),I>=y&&(I=0),N>=b&&(N=0);return n.makeTensorInfo(a.shape,a.dtype,m)}var voe={kernelName:ql,backendName:"cpu",kernelFunc:boe};function xoe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;Ie([a],"batchToSpaceND");let o=s.reduce((y,b)=>y*b),l=E.getReshaped(a.shape,s,o),d=E.getPermuted(l.length,s.length),u=E.getReshapedPermuted(a.shape,s,o),c=E.getSliceBeginCoords(i,s.length),p=E.getSliceSize(u,i,s.length),h=It({inputs:{x:a},backend:n,attrs:{shape:l}}),f=mr({inputs:{x:h},backend:n,attrs:{perm:d}}),m=It({inputs:{x:f},backend:n,attrs:{shape:u}}),g=cl({inputs:{x:m},backend:n,attrs:{begin:c,size:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var woe={kernelName:yc,backendName:"cpu",kernelFunc:xoe};function koe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,d=A2(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,d)}var Soe={kernelName:bc,backendName:"cpu",kernelFunc:koe};function Ioe(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=E.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Noe={kernelName:Nf,backendName:"cpu",kernelFunc:Ioe},Coe=ct(eo,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),Toe={kernelName:eo,backendName:"cpu",kernelFunc:Coe},Eoe=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(k.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let d=0;d<o.length;d++){let u=o[d],c=l[d];r[d]=Math.hypot(u,c)}return n.makeOutput(r,t.shape,"float32")},_oe={kernelName:Cf,backendName:"cpu",kernelFunc:Eoe};function ec(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var $oe={kernelName:Db,backendName:"cpu",kernelFunc:ec};function tc(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=k.parseAxisParam(a,t[0].shape)[0],i=t.map(m=>m.shape);E.assertParamsConsistent(i,s);let o=E.computeOutShape(t.map(m=>m.shape),s);if(k.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(m=>k.sizeFromShape(m.shape)>0);if(l.length===1)return ps({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let m=l.map(x=>dl({inputs:{input:x},backend:n})),g=l.map(x=>ec({inputs:{input:x},backend:n})),y=tc({inputs:m,backend:n,attrs:{axis:s}}),b=tc({inputs:g,backend:n,attrs:{axis:s}}),v=Cr({inputs:{real:y,imag:b},backend:n});return m.forEach(x=>n.disposeIntermediateTensorInfo(x)),g.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),v}let d=l.map(m=>{let g=[-1,k.sizeFromShape(m.shape.slice(s))];return It({inputs:{x:m},backend:n,attrs:{shape:g}})}),u=d.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=E.computeOutShape(d.map(m=>m.shape),1);let c=d[0].shape[0]===1,p=R2(u,o,t[0].dtype,c),h=E.computeOutShape(l.map(m=>m.shape),s),f=n.makeTensorInfo(h,t[0].dtype,p);return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Aoe={kernelName:xc,backendName:"cpu",kernelFunc:tc};function xP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:d,dimRoundingMode:u}=r;Ie([a,s],"conv2d");let c=E.convertConv2DDataFormat(l),p=E.computeConv2DInfo(a.shape,s.shape,i,d,o,u,!1,c),h=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,y=p.padInfo.left,b=p.padInfo.top,v=p.dataFormat==="channelsLast",x=new Yt(p.outShape,a.dtype),w=k.computeStrides(a.shape),I=k.computeStrides(s.shape),N=w[0],T=v?w[1]:w[2],A=v?w[2]:1,R=v?1:w[1],F=x.strides[0],C=v?x.strides[1]:x.strides[2],M=v?x.strides[2]:1,B=v?1:x.strides[1],U=n.data.get(a.dataId).values,G=n.data.get(s.dataId).values,X=x.values;for(let P=0;P<p.batchSize;++P){let q=P*N,Q=P*F;for(let J=0;J<p.outHeight;++J){let re=Q+J*C,ae=J*p.strideHeight-b;for(let ie=0;ie<h;++ie){let le=ae+ie*m;if(le<0||le>=p.inHeight)continue;let xe=ie*I[0],we=q+le*T;for(let ge=0;ge<p.outWidth;++ge){let Ee=re+ge*M,Ae=ge*p.strideWidth-y;for(let Le=0;Le<f;++Le){let He=Ae+Le*g;if(He<0||He>=p.inWidth)continue;let pt=xe+Le*I[1],Qe=we+He*A,tt=pt;for(let Me=0;Me<p.inChannels;++Me){let it=U[Qe+Me*R];for(let xt=0;xt<p.outChannels;++xt)X[Ee+xt*B]+=it*G[tt+xt];tt+=p.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,X)}var Roe={kernelName:Rl,backendName:"cpu",kernelFunc:xP};function Foe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:d,filterShape:u}=r;Ie([a,s],"conv2dBackpropFilter");let c=E.convertConv2DDataFormat(l),p=E.computeConv2DInfo(a.shape,u,i,1,o,d,!1,c),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=p,y=p.dataFormat==="channelsLast",b=new Yt(p.filterShape,"float32"),v=p.padInfo.left,x=p.padInfo.top,w=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,N=new Yt(a.shape,a.dtype,w),T=new Yt(s.shape,s.dtype,I);for(let A=0;A<m;++A){let R=Math.max(0,Math.ceil((x-A)/h)),F=Math.min(p.outHeight,(p.inHeight+x-A)/h);for(let C=0;C<g;++C){let M=Math.max(0,Math.ceil((v-C)/f)),B=Math.min(p.outWidth,(p.inWidth+v-C)/f);for(let U=0;U<p.inChannels;++U)for(let G=0;G<p.outChannels;++G){let X=0;for(let P=0;P<p.batchSize;++P)for(let q=R;q<F;++q){let Q=A+q*h-x;for(let J=M;J<B;++J){let re=C+J*f-v;y?X+=N.get(P,Q,re,U)*T.get(P,q,J,G):X+=N.get(P,U,Q,re)*T.get(P,G,q,J)}}b.set(X,A,C,U,G)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var Doe={kernelName:Tb,backendName:"cpu",kernelFunc:Foe};function Moe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:d,dimRoundingMode:u}=r;Ie([a,s],"conv2dBackpropInput");let c=k.computeStrides(s.shape),p=k.computeStrides(a.shape),h=E.convertConv2DDataFormat(d),f=E.computeConv2DInfo(i,s.shape,o,1,l,u,!1,h),m=new Yt(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=c,{batchSize:I,filterHeight:N,filterWidth:T,inChannels:A,inHeight:R,inWidth:F,outChannels:C,outHeight:M,outWidth:B,strideHeight:U,strideWidth:G}=f;h=f.dataFormat;let X=N-1-f.padInfo.top,P=T-1-f.padInfo.left,q=h==="channelsLast",Q=m.strides[0],J=q?m.strides[1]:m.strides[2],re=q?m.strides[2]:1,ae=q?1:m.strides[1],ie=p[0],le=q?p[1]:p[2],xe=q?p[2]:1,we=q?1:p[1];for(let ge=0;ge<I;++ge)for(let Ee=0;Ee<A;++Ee)for(let Ae=0;Ae<R;++Ae){let Le=Ae-X,He=Math.max(0,Math.ceil(Le/U)),pt=Math.min(M,(N+Le)/U);for(let Qe=0;Qe<F;++Qe){let tt=Qe-P,Me=Math.max(0,Math.ceil(tt/G)),it=Math.min(B,(T+tt)/G),xt=0;for(let Pt=He;Pt<pt;++Pt){let ar=Pt*U-Le;for(let In=Me;In<it;++In){let sr=In*G-tt,ia=ie*ge+le*Pt+xe*In,xr=v*(N-1-ar)+x*(T-1-sr)+w*Ee;for(let ir=0;ir<C;++ir){let Nn=y[ia+we*ir],Wr=b[xr+ir];xt+=Nn*Wr}}}let vr=Q*ge+J*Ae+re*Qe+ae*Ee;g[vr]=xt}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var Ooe={kernelName:Fl,backendName:"cpu",kernelFunc:Moe};function Poe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;Ie([a,s],"conv3d");let d=E.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:u,filterHeight:c,filterWidth:p,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=d,y=g.front,b=g.left,v=g.top,x=new Yt(d.outShape,a.dtype),w=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,N=x.values,T=k.computeStrides(a.shape),A=k.computeStrides(s.shape);for(let R=0;R<d.batchSize;++R){let F=R*T[0],C=R*x.strides[0];for(let M=0;M<d.outDepth;++M){let B=C+M*x.strides[1],U=M*d.strideDepth-y;for(let G=0;G<u;++G){let X=U+G*h;if(X<0||X>=d.inDepth)continue;let P=G*A[0],q=F+X*T[1];for(let Q=0;Q<d.outHeight;++Q){let J=B+Q*x.strides[2],re=Q*d.strideHeight-v;for(let ae=0;ae<c;++ae){let ie=re+ae*f;if(ie<0||ie>=d.inHeight)continue;let le=P+ae*A[1],xe=q+ie*T[2];for(let we=0;we<d.outWidth;++we){let ge=J+we*d.outChannels,Ee=we*d.strideWidth-b;for(let Ae=0;Ae<p;++Ae){let Le=Ee+Ae*m;if(Le<0||Le>=d.inWidth)continue;let He=le+Ae*A[2],pt=xe+Le*d.inChannels,Qe=He;for(let tt=0;tt<d.inChannels;++tt){let Me=w[pt+tt];for(let it=0;it<d.outChannels;++it)N[ge+it]+=Me*I[Qe+it];Qe+=d.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var Loe={kernelName:Dl,backendName:"cpu",kernelFunc:Poe};function zoe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;Ie([a,s],"conv3dBackpropFilterV2");let d=k.computeStrides(a.shape),u=k.computeStrides(s.shape),c=E.computeConv3DInfo(a.shape,l,i,1,o),p=c.strideDepth,h=c.strideHeight,f=c.strideWidth,m=c.filterDepth,g=c.filterHeight,y=c.filterWidth,b=new Yt(c.filterShape,"float32"),v=b.values,[x,w,I,N]=b.strides,T=n.data.get(s.dataId).values,[A,R,F,C]=u,M=n.data.get(a.dataId).values,[B,U,G,X]=d,P=c.padInfo.front,q=c.padInfo.left,Q=c.padInfo.top;for(let J=0;J<m;++J){let re=Math.max(0,Math.ceil((P-J)/p)),ae=Math.min(c.outDepth,(c.inDepth+P-J)/p),ie=J*x;for(let le=0;le<g;++le){let xe=Math.max(0,Math.ceil((Q-le)/h)),we=Math.min(c.outHeight,(c.inHeight+Q-le)/h),ge=le*w+ie;for(let Ee=0;Ee<y;++Ee){let Ae=Math.max(0,Math.ceil((q-Ee)/f)),Le=Math.min(c.outWidth,(c.inWidth+q-Ee)/f),He=Ee*I+ge;for(let pt=0;pt<c.inChannels;++pt){let Qe=pt*N+He;for(let tt=0;tt<c.outChannels;++tt){let Me=0;for(let it=0;it<c.batchSize;++it){let xt=it*B,vr=it*A;for(let Pt=re;Pt<ae;++Pt){let ar=(J+Pt*p-P)*U+xt,In=Pt*R+vr;for(let sr=xe;sr<we;++sr){let ia=(le+sr*h-Q)*G+ar,xr=sr*F+In;for(let ir=Ae;ir<Le;++ir){let Nn=(Ee+ir*f-q)*X+ia,Wr=ir*C+xr;Me+=M[Nn+pt]*T[Wr+tt]}}}}v[Qe+tt]=Me}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var Boe={kernelName:wc,backendName:"cpu",kernelFunc:zoe};function Woe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;Ie([a],"conv3dBackpropInputV2");let d=k.computeStrides(a.shape),u=k.computeStrides(s.shape),c=E.computeConv3DInfo(l,s.shape,o,1,i),p=new Yt(c.inShape,"float32"),h=p.values,[f,m,g,y]=p.strides,b=n.data.get(a.dataId).values,[v,x,w,I]=d,N=n.data.get(s.dataId).values,[T,A,R,F]=u,{batchSize:C,filterDepth:M,filterHeight:B,filterWidth:U,inChannels:G,inDepth:X,inHeight:P,inWidth:q,outChannels:Q,outDepth:J,outHeight:re,outWidth:ae,strideDepth:ie,strideHeight:le,strideWidth:xe}=c,we=M-1-c.padInfo.front,ge=B-1-c.padInfo.top,Ee=U-1-c.padInfo.left;for(let Ae=0;Ae<C;++Ae)for(let Le=0;Le<G;++Le)for(let He=0;He<X;++He){let pt=He-we,Qe=Math.max(0,Math.ceil(pt/ie)),tt=Math.min(J,(M+pt)/ie);for(let Me=0;Me<P;++Me){let it=Me-ge,xt=Math.max(0,Math.ceil(it/le)),vr=Math.min(re,(B+it)/le);for(let Pt=0;Pt<q;++Pt){let ar=Pt-Ee,In=Math.max(0,Math.ceil(ar/xe)),sr=Math.min(ae,(U+ar)/xe),ia=0;for(let xr=Qe;xr<tt;++xr){let ir=xr*ie-pt;for(let Nn=xt;Nn<vr;++Nn){let Wr=Nn*le-it;for(let Xs=In;Xs<sr;++Xs){let Mp=Xs*xe-ar,bs=v*Ae+x*xr+w*Nn+I*Xs,Op=T*(M-1-ir)+A*(B-1-Wr)+R*(U-1-Mp)+F*Le;for(let ja=0;ja<Q;++ja){let Qs=b[bs+ja],Cn=N[Op+ja];ia+=Qs*Cn}}}}h[f*Ae+m*He+g*Me+y*Pt+Le]=ia}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}var Uoe={kernelName:kc,backendName:"cpu",kernelFunc:Woe},Voe=ct(Ml,e=>Math.cos(e)),joe={kernelName:Ml,backendName:"cpu",kernelFunc:Voe},Hoe=ct(Ol,e=>Math.cosh(e)),Goe={kernelName:Ol,backendName:"cpu",kernelFunc:Hoe};function qoe(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:d}=r,[u,c,p,h]=a.shape,f=s.shape[0],[m,g]=o,y=Ve([f,m,g,h],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,w=k.computeStrides(a.shape),I=k.computeStrides(y.shape);for(let N=0;N<f;N++){let T=N*4,A=b[T],R=b[T+1],F=b[T+2],C=b[T+3],M=v[N];if(M>=u)continue;let B=m>1?(F-A)*(c-1)/(m-1):0,U=g>1?(C-R)*(p-1)/(g-1):0;for(let G=0;G<m;G++){let X=m>1?A*(c-1)+G*B:.5*(A+F)*(c-1);if(X<0||X>c-1){for(let P=0;P<g;P++)for(let q=0;q<h;q++){let Q=q+P*I[2]+G*I[1]+N*I[0];y.values[Q]=d}continue}if(l==="bilinear"){let P=Math.floor(X),q=Math.ceil(X),Q=X-P;for(let J=0;J<g;J++){let re=g>1?R*(p-1)+J*U:.5*(R+C)*(p-1);if(re<0||re>p-1){for(let xe=0;xe<h;xe++){let we=xe+J*I[2]+G*I[1]+N*I[0];y.values[we]=d}continue}let ae=Math.floor(re),ie=Math.ceil(re),le=re-ae;for(let xe=0;xe<h;xe++){let we=xe+ae*w[2]+P*w[1]+M*w[0],ge=x[we];we=xe+ie*w[2]+P*w[1]+M*w[0];let Ee=x[we];we=xe+ae*w[2]+q*w[1]+M*w[0];let Ae=x[we];we=xe+ie*w[2]+q*w[1]+M*w[0];let Le=x[we],He=ge+(Ee-ge)*le,pt=Ae+(Le-Ae)*le;we=xe+J*I[2]+G*I[1]+N*I[0],y.values[we]=He+(pt-He)*Q}}}else for(let P=0;P<g;++P){let q=g>1?R*(p-1)+P*U:.5*(R+C)*(p-1);if(q<0||q>p-1){for(let re=0;re<h;re++){let ae=re+P*I[2]+G*I[1]+N*I[0];y.values[ae]=d}continue}let Q=Math.round(q),J=Math.round(X);for(let re=0;re<h;re++){let ae=re+Q*w[2]+J*w[1]+M*w[0],ie=re+P*I[2]+G*I[1]+N*I[0];y.values[ie]=x[ae]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var Koe={kernelName:Ic,backendName:"cpu",kernelFunc:qoe};function Xoe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;Ie(a,"cumprod");let l=E.getAxesPermutation([s],a.shape.length),d=a;l!=null&&(d=mr({inputs:{x:a},backend:n,attrs:{perm:l}}));let u=E.getInnerMostAxes(1,a.shape.length)[0];if(u!==d.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${u}`);let c=ea(d.dtype,"int32"),p=k.makeOnesTypedArray(k.sizeFromShape(d.shape),c),h=n.data.get(d.dataId).values,f=d.shape[d.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<h.length;y+=f)for(let b=0;b<f;b++){let v=m(y,b);if(b===0)p[v]=i?1:h[v];else{let x=m(y,b-1);p[v]=i?h[x]*p[x]:h[v]*p[x]}}let g=n.makeTensorInfo(d.shape,c,p);if(l!=null){let y=E.getUndoAxesPermutation(l),b=mr({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(d),b}return g}var Qoe={kernelName:Sc,backendName:"cpu",kernelFunc:Xoe};function Joe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;Ie(a,"cumsum");let l=E.getAxesPermutation([s],a.shape.length),d=a;l!=null&&(d=mr({inputs:{x:a},backend:n,attrs:{perm:l}}));let u=E.getInnerMostAxes(1,a.shape.length)[0];if(u!==d.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${u}`);let c=ea(d.dtype,"int32"),p=k.makeZerosTypedArray(k.sizeFromShape(d.shape),c),h=n.data.get(d.dataId).values,f=d.shape[d.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<h.length;y+=f)for(let b=0;b<f;b++){let v=m(y,b);if(b===0)p[v]=i?0:h[v];else{let x=m(y,b-1);p[v]=i?h[x]+p[x]:h[v]+p[x]}}let g=n.makeTensorInfo(d.shape,c,p);if(l!=null){let y=E.getUndoAxesPermutation(l),b=mr({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(d),b}return g}var Zoe={kernelName:Pl,backendName:"cpu",kernelFunc:Joe};function Yoe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,u=A2(l,d,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(a.shape.length===2){let l=n.bufferSync(a),d=n.bufferSync(s),u=E3(l,d,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var ele={kernelName:Tf,backendName:"cpu",kernelFunc:Yoe};function tle(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;k.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=a.shape[0],l=a.shape[1],d=a.shape[2],u=a.shape[3],c=l*s,p=d*s,h=u/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*c*p*h),g=0;for(let y=0;y<o;++y)for(let b=0;b<c;++b){let v=Math.floor(b/s),x=b%s;for(let w=0;w<p;++w){let I=Math.floor(w/s),N=w%s,T=(x*s+N)*h;for(let A=0;A<h;++A){let R=A+T+u*(I+d*(v+l*y));m[g++]=f[R]}}}return n.makeTensorInfo([o,c,p,h],a.dtype,m)}var nle={kernelName:Nc,backendName:"cpu",kernelFunc:tle};function wP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:d}=r;Ie([a,s],"depthwiseConv2DNative");let u=k.computeStrides(a.shape),c=k.computeStrides(s.shape),p=l;p==null&&(p=[1,1]),k.assert(E.eitherStridesOrDilationsAreOne(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let h=E.computeConv2DInfo(a.shape,s.shape,i,p,o,d,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=h,v=b.left,x=b.top,w=h.outChannels/h.inChannels,I=new Yt(h.outShape,a.dtype),N=n.data.get(a.dataId).values,T=n.data.get(s.dataId).values,A=I.values;for(let R=0;R<h.batchSize;++R){let F=R*u[0],C=R*I.strides[0];for(let M=0;M<h.outHeight;++M){let B=C+M*I.strides[1],U=M*h.strideHeight-x;for(let G=0;G<f;++G){let X=U+G*g;if(X<0||X>=h.inHeight)continue;let P=G*c[0],q=F+X*u[1];for(let Q=0;Q<h.outWidth;++Q){let J=B+Q*I.strides[2],re=Q*h.strideWidth-v;for(let ae=0;ae<m;++ae){let ie=re+ae*y;if(ie<0||ie>=h.inWidth)continue;let le=P+ae*c[1],xe=q+ie*h.inChannels,we=J,ge=le;for(let Ee=0;Ee<h.inChannels;++Ee){let Ae=N[xe+Ee];for(let Le=0;Le<w;++Le)A[we+Le]+=Ae*T[ge+Le];we+=w,ge+=w}}}}}}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var rle={kernelName:Ll,backendName:"cpu",kernelFunc:wP};function ale(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:d,filterShape:u}=r;Ie([a,s],"depthwiseConv2dNativeBackpropFilter");let c=E.computeConv2DInfo(a.shape,u,i,o,l,d,!0),{strideHeight:p,strideWidth:h,filterHeight:f,filterWidth:m}=c,g=new Yt(c.filterShape,"float32"),y=c.padInfo.left,b=c.padInfo.top,v=c.outChannels/c.inChannels,x=n.data.get(a.dataId).values,w=new Yt(a.shape,a.dtype,x),I=n.data.get(s.dataId).values,N=new Yt(s.shape,s.dtype,I);for(let T=0;T<f;++T){let A=Math.max(0,Math.ceil((b-T)/p)),R=Math.min(c.outHeight,(c.inHeight+b-T)/p);for(let F=0;F<m;++F){let C=Math.max(0,Math.ceil((y-F)/h)),M=Math.min(c.outWidth,(c.inWidth+y-F)/h);for(let B=0;B<c.outChannels;++B){let U=Math.trunc(B/v),G=B%v,X=0;for(let P=0;P<c.batchSize;++P)for(let q=A;q<R;++q){let Q=T+q*p-b;for(let J=C;J<M;++J){let re=F+J*h-y;X+=w.get(P,Q,re,U)*N.get(P,q,J,B)}}g.set(X,T,F,U,G)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var sle={kernelName:Eb,backendName:"cpu",kernelFunc:ale};function ile(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:d,inputShape:u}=r;Ie([a,s],"depthwiseConv2DNativeBackpropInput");let c=k.computeStrides(a.shape),p=k.computeStrides(s.shape),h=E.computeConv2DInfo(u,s.shape,i,o,l,d,!0),f=new Yt(h.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(a.dataId).values,[x,w,I]=c,N=n.data.get(s.dataId).values,[T,A,R]=p,{batchSize:F,filterHeight:C,filterWidth:M,inChannels:B,inHeight:U,inWidth:G,outChannels:X,outHeight:P,outWidth:q,strideHeight:Q,strideWidth:J}=h,re=C-1-h.padInfo.top,ae=M-1-h.padInfo.left,ie=X/B;for(let le=0;le<F;++le)for(let xe=0;xe<B;++xe)for(let we=0;we<U;++we){let ge=we-re,Ee=Math.max(0,Math.ceil(ge/Q)),Ae=Math.min(P,(C+ge)/Q);for(let Le=0;Le<G;++Le){let He=Le-ae,pt=Math.max(0,Math.ceil(He/J)),Qe=Math.min(q,(M+He)/J),tt=0;for(let Me=Ee;Me<Ae;++Me){let it=Me*Q-ge;for(let xt=pt;xt<Qe;++xt){let vr=xt*J-He,Pt=x*le+w*Me+I*xt,ar=T*(C-1-it)+A*(M-1-vr)+R*xe;for(let In=0;In<ie;++In){let sr=xe*ie+In,ia=v[Pt+sr],xr=N[ar+In];tt+=ia*xr}}}m[g*le+y*we+b*Le+xe]=tt}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var ole={kernelName:_b,backendName:"cpu",kernelFunc:ile};function lle(e){let{inputs:t,backend:n}=e,{x:r}=t,a=k.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=Ve([a,a],r.dtype),o=i.values;for(let d=0;d<s.length;d++)o[d*a+d]=s[d];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var ule={kernelName:Ef,backendName:"cpu",kernelFunc:lle},dle={kernelName:zl,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t,d=l.data.get(r.dataId).values,u=r.shape.length,c=l.data.get(a.dataId).values,p=a.shape.length,{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:I,filterWidth:N,dilationHeight:T,dilationWidth:A,outShape:R}=E.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),F=k.sizeFromShape(R),C=R.length,M=k.getArrayFromDType(r.dtype,F);for(let B=0;B<h;++B)for(let U=0;U<y;++U){let G=U*x-v.top;for(let X=0;X<b;++X){let P=X*w-v.left;for(let q=0;q<g;++q){let Q=Number.MIN_SAFE_INTEGER;for(let re=0;re<I;++re){let ae=G+re*T;if(ae>=0&&ae<f)for(let ie=0;ie<N;++ie){let le=P+ie*A;if(le>=0&&le<m){let xe=k.locToIndex([B,ae,le,q],u,k.computeStrides(r.shape)),we=k.locToIndex([re,ie,q],p,k.computeStrides(a.shape)),ge=d[xe]+c[we];ge>Q&&(Q=ge)}}}let J=k.locToIndex([B,U,X,q],C,k.computeStrides(R));M[J]=Q}}}return{dataId:l.write(k.toTypedArray(M,r.dtype),R,r.dtype),shape:R,dtype:r.dtype}}},cle={kernelName:Wd,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,d=t,u=k.toNestedArray(r.shape,d.data.get(r.dataId).values),c=k.toNestedArray(a.shape,d.data.get(a.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:I,dilationHeight:N,dilationWidth:T,outShape:A}=E.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);k.assert(s.rank===A.length,()=>`Error in ${Wd}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let R=k.toNestedArray(A,d.data.get(s.dataId).values),F=k.makeZerosNestedTypedArray(a.shape,a.dtype);for(let C=0;C<p;++C)for(let M=0;M<g;++M){let B=M*v-b.top;for(let U=0;U<y;++U){let G=U*x-b.left;for(let X=0;X<m;++X){let P=Number.MIN_SAFE_INTEGER,q=0,Q=0;for(let J=0;J<w;++J){let re=B+J*N;if(re>=0&&re<h)for(let ae=0;ae<I;++ae){let ie=G+ae*T;if(ie>=0&&ie<f){let le=u[C][re][ie][X]+c[J][ae][X];le>P&&(P=le,q=J,Q=ae)}}}F[q][Q][X]+=R[C][M][U][X]}}}return{dataId:d.write(k.toTypedArray(F,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},ple={kernelName:Bd,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,d=t,u=k.toNestedArray(r.shape,d.data.get(r.dataId).values),c=k.toNestedArray(a.shape,d.data.get(a.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:I,dilationHeight:N,dilationWidth:T,outShape:A}=E.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);k.assert(s.rank===A.length,()=>`Error in ${Bd}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let R=k.toNestedArray(A,d.data.get(s.dataId).values),F=k.makeZerosNestedTypedArray(r.shape,r.dtype);for(let C=0;C<p;++C)for(let M=0;M<g;++M){let B=M*v-b.top;for(let U=0;U<y;++U){let G=U*x-b.left;for(let X=0;X<m;++X){let P=Number.MIN_SAFE_INTEGER,q=B<0?0:B,Q=G<0?0:G;for(let J=0;J<w;++J){let re=B+J*N;if(re>=0&&re<h)for(let ae=0;ae<I;++ae){let ie=G+ae*T;if(ie>=0&&ie<f){let le=u[C][re][ie][X]+c[J][ae][X];le>P&&(P=le,q=re,Q=ie)}}}F[C][q][Q][X]+=R[C][M][U][X]}}}return{dataId:d.write(k.toTypedArray(F,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function hle(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},d=(l==null?void 0:l.alpha)||1,u=(o==null?void 0:o.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let c=s.getContext(u,(o==null?void 0:o.contextAttributes)||{});if(c==null)throw new Error(`Could not get the context with ${u} type.`);let[p,h]=a.shape.slice(0,2),f=a.shape.length===2?1:a.shape[2],m=n.data.get(a.dataId).values,g=a.dtype==="float32"?255:1,y=new Uint8ClampedArray(h*p*4);for(let v=0;v<p*h;++v){let x=[0,0,0,255*d];for(let I=0;I<f;I++){let N=m[v*f+I];if(a.dtype==="float32"){if(N<0||N>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${N}.`)}else if(a.dtype==="int32"&&(N<0||N>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${N}.`);f===1?(x[0]=N*g,x[1]=N*g,x[2]=N*g):x[I]=N*g}let w=v*4;y[w+0]=Math.round(x[0]),y[w+1]=Math.round(x[1]),y[w+2]=Math.round(x[2]),y[w+3]=Math.round(x[3])}s.width=h,s.height=p;let b=new ImageData(y,h,p);return c.putImageData(b,0,0),a}var fle={kernelName:$b,backendName:"cpu",kernelFunc:hle};function bm(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"sum");let o;a.dtype==="bool"?o=ji({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):o=ps({inputs:{x:a},backend:n});let l=o.shape.length,d=k.parseAxisParam(s,o.shape),u=E.getAxesPermutation(d,l),c=d,p=o;u!=null&&(p=mr({inputs:{x:o},backend:n,attrs:{perm:u}}),c=E.getInnerMostAxes(c.length,l)),E.assertAxesAreInnerMostDims("sum",c,p.shape.length);let[h,f]=E.computeOutAndReduceShapes(p.shape,c),m=E.upcastType(p.dtype,"int32"),g=zy(n,h,m),y=k.sizeFromShape(f),b=n.data.get(g.dataId).values,v=n.data.get(p.dataId).values;for(let x=0;x<b.length;++x){let w=x*y,I=0;for(let N=0;N<y;++N)I+=v[w+N];b[x]=I}if(i){let x=E.expandShapeToKeepDim(g.shape,d),w=g;g=It({inputs:{x:g},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(w)}return n.disposeIntermediateTensorInfo(o),u!=null&&n.disposeIntermediateTensorInfo(p),g}var mle={kernelName:Ru,backendName:"cpu",kernelFunc:bm};function gle(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=E.decodeEinsumEquation(a,s.length);E.checkEinsumDimSizes(i.length,l,s);let{path:d,steps:u}=E.getEinsumComputePath(o,l),c=u.length,p=null,h=i.length,f=[];for(let m=0;m<c;++m){for(let g of u[m]){let{permutationIndices:y,expandDims:b}=E.getEinsumPermutation(h,l[g]),v;E.isIdentityPermutation(y)?v=s[g]:(v=mr({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),f.push(v));let x=v.shape.slice();for(let w=0;w<b.length;++w)x.splice(b[w],0,1);k.arraysEqual(v.shape,x)||(v=It({inputs:{x:v},backend:n,attrs:{shape:x}}),f.push(v)),p===null?p=v:(p=jv({inputs:{a:v,b:p},backend:n}),f.push(p))}m<c-1&&(d[m]>=0&&(p=bm({inputs:{x:p},backend:n,attrs:{axis:d[m]-(i.length-h),keepDims:!1}}),f.push(p)),h--)}for(let m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}var yle={kernelName:Ab,backendName:"cpu",kernelFunc:gle};function ble(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;Ie([r,a],"eluGrad");let s=new Float32Array(k.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let d=i[l];d>=0?s[l]=o[l]:s[l]=o[l]*(d+1)}return n.makeTensorInfo(a.shape,"float32",s)}var vle={kernelName:Cc,backendName:"cpu",kernelFunc:ble},xle=E.ERF_P,wle=E.ERF_A1,kle=E.ERF_A2,Sle=E.ERF_A3,Ile=E.ERF_A4,Nle=E.ERF_A5,Cle=ct(Ul,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+xle*n);return t*(1-((((Nle*r+Ile)*r+Sle)*r+kle)*r+wle)*r*Math.exp(-n*n))}),Tle={kernelName:Ul,backendName:"cpu",kernelFunc:Cle};function Uy(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(k.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),It({inputs:{x:a},backend:n,attrs:{shape:o}})}var Ele={kernelName:Ec,backendName:"cpu",kernelFunc:Uy},_le=Gt((e,t)=>e/t),V2=cn(Bl,_le),Qw={kernelName:Bl,backendName:"cpu",kernelFunc:V2};function kP(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,d=[a,s],u=k.sizeFromShape(d),c=k.getTypedArrayFromDType("float32",u),p=k.getTypedArrayFromDType("float32",u);for(let g=0;g<a;g++){let y=cl({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),b=cl({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),v=Cr({inputs:{real:y,imag:b},backend:n}),{real:x,imag:w}=$le(v,t,n),I=E.mergeRealAndImagArrays(x,w);for(let N=0;N<s;N++){let T=E.getComplexWithIndex(I,N);c[g*s+N]=T.real,p[g*s+N]=T.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v)}let h=n.makeTensorInfo(d,"float32",c),f=n.makeTensorInfo(d,"float32",p),m=Cr({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}function $le(e,t,n){let r=k.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(Ale(r)){let o=Jw(s,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let d=n.makeTensorInfo(l,"float32",o.real),u=n.makeTensorInfo(l,"float32",o.imag),c=n.makeTensorInfo([],"float32",k.createScalarValue(r,"float32")),p=ps({inputs:{x:c},backend:n}),h=Qw.kernelFunc({inputs:{a:d,b:c},backend:n}),f=Qw.kernelFunc({inputs:{a:u,b:p},backend:n}),m=n.data.get(h.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{let o=E.mergeRealAndImagArrays(s,i),l=Rle(o,r,t);return E.splitRealAndImagArrays(l)}}function Ale(e){return(e&e-1)===0}function Jw(e,t,n,r,a){if(n===1)return{real:e,imag:t};let s=E.mergeRealAndImagArrays(e,t),i=n/2,o=E.complexWithEvenIndex(s),l=o.real,d=o.imag,u=[l.length],c=a.makeTensorInfo(u,"float32",l),p=a.makeTensorInfo(u,"float32",d),h=Cr({inputs:{real:c,imag:p},backend:a}),f=E.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),v=a.makeTensorInfo(y,"float32",g),x=Cr({inputs:{real:b,imag:v},backend:a}),w=Jw(l,d,i,r,a),I=w.real,N=w.imag,T=[I.length],A=a.makeTensorInfo(T,"float32",I),R=a.makeTensorInfo(T,"float32",N),F=Cr({inputs:{real:A,imag:R},backend:a}),C=Jw(m,g,i,r,a),M=C.real,B=C.imag,U=[M.length],G=a.makeTensorInfo(U,"float32",M),X=a.makeTensorInfo(U,"float32",B),P=Cr({inputs:{real:G,imag:X},backend:a}),q=E.exponents(n,r),Q=[q.real.length],J=a.makeTensorInfo(Q,"float32",q.real),re=a.makeTensorInfo(Q,"float32",q.imag),ae=Cr({inputs:{real:J,imag:re},backend:a}),ie=jv({inputs:{a:ae,b:P},backend:a}),le=Yd({inputs:{a:F,b:ie},backend:a}),xe=B2({inputs:{a:F,b:ie},backend:a}),we=dl({inputs:{input:le},backend:a}),ge=dl({inputs:{input:xe},backend:a}),Ee=ec({inputs:{input:le},backend:a}),Ae=ec({inputs:{input:xe},backend:a}),Le=tc({inputs:[we,ge],backend:a,attrs:{axis:0}}),He=tc({inputs:[Ee,Ae],backend:a,attrs:{axis:0}}),pt=a.data.get(Le.dataId).values,Qe=a.data.get(He.dataId).values;return a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(X),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(J),a.disposeIntermediateTensorInfo(re),a.disposeIntermediateTensorInfo(ae),a.disposeIntermediateTensorInfo(ie),a.disposeIntermediateTensorInfo(le),a.disposeIntermediateTensorInfo(xe),a.disposeIntermediateTensorInfo(we),a.disposeIntermediateTensorInfo(Ee),a.disposeIntermediateTensorInfo(ge),a.disposeIntermediateTensorInfo(Ae),a.disposeIntermediateTensorInfo(Le),a.disposeIntermediateTensorInfo(He),{real:pt,imag:Qe}}function Rle(e,t,n){let r=new Float32Array(t*2);for(let a=0;a<t;a++){let s=0,i=0;for(let o=0;o<t;o++){let l=E.exponent(a*o,t,n),d=E.getComplexWithIndex(e,o);s+=d.real*l.real-d.imag*l.imag,i+=d.real*l.imag+d.imag*l.real}n&&(s/=t,i/=t),E.assignToTypedArray(r,s,i,a)}return r}function Fle(e){let{inputs:t,backend:n}=e,{input:r}=t,a=k.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=It({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=kP(o,!1,n),d=It({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),d}var Dle={kernelName:Rb,backendName:"cpu",kernelFunc:Fle};function j2(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||k.inferDtype(a),o=k.getArrayFromDType(i,k.sizeFromShape(r));return Ole(o,a),t.makeTensorInfo(r,i,o)}var Mle={kernelName:_f,backendName:"cpu",kernelFunc:j2};function Ole(e,t,n){e.fill(t)}var Ple={kernelName:_c,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,s=k.getTypedArrayFromDType(r.dtype,k.sizeFromShape(r.shape)),[i,o,l,d]=r.shape,u=a.data.get(r.dataId).values;for(let c=0;c<i;c++){let p=c*l*o*d;for(let h=0;h<o;h++){let f=h*(l*d);for(let m=0;m<l;m++){let g=m*d;for(let y=0;y<d;y++){let b=Math.round(l-m-1),v=p+f+g+y,x=u[v];if(b>=0&&b<l){let w=b*d,I=p+f+w+y;x=u[I]}s[v]=x}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Lle(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:d,dataFormat:u,dilations:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=xP({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:d,dataFormat:u,dilations:c,dimRoundingMode:p}});if(i){let g=m;if(u==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=It({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=Yd({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=Yd({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(h){let g=m;if(u==="NCHW"&&h==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let y=It({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=Wy(n,m,h,y,f),n.disposeIntermediateTensorInfo(y)}else m=Wy(n,m,h,o,f);n.disposeIntermediateTensorInfo(g)}return m}var zle={kernelName:Zo,backendName:"cpu",kernelFunc:Lle};function Ble(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:d,dataFormat:u,dilations:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=wP({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:d,dataFormat:u,dilations:c,dimRoundingMode:p}});if(i){let g=m;m=Yd({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(h){let g=m;m=Wy(n,m,h,o,f),n.disposeIntermediateTensorInfo(g)}return m}var Wle={kernelName:Yo,backendName:"cpu",kernelFunc:Ble};function Ule(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=k.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,d,u,c]=E.prepareAndValidate(r,a);if(d===0)return n.makeTensorInfo(l,r.dtype,[]);let p=n.data.get(a.dataId).values,h=n.bufferSync(r),f=L3(p,h,r.dtype,d,o,u,c,r.shape,s);return n.makeTensorInfo(l,r.dtype,f.values)}var Vle={kernelName:Ac,backendName:"cpu",kernelFunc:Ule};function jle(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;Ie([a,s],"gatherV2");let l=k.parseAxisParam(i,a.shape)[0],d=n.data.get(s.dataId).values,u=a.shape[l];for(let x=0;x<d.length;++x){let w=d[x];k.assert(w<=u-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${u-1}]`)}let c=o;o==null&&(c=0);let p=k.sizeFromShape(s.shape),h=E.segment_util.collectGatherOpShapeInfo(a,s,l,c),f=It({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=It({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,p/h.batchSize]}}),g=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),v=z3(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(h.outputShape,v.dtype,v.values)}var Hle={kernelName:$c,backendName:"cpu",kernelFunc:jle};function Gle(e){let{inputs:t,backend:n}=e,{input:r}=t,a=k.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=It({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=kP(o,!0,n),d=It({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),d}var qle={kernelName:Fb,backendName:"cpu",kernelFunc:Gle},Kle=ct(Ql,e=>Number.isFinite(e)?1:0,"bool"),Xle={kernelName:Ql,backendName:"cpu",kernelFunc:Kle},Qle=ct(Jl,e=>Math.abs(e)===1/0?1:0,"bool"),Jle={kernelName:Jl,backendName:"cpu",kernelFunc:Qle},Zle=ct(Zl,e=>Number.isNaN(e)?1:0,"bool"),Yle={kernelName:Zl,backendName:"cpu",kernelFunc:Zle};function eue(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=j3(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var tue={kernelName:Mc,backendName:"cpu",kernelFunc:eue},nue=ct(tu,e=>Math.log1p(e)),rue={kernelName:tu,backendName:"cpu",kernelFunc:nue},aue=Gt((e,t)=>e&&t),sue=cn(Oc,aue,null,"bool"),iue={kernelName:Oc,backendName:"cpu",kernelFunc:sue},oue=ct(Pc,e=>e?0:1,"bool"),lue={kernelName:Pc,backendName:"cpu",kernelFunc:oue},uue=Gt((e,t)=>e||t),due=cn(Lc,uue,null,"bool"),cue={kernelName:Lc,backendName:"cpu",kernelFunc:due};function pue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;Ie(a,"LRN");let d=a.shape[3],u=d-1,c=n.data.get(a.dataId).values,p=k.sizeFromShape(a.shape),h=new Float32Array(p);function f(m){let g=m%d,y=m-g+Math.max(0,g-s),b=m-g+Math.min(g+s,u),v=0;for(;y<=b;y++){let x=c[y];v+=x*x}return v}for(let m=0;m<p;m++){let g=f(m),y=c[m]*Math.pow(i+o*g,-l);h[m]=y}return n.makeTensorInfo(a.shape,a.dtype,h)}var hue={kernelName:nu,backendName:"cpu",kernelFunc:pue};function fue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:d,beta:u}=r;Ie(i,"LRNGrad");let c=k.sizeFromShape(i.shape),p=i.shape[3],h=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(c),y=c;for(let b=0;b<y;b++){let v=b%p,x=b-v+Math.max(0,v-o),w=b-v+Math.min(p,v+o+1),I=0;for(let N=x;N<w;N++)I+=Math.pow(f[N],2);I=d*I+l;for(let N=x;N<w;N++){let T=-2*d*u*f[N]*m[b]/I;b===N&&(T+=Math.pow(I,-u)),T*=h[b],g[N]+=T}}return n.makeTensorInfo(i.shape,a.dtype,g)}var mue={kernelName:zc,backendName:"cpu",kernelFunc:fue};function SP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,d=l.length,u=k.parseAxisParam(s,l),c=u,p=E.getAxesPermutation(c,d),h=o.data.get(a.dataId).values;if(p!=null){let x=new Array(d);for(let w=0;w<x.length;w++)x[w]=l[p[w]];h=D2(h,l,a.dtype,p,x),c=E.getInnerMostAxes(c.length,d),l=x}Ie(a,"max"),E.assertAxesAreInnerMostDims("max",c,d);let[f,m]=E.computeOutAndReduceShapes(l,c),g=k.sizeFromShape(m),y=G3(h,g,f,a.dtype),b=o.write(y,f,a.dtype),v=f;return i&&(v=E.expandShapeToKeepDim(f,u)),{dataId:b,shape:v,dtype:a.dtype}}var gue={kernelName:ru,backendName:"cpu",kernelFunc:SP};function yue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Ie(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,d=1;k.assert(E.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let u=E.computePool2DInfo(a.shape,s,i,d,o,l),c;if(u.filterWidth===1&&u.filterHeight===1&&k.arraysEqual(u.inShape,u.outShape))c=ps({inputs:{x:a},backend:n});else{let p=n.data.get(a.dataId).values,h=k.computeStrides(a.shape),f=U2(p,a.shape,a.dtype,h,u,"max");c=n.makeTensorInfo(u.outShape,a.dtype,f.values)}return c}var bue={kernelName:su,backendName:"cpu",kernelFunc:yue};function vue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:d}=r;Ie(a,"maxPool3d");let u=E.computePool3DInfo(a.shape,s,i,1,o,l,d),c=n.data.get(a.dataId).values,p=vP(c,a.shape,a.dtype,k.computeStrides(a.shape),u,"max");return n.makeTensorInfo(p.shape,"float32",p.values)}var xue={kernelName:Bc,backendName:"cpu",kernelFunc:vue};function wue(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:d}=r;Ie([a,s],"maxPool3DGrad");let u=E.computePool3DInfo(s.shape,i,o,1,l,d),c=n.bufferSync(s),p=uoe(c,u),h=u.strideDepth,f=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,v=u.effectiveFilterDepth,x=u.effectiveFilterHeight,w=u.effectiveFilterWidth,I=v-1-u.padInfo.front,N=w-1-u.padInfo.left,T=x-1-u.padInfo.top,A=Ve(s.shape,"float32"),R=n.bufferSync(a);for(let F=0;F<u.batchSize;++F)for(let C=0;C<u.inChannels;++C)for(let M=0;M<u.inDepth;++M)for(let B=0;B<u.inHeight;++B)for(let U=0;U<u.inWidth;++U){let G=M-I,X=B-T,P=U-N,q=0;for(let Q=0;Q<v;Q+=g){let J=(G+Q)/h;if(!(J<0||J>=u.outDepth||Math.floor(J)!==J))for(let re=0;re<x;re+=y){let ae=(X+re)/f;if(!(ae<0||ae>=u.outHeight||Math.floor(ae)!==ae))for(let ie=0;ie<w;ie+=b){let le=(P+ie)/m;if(le<0||le>=u.outWidth||Math.floor(le)!==le)continue;let xe=v*x*w-1-p.get(F,J,ae,le,C),we=Q*x*w+re*w+ie,ge=xe===we?1:0;if(ge===0)continue;let Ee=R.get(F,J,ae,le,C);q+=Ee*ge}}}A.set(q,F,M,B,U,C)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}var kue={kernelName:Af,backendName:"cpu",kernelFunc:wue};function Sue(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;Ie([s,i],"maxPoolGrad");let{filterSize:l,strides:d,pad:u,dimRoundingMode:c}=r,p=E.computePool2DInfo(o.shape,l,d,1,u,c),h=n.data.get(o.dataId).values,f=Ve(p.outShape,o.dtype,bP(h,o.shape,o.dtype,p).values),m=p.strideHeight,g=p.strideWidth,y=p.dilationHeight,b=p.dilationWidth,v=p.effectiveFilterHeight,x=p.effectiveFilterWidth,w=x-1-p.padInfo.left,I=v-1-p.padInfo.top,N=Ve(o.shape,"float32"),T=n.data.get(a.dataId).values,A=Ve(a.shape,"float32",T);for(let R=0;R<p.batchSize;++R)for(let F=0;F<p.inChannels;++F)for(let C=0;C<p.inHeight;++C)for(let M=0;M<p.inWidth;++M){let B=C-I,U=M-w,G=0;for(let X=0;X<v;X+=y){let P=(B+X)/m;if(!(P<0||P>=p.outHeight||Math.floor(P)!==P))for(let q=0;q<x;q+=b){let Q=(U+q)/g;if(Q<0||Q>=p.outWidth||Math.floor(Q)!==Q)continue;let J=v*x-1-f.get(R,P,Q,F),re=X*x+q,ae=J===re?1:0;if(ae===0)continue;let ie=A.get(R,P,Q,F);G+=ie*ae}}N.set(G,R,C,M,F)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var Iue={kernelName:$f,backendName:"cpu",kernelFunc:Sue};function Nue(e,t,n,r,a){let s=k.computeStrides(t),i=U2(e,t,n,s,a,"max"),o=bP(e,t,n,a,!0,r);return[i.values,o.values]}var Cue={kernelName:Rf,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;Ie(r,"MaxPoolWithArgmax");let d=l.data.get(r.dataId).values,u=E.computePool2DInfo(r.shape,a,s,[1,1],i),[c,p]=Nue(d,r.shape,r.dtype,o,u),h=l.write(c,u.outShape,r.dtype),f=l.write(p,u.outShape,r.dtype);return[{dataId:h,shape:u.outShape,dtype:r.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};function Tue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=k.parseAxisParam(s,a.shape),l=E.computeOutAndReduceShapes(a.shape,o)[1],d=k.sizeFromShape(l),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([d]));u.push(c);let p=ji({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});u.push(p);let h=V2({inputs:{a:p,b:c},backend:n});u.push(h);let f=bm({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:i}});return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Eue={kernelName:iu,backendName:"cpu",kernelFunc:Tue};function _ue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;Ie(a,"min");let o=k.parseAxisParam(s,a.shape),l=o,d=E.getAxesPermutation(l,a.shape.length),u=a;d!=null&&(u=mr({inputs:{x:a},backend:n,attrs:{perm:d}}),l=E.getInnerMostAxes(l.length,a.shape.length)),E.assertAxesAreInnerMostDims("min",l,u.shape.length);let[c,p]=E.computeOutAndReduceShapes(u.shape,l),h=k.sizeFromShape(p),f=k.makeZerosTypedArray(k.sizeFromShape(c),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*h,v=m[b];for(let x=0;x<h;++x){let w=m[b+x];(Number.isNaN(w)||w<v)&&(v=w)}f[y]=v}d!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(c,u.dtype,f);if(i){let y=E.expandShapeToKeepDim(c,o),b=It({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var $ue={kernelName:ou,backendName:"cpu",kernelFunc:_ue};function Aue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;Ie(a,"mirrorPad");let o=s.map((b,v)=>b[0]+a.shape[v]+b[1]),l=s.map(b=>b[0]),d=s.map((b,v)=>b[0]+a.shape[v]),u=i==="reflect"?0:1,c=n.data.get(a.dataId).values,p=a.shape.length,h=k.computeStrides(a.shape),f=k.sizeFromShape(o),m=o.length,g=k.computeStrides(o),y=k.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let v=k.indexToLoc(b,m,g);for(let w=0;w<m;w++)v[w]<l[w]?v[w]=l[w]*2-v[w]-u:v[w]>=d[w]&&(v[w]=(d[w]-1)*2-v[w]+u);v=v.map((w,I)=>w-l[I]);let x=k.locToIndex(v,p,h);y[b]=c[x]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}var Rue={kernelName:uu,backendName:"cpu",kernelFunc:Aue},Fue=Gt((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),Due=cn(du,Fue),Mue={kernelName:du,backendName:"cpu",kernelFunc:Due},Oue=Zi(kb());function IP(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=k.parseAxisParam([o],a.shape),d=SP({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=E.expandShapeToKeepDim(d.shape,l),c=It({inputs:{x:d},backend:n,attrs:{shape:u}}),p=B2({inputs:{a,b:c},backend:n}),h=D3({inputs:{x:p},backend:n}),f=bm({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),m=It({inputs:{x:f},backend:n,attrs:{shape:u}}),g=V2({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var Pue={kernelName:Fu,backendName:"cpu",kernelFunc:IP};function Lue(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;Ie(a,"multinomial");let l=o?a:IP({inputs:{logits:a},backend:n,attrs:{dim:-1}}),d=l.shape[0],u=l.shape[1],c=n.data.get(l.dataId).values,p=[d,s],h=k.makeZerosTypedArray(k.sizeFromShape(p),"int32");for(let f=0;f<d;++f){let m=f*u,g=new Float32Array(u-1);g[0]=c[m];for(let v=1;v<g.length;++v)g[v]=g[v-1]+c[m+v];let y=Oue.alea(i.toString()),b=f*s;for(let v=0;v<s;++v){let x=y();h[b+v]=g.length;for(let w=0;w<g.length;w++)if(x<g[w]){h[b+v]=w;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",h)}var zue={kernelName:Wc,backendName:"cpu",kernelFunc:Lue},Bue=gs.nonMaxSuppressionV3Impl;function Wue(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;Ie(a,"NonMaxSuppression");let d=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:c}=Bue(d,u,i,o,l);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}var Uue={kernelName:jc,backendName:"cpu",kernelFunc:Wue},Vue=gs.nonMaxSuppressionV4Impl;function jue(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:d}=r;Ie(a,"NonMaxSuppressionPadded");let u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:p,validOutputs:h}=Vue(u,c,i,o,l,d);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var Hue={kernelName:Hc,backendName:"cpu",kernelFunc:jue},Gue=gs.nonMaxSuppressionV5Impl;function que(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:d}=r;Ie(a,"NonMaxSuppressionWithScore");let u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,p=i,h=o,f=l,m=d,{selectedIndices:g,selectedScores:y}=Gue(u,c,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var Kue={kernelName:Gc,backendName:"cpu",kernelFunc:que};function Xue(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;Ie(a,"oneHot");let d=k.sizeFromShape(a.shape),u=new Float32Array(d*i);u.fill(l);let c=n.data.get(a.dataId).values;for(let p=0;p<d;++p)c[p]>=0&&c[p]<i&&(u[p*i+c[p]]=o);return n.makeTensorInfo([...a.shape,i],s,u)}var Que={kernelName:pu,backendName:"cpu",kernelFunc:Xue};function Vy(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let a=dl({inputs:{input:r},backend:n}),s=Vy({inputs:{x:a},backend:n}),i=ec({inputs:{input:r},backend:n}),o=Vy({inputs:{x:i},backend:n}),l=Cr({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return j2({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var Jue={kernelName:cp,backendName:"cpu",kernelFunc:Vy};function NP(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let a=dl({inputs:{input:r},backend:n}),s=NP({inputs:{x:a},backend:n}),i=ec({inputs:{input:r},backend:n}),o=Vy({inputs:{x:i},backend:n}),l=Cr({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return j2({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var Zue={kernelName:qc,backendName:"cpu",kernelFunc:NP};function CP(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return Uy({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{k.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),k.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let c=Uy({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(c),c}),d=tc({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),d}var Yue={kernelName:Kc,backendName:"cpu",kernelFunc:CP};function ede(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;Ie(a,"pad");let o=s.map((y,b)=>y[0]+a.shape[b]+y[1]),l=s.map(y=>y[0]),d=n.data.get(a.dataId).values,u=k.sizeFromShape(a.shape),c=a.shape.length,p=k.computeStrides(a.shape),h=k.sizeFromShape(o),f=o.length,m=k.computeStrides(o),g=k.getTypedArrayFromDType(a.dtype,h);i!==0&&g.fill(i);for(let y=0;y<u;y++){let b=k.indexToLoc(y,c,p).map((x,w)=>x+l[w]),v=k.locToIndex(b,f,m);g[v]=d[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}var TP={kernelName:hu,backendName:"cpu",kernelFunc:ede},tde=Gt((e,t)=>Math.pow(e,t)),nde=cn(fu,tde),rde={kernelName:fu,backendName:"cpu",kernelFunc:nde};function ade(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(y=>n.data.get(y.dataId).values),d=a.map(y=>y.shape),u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values,[p,h,f]=Z3(l,d,u,s.shape,s.dtype,c,i.shape),m=p.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,s.dtype,h);return m.concat([g])}var sde={kernelName:Mb,backendName:"cpu",kernelFunc:ade};function ide(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[d,u]=Y3(i,r.shape,r.dtype,o,a.shape,l,s.shape),c=n.makeTensorInfo([d.length],"int32",d),p=n.makeTensorInfo([u.length],r.dtype,u);return[c,p]}var ode={kernelName:Ob,backendName:"cpu",kernelFunc:ide};function lde(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,d=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values,p=o.map(g=>n.data.get(g.dataId).values),h=o.map(g=>g.shape),[f,m]=eP(d,a.shape,u,s.shape,s.dtype,c,i.shape,p,h,l);return n.makeTensorInfo(f,s.dtype,m)}var ude={kernelName:Pb,backendName:"cpu",kernelFunc:lde};function dde(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=M2(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}var cde={kernelName:Ff,backendName:"cpu",kernelFunc:dde},pde=ct(yu,e=>1/e),hde={kernelName:yu,backendName:"cpu",kernelFunc:pde};function fde(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;Ie(a,"resizeBilinear");let l=k.computeStrides(a.shape),[d,u]=o,[c,p,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(k.sizeFromShape([c,d,u,f])),y=[s&&d>1?p-1:p,s&&u>1?h-1:h],b=[s&&d>1?d-1:d,s&&u>1?u-1:u],v=0,x=y[0]/b[0],w=y[1]/b[1];for(let I=0;I<c;I++)for(let N=0;N<d;N++){let T;i?T=x*(N+.5)-.5:T=x*N;let A=Math.max(0,Math.floor(T)),R=T-A,F=Math.min(p-1,Math.ceil(T)),C=I*l[0]+A*l[1],M=I*l[0]+F*l[1];for(let B=0;B<u;B++){let U;i?U=w*(B+.5)-.5:U=w*B;let G=Math.max(0,Math.floor(U)),X=U-G,P=Math.min(h-1,Math.ceil(U)),q=C+G*l[2],Q=M+G*l[2],J=C+P*l[2],re=M+P*l[2];for(let ae=0;ae<f;ae++){let ie=m[q+ae],le=m[Q+ae],xe=m[J+ae],we=m[re+ae],ge=ie+(xe-ie)*X,Ee=le+(we-le)*X,Ae=ge+(Ee-ge)*R;g[v++]=Ae}}}return n.makeTensorInfo([c,d,u,f],"float32",g)}var mde={kernelName:xu,backendName:"cpu",kernelFunc:fde};function gde(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;Ie([s,a],"resizeBilinearGrad");let o=k.computeStrides(a.shape),[l,d,u,c]=a.shape,[,p,h]=s.shape,f=new Float32Array(l*d*u*c),m=[i&&p>1?d-1:d,i&&h>1?u-1:u],g=[i&&p>1?p-1:p,i&&h>1?h-1:h],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values,x=0;for(let w=0;w<l;w++){let I=w*o[0];for(let N=0;N<p;N++){let T=N*y,A=Math.floor(T),R=Math.min(Math.ceil(T),d-1),F=I+A*o[1],C=I+R*o[1],M=T-A,B=1-M;for(let U=0;U<h;U++){let G=U*b,X=Math.floor(G),P=Math.min(Math.ceil(G),u-1),q=G-X,Q=1-q,J=F+X*o[2],re=F+P*o[2],ae=C+X*o[2],ie=C+P*o[2],le=B*Q,xe=B*q,we=M*Q,ge=M*q;for(let Ee=0;Ee<c;Ee++){let Ae=v[x++];f[J+Ee]+=Ae*le,f[re+Ee]+=Ae*xe,f[ae+Ee]+=Ae*we,f[ie+Ee]+=Ae*ge}}}}return n.makeTensorInfo([l,u,d,c],"float32",f)}var yde={kernelName:Jc,backendName:"cpu",kernelFunc:gde};function bde(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;Ie(a,"resizeNearestNeighbor");let l=k.computeStrides(a.shape),[d,u]=o,[c,p,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(c*d*u*f),y=[s&&d>1?p-1:p,s&&u>1?h-1:h],b=[s&&d>1?d-1:d,s&&u>1?u-1:u],v=y[0]/b[0],x=y[1]/b[1],w=0;for(let I=0;I<c;I++){let N=I*l[0];for(let T=0;T<d;T++){let A=i?v*(T+.5):v*T,R=Math.min(p-1,s?Math.round(A):Math.floor(A));i&&(R=Math.max(0,R));let F=N+R*l[1];for(let C=0;C<u;C++){let M=i?x*(C+.5):x*C,B=Math.min(h-1,s?Math.round(M):Math.floor(M));i&&(B=Math.max(0,B));let U=F+B*l[2];for(let G=0;G<f;G++){let X=m[U+G];g[w++]=X}}}}return n.makeTensorInfo([c,d,u,f],a.dtype,g)}var vde={kernelName:vu,backendName:"cpu",kernelFunc:bde};function xde(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;Ie([s,a],"resizeNearestNeighborGrad");let o=k.computeStrides(a.shape),l=k.computeStrides(s.shape),[d,u,c,p]=a.shape,[,h,f]=s.shape,m=new Float32Array(d*u*c*p),g=n.data.get(s.dataId).values,y=[i&&h>1?u-1:u,i&&f>1?c-1:c],b=[i&&h>1?h-1:h,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,I=1/x,N=Math.ceil(w)*2+2,T=Math.ceil(I)*2+2;for(let A=0;A<d;A++){let R=A*o[0];for(let F=0;F<u;F++){let C=R+F*o[1],M=Math.floor(F*w),B=Math.floor(M-N/2);for(let U=0;U<c;U++){let G=C+U*o[2],X=Math.floor(U*I),P=Math.floor(X-T/2);for(let q=0;q<p;q++){let Q=0;for(let J=0;J<N;J++){let re=J+B;if(re<0||re>=h)continue;let ae=R+re*l[1],ie=re*v,le=Math.min(u-1,i?Math.round(ie):Math.floor(ie));if(F===le)for(let xe=0;xe<T;xe++){let we=xe+P;if(we<0||we>=f)continue;let ge=ae+we*l[2],Ee=we*x,Ae=Math.min(c-1,i?Math.round(Ee):Math.floor(Ee));U===Ae&&(Q+=g[ge+q])}}m[G+q]=Q}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}var wde={kernelName:Qc,backendName:"cpu",kernelFunc:xde};function kde(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;Ie(a,"reverse");let i=a.shape.length,o=k.parseAxisParam(s,a.shape);if(i===0)return ps({inputs:{x:a},backend:n});let l=new Yt(a.shape,a.dtype),d=n.bufferSync(a);for(let u=0;u<l.size;u++){let c=l.indexToLoc(u),p=c.slice();o.forEach(h=>p[h]=a.shape[h]-1-p[h]),l.set(d.get(...p),...c)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var Sde={kernelName:ku,backendName:"cpu",kernelFunc:kde},Ide={kernelName:pp,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=k.getTypedArrayFromDType(r.dtype,k.sizeFromShape(r.shape)),[d,u,c,p]=r.shape,[h,f]=E.getImageCenter(i,u,c),m=255,g=Math.sin(a),y=Math.cos(a),b=o.data.get(r.dataId).values;for(let v=0;v<d;v++){let x=v*c*u*p;for(let w=0;w<u;w++){let I=w*(c*p);for(let N=0;N<c;N++){let T=N*p;for(let A=0;A<p;A++){let R=[d,w,N,A],F=R[2],C=R[1],M=(F-h)*y-(C-f)*g,B=(F-h)*g+(C-f)*y;M=Math.round(M+h),B=Math.round(B+f);let U=s;if(typeof s!="number"&&(A===3?U=m:U=s[A]),M>=0&&M<c&&B>=0&&B<u){let X=B*(c*p),P=M*p,q=x+X+P+A;U=b[q]}let G=x+I+T+A;l[G]=U}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Nde=ct(Su,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),Cde={kernelName:Su,backendName:"cpu",kernelFunc:Nde};function Tde(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:d,strides:u,outputSize:c}=E.calculateShapes(s,a,i),p=!0,h=n.bufferSync(a),f=n.bufferSync(s),m=Oo(h,f,i,c,d,l,o,u,0,p);return n.makeTensorInfo(i,m.dtype,m.values)}var Ede={kernelName:Zc,backendName:"cpu",kernelFunc:Tde};function _de(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function $de(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}function Ade(e,t,n,r,a,s){let i=k.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let l=e.slice(o*r,(o+1)*r),d=o*a;for(let u=0;u<a;++u)i[d+u]=s==="left"?_de(l,t[u+d]):$de(l,t[u+d])}return i}function Rde(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,d=Ade(o,l,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",d)}var Fde={kernelName:ep,backendName:"cpu",kernelFunc:Rde};function Dde(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;Ie([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,u=ea(a.dtype,s.dtype),c=k.makeZerosTypedArray(k.sizeFromShape(a.shape),u),p=0,h=i===0||i>1||a.shape.length===1?1:k.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<h;m++)o[f]===1?c[p++]=l[f]:c[p++]=d[f];return n.makeTensorInfo(a.shape,u,c)}var Mde={kernelName:tp,backendName:"cpu",kernelFunc:Dde},Ode=E.SELU_SCALEALPHA,Pde=E.SELU_SCALE,Lde=ct(Nu,e=>e>=0?Pde*e:Ode*(Math.exp(e)-1)),zde={kernelName:Nu,backendName:"cpu",kernelFunc:Lde},Bde=ct(Eu,e=>e<0?-1:e>0?1:0),Wde={kernelName:Eu,backendName:"cpu",kernelFunc:Bde},Ude=ct(Cu,e=>Math.sin(e)),Vde={kernelName:Cu,backendName:"cpu",kernelFunc:Ude},jde=ct(Tu,e=>Math.sinh(e)),Hde={kernelName:Tu,backendName:"cpu",kernelFunc:jde},Gde=11920928955078125e-23,BE=Math.log(Gde)+2,qde=ct($u,e=>{let t=e>-BE,n=e<BE,r=Math.exp(e),a;return n?a=r:t?a=e:a=Math.log(1+r),a}),Kde={kernelName:$u,backendName:"cpu",kernelFunc:qde};function Xde(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;Ie([a],"spaceToBatchND");let o=k.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let d=TP.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=E.getReshaped(d.shape,s,o,!1),c=E.getPermuted(u.length,s.length,!1),p=E.getReshapedPermuted(d.shape,s,o,!1),h=It({inputs:{x:d},backend:n,attrs:{shape:u}}),f=mr({inputs:{x:h},backend:n,attrs:{perm:c}}),m=It({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}var Qde={kernelName:rp,backendName:"cpu",kernelFunc:Xde};function Jde(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values[0],[c,p,h,f,m]=rP(o,r.shape,r.dtype,l,a.dtype,d,u);return[n.makeTensorInfo(p,r.dtype,c),n.makeTensorInfo([p[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var Zde={kernelName:Df,backendName:"cpu",kernelFunc:Jde};function Yde(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[d,u,c]=aP(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(u,r.dtype,d),n.makeTensorInfo([c.length],s.dtype,new Int32Array(c))]}var ece={kernelName:sp,backendName:"cpu",kernelFunc:Yde};function tce(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[d,u]=O2(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,d)}var nce={kernelName:Mf,backendName:"cpu",kernelFunc:tce};function rce(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[d,u]=O2(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,d)}var ace={kernelName:Of,backendName:"cpu",kernelFunc:rce};function sce(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:d,sliceSize:u,strides:c,outputSize:p}=E.calculateShapes(s,a,o),h=!1,f=n.bufferSync(a),m;switch(s.dtype){case"bool":{let g=n.bufferSync(s),y=!!n.data.get(i.dataId).values[0];m=Oo(f,g,o,p,u,d,l,c,y,h);break}case"float32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];m=Oo(f,g,o,p,u,d,l,c,y,h);break}case"int32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];m=Oo(f,g,o,p,u,d,l,c,y,h);break}case"string":{let g=n.bufferSync(s),y=k.decodeString(n.data.get(i.dataId).values[0]);m=Oo(f,g,o,p,u,d,l,c,y,h);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}var ice={kernelName:ip,backendName:"cpu",kernelFunc:sce};function oce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=k.parseAxisParam(i,a.shape)[0],l=E.prepareSplitSize(a,s,o),d=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map(c=>{let p=[...u];p[o]=c;let h=cl({inputs:{x:a},backend:n,attrs:{begin:d,size:p}});return d[o]+=c,h})}var lce={kernelName:ap,backendName:"cpu",kernelFunc:oce},uce={kernelName:Pf,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;Ie(n,"square");let a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let i=0;i<a.length;++i){let o=a[i];s[i]=o*o}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},dce=ct(no,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),cce={kernelName:no,backendName:"cpu",kernelFunc:dce};function pce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:d,ellipsisMask:u,newAxisMask:c,shrinkAxisMask:p}=r;Ie(a,"stridedSlice");let{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=ln.sliceInfo(a.shape,s,i,o,l,d,u,c,p),w;if(m)w=It({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){k.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let I=ln.computeOutShape(b,v,x),N=cl({inputs:{x:a},backend:n,attrs:{begin:b,size:I}});w=It({inputs:{x:N},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(N)}else{let I=n.bufferSync(a),N=oP(h,I,x,b);w=n.makeTensorInfo(f,N.dtype,N.values)}return w}var hce={kernelName:op,backendName:"cpu",kernelFunc:pce};function fce(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:d}=r,{data:u,dataSplits:c}=t,p=n.data.get(u.dataId).values,h=n.data.get(c.dataId).values,[f,m]=P2(p,h,a,s,i,o,l,d);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}var mce={kernelName:zf,backendName:"cpu",kernelFunc:fce};function gce(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[d,u,c]=L2(o,l,a),p=u.length;return[n.makeTensorInfo([p,2],"int32",d),n.makeTensorInfo([p],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(c))]}var yce={kernelName:Bf,backendName:"cpu",kernelFunc:gce};function bce(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=z2(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var vce={kernelName:Wf,backendName:"cpu",kernelFunc:bce},xce=ct(Ou,e=>Math.tan(e)),wce={kernelName:Ou,backendName:"cpu",kernelFunc:xce},kce=ct(Pu,e=>Math.tanh(e)),Sce={kernelName:Pu,backendName:"cpu",kernelFunc:kce};function Ice(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:d,outputSize:u}=E.calculateShapes(s,a,r.shape),c=!1,p=n.bufferSync(a),h=n.bufferSync(s),f=n.bufferSync(r),m=Oo(p,h,r.shape,u,l,o,i,d,f,c);return n.makeTensorInfo(r.shape,m.dtype,m.values)}var Nce={kernelName:Yc,backendName:"cpu",kernelFunc:Ice};function Cce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;Ie(a,"tile");let i=uP(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var Tce={kernelName:to,backendName:"cpu",kernelFunc:Cce};function Ece(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;Ie(a,"topk");let o=n.data.get(a.dataId).values,[l,d]=cP(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(d.shape,d.dtype,d.values)]}var _ce={kernelName:lp,backendName:"cpu",kernelFunc:Ece};function $ce(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:d}=n,[u,c,p,h]=a.shape,[f,m]=d??[c,p],g=[u,f,m,h],y=k.computeStrides(a.shape),b=y[0],v=y[1],x=y[2],w=k.computeStrides(g),I=w[0],N=w[1],T=w[2],A=k.getTypedArrayFromDType(a.dtype,k.sizeFromShape(g));A.fill(l);let R=r.data.get(a.dataId).values,F=r.data.get(s.dataId).values;for(let C=0;C<u;++C){let M=s.shape[0]===1?F:F.subarray(C*8,C*8+8);for(let B=0;B<f;++B)for(let U=0;U<m;++U)for(let G=0;G<h;++G){let X,P=M[6]*U+M[7]*B+1;if(P===0)continue;let q=(M[0]*U+M[1]*B+M[2])/P,Q=(M[3]*U+M[4]*B+M[5])/P,J=WE(q,p,o),re=WE(Q,c,o);switch(i){case"nearest":X=Oce(R,c,p,b,v,x,C,re,J,G,l);break;case"bilinear":X=Pce(R,c,p,b,v,x,C,re,J,G,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let ae=C*I+B*N+U*T+G;A[ae]=X}return r.makeTensorInfo(g,a.dtype,A)}return{dataId:r.write(A,g,a.dtype),shape:a.shape,dtype:a.dtype}}var Ace={kernelName:up,backendName:"cpu",kernelFunc:$ce};function WE(e,t,n){switch(n){case"reflect":return Rce(e,t);case"wrap":return Fce(e,t);case"nearest":return Mce(e,t);case"constant":default:return Dce(e)}}function Rce(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return k.clamp(0,n,t-1)}function Fce(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return k.clamp(0,n,t-1)}function Dce(e,t){return e}function Mce(e,t){return k.clamp(0,e,t-1)}function oh(e,t,n,r,a,s,i,o,l,d,u){let c=i*r+o*a+l*s+d;return 0<=o&&o<t&&0<=l&&l<n?e[c]:u}function Oce(e,t,n,r,a,s,i,o,l,d,u){let c=Math.round(o),p=Math.round(l);return oh(e,t,n,r,a,s,i,c,p,d,u)}function Pce(e,t,n,r,a,s,i,o,l,d,u){let c=Math.floor(o),p=Math.floor(l),h=c+1,f=p+1,m=(f-l)*oh(e,t,n,r,a,s,i,c,p,d,u)+(l-p)*oh(e,t,n,r,a,s,i,c,f,d,u),g=(f-l)*oh(e,t,n,r,a,s,i,h,p,d,u)+(l-p)*oh(e,t,n,r,a,s,i,h,f,d,u);return(h-o)*m+(o-c)*g}function Lce(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;Ie(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:d}=W2(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([d.length],"int32",d)]}var zce={kernelName:Uf,backendName:"cpu",kernelFunc:Lce};function Bce(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),d=0;for(let h=0;h<i;h++)h!==s&&(l[d++]=a.shape[h]);let u=new Array(i).fill(0),c=a.shape.slice();c[s]=1;let p=new Array(o);for(let h=0;h<p.length;h++){u[s]=h;let f=cl({inputs:{x:a},backend:n,attrs:{begin:u,size:c}});p[h]=It({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return p}var Wce={kernelName:dp,backendName:"cpu",kernelFunc:Bce};function Uce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;Ie(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,d=[],u=[],c=o-l,p=s;for(let f=0;f<c;++f){let m=Uy({inputs:{input:p},backend:n,attrs:{dim:f+1}});p=m,u.push(m)}for(let f=0;f<i;++f){let m=k.createScalarValue(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=R3({inputs:{a:g,b:p},backend:n}),b=ji({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),v=jv({inputs:{a:b,b:a},backend:n}),x=bm({inputs:{x:v},backend:n,attrs:{axis:0,keepDims:!1}});d.push(x),u.push(g),u.push(y),u.push(b),u.push(v),u.push(x)}let h=CP({inputs:d,backend:n,attrs:{axis:0}});return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),h}var Vce={kernelName:Vf,backendName:"cpu",kernelFunc:Uce},jce=[Pie,gse,zie,Wie,kse,Vie,Hie,qie,Xie,Jie,Yie,toe,roe,ioe,loe,coe,hoe,moe,yoe,Mie,voe,woe,Soe,Ise,Noe,xse,Cse,Toe,yse,_oe,Aoe,Roe,Doe,Ooe,Loe,Boe,Uoe,joe,Goe,Koe,Qoe,Zoe,ele,nle,rle,sle,ole,ule,dle,cle,ple,fle,yle,Eie,vle,Tse,Tle,Ese,Ele,$se,Dle,Mle,Ple,Rse,Dse,zle,Wle,Vle,Hle,Ose,Lse,bse,qle,$oe,Xle,Jle,Yle,_ie,Bse,Use,tue,jse,rue,iue,lue,cue,hue,mue,gue,Gse,bue,xue,kue,Iue,Cue,Eue,$ue,Kse,Rue,Mue,zue,Qse,Zse,Uue,Hue,Kue,eie,Que,Zue,Yue,TP,rde,Aie,rie,sde,ode,ude,cde,vse,Qw,hde,Rie,Fie,Die,mde,yde,vde,wde,Sde,Ide,Cde,pie,Ede,Fde,Mde,zde,fie,Wde,Vde,Hde,mie,Pue,Kde,Qde,Zde,ece,nce,ace,ice,lce,bie,uce,xie,kie,cce,hce,mce,yce,vce,Cie,mle,wce,Sce,Nce,Tce,_ce,Ace,tie,zce,Wce,Vce,Jue];for(let e of jce)jf(e);var EP={};De(EP,{assertNotComplex:()=>Np,bindCanvasToFramebuffer:()=>tpe,bindColorTextureToFramebuffer:()=>Ug,bindTextureToProgramUniformSampler:()=>jP,bindTextureUnit:()=>WP,bindVertexBufferToProgramAttribute:()=>Zw,callAndCheck:()=>fe,canBeRepresented:()=>$P,createFragmentShader:()=>FP,createFramebuffer:()=>BP,createProgram:()=>DP,createStaticIndexBuffer:()=>PP,createStaticVertexBuffer:()=>OP,createTexture:()=>LP,createVertexShader:()=>RP,getBatchDim:()=>pl,getExtensionOrThrow:()=>lh,getFramebufferErrorMessage:()=>HP,getMaxTexturesInShader:()=>XP,getNumChannels:()=>Yce,getProgramUniformLocation:()=>VP,getProgramUniformLocationOrThrow:()=>UP,getRowsCols:()=>hl,getShapeAs3D:()=>dh,getTextureShapeFromLogicalShape:()=>qP,getWebGLDisjointQueryTimerVersion:()=>QP,getWebGLErrorMessage:()=>AP,getWebGLMaxTextureSize:()=>KP,hasExtension:()=>Xr,isCapableOfRenderingToFloatTexture:()=>JP,isDownloadFloatTextureEnabled:()=>ZP,isReshapeFree:()=>sf,isWebGLFenceEnabled:()=>YP,isWebGLVersionEnabled:()=>e1,linkProgram:()=>MP,logShaderSourceAndInfoLog:()=>G2,resetMaxTextureSize:()=>npe,resetMaxTexturesInShader:()=>rpe,unbindColorTextureFromFramebuffer:()=>Yw,unbindTextureUnit:()=>epe,validateFramebuffer:()=>uh,validateProgram:()=>Wg,validateTextureSize:()=>zP});var $o={},gg={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function _P(e,t){$o[e]=t}function za(e,t){if(!(e in $o)||t!=null){let r=Gce(e,t);if(r!==null)$o[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=$o[e];return n==null||n.isContextLost()?(delete $o[e],za(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),$o[e])}function Hce(e){if(!K().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Gce(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??Hce(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete $o[e]},!1),K().getBool("SOFTWARE_WEBGL_ENABLED")&&(gg.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",gg)||n.getContext("experimental-webgl",gg):n.getContext("webgl2",gg)}var af;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(af||(af={}));var Kr;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Kr||(Kr={}));var _n;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(_n||(_n={}));function vm(e,t){return[t,e]}function qce(e,t){return e*t}function yg(e){let t=k.sizeFromShape(e),n=Math.ceil(t/4);return k.sizeToSquarishShape(n)}function Ip(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function Kce(e,t){let[n,r]=Ip(e,t);return n*r*4}function H2(e,t){let n=e,r,a,s,i,o,l,d,u,c,p;return K().getNumber("WEBGL_VERSION")===2?(r=n.R32F,a=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,d=4,u=1,c=n.HALF_FLOAT,p=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,d=4,u=4,c=t!=null?t.HALF_FLOAT_OES:null,p=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:d,defaultNumChannels:u,textureTypeHalfFloat:c,textureTypeFloat:p}}function fe(e,t){let n=t();return K().getBool("DEBUG")&&Xce(e),n}function Xce(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+AP(e,t))}var Qce=596e-10,Jce=65504;function $P(e){return!!(K().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||Qce<Math.abs(e)&&Math.abs(e)<Jce)}function AP(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function lh(e,t){return Ks(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function RP(e,t){let n=Ks(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(fe(e,()=>e.shaderSource(n,t)),fe(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function FP(e,t){let n=Ks(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(fe(e,()=>e.shaderSource(n,t)),fe(e,()=>e.compileShader(n)),K().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw G2(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var Zce=/ERROR: [0-9]+:([0-9]+):/g;function G2(e,t){let n=Zce.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],a=e.split(`
`),s=a.length.toString().length+2,i=a.map((c,p)=>k.rightPad((p+1).toString(),s)+c),o=0;for(let c=0;c<i.length;c++)o=Math.max(i[c].length,o);let l=i.slice(0,r-1),d=i.slice(r-1,r),u=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${k.rightPad(d[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function DP(e){return Ks(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function MP(e,t){if(fe(e,()=>e.linkProgram(t)),!K().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Wg(e,t){if(fe(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function OP(e,t){let n=Ks(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return fe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),fe(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function PP(e,t){let n=Ks(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return fe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),fe(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Yce(){return K().getNumber("WEBGL_VERSION")===2?1:4}function LP(e){return Ks(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function zP(e,t){let n=K().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function BP(e){return Ks(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Zw(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(fe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),fe(e,()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i)),fe(e,()=>e.enableVertexAttribArray(o)),!0)}function WP(e,t,n){GP(e,n),fe(e,()=>e.activeTexture(e.TEXTURE0+n)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function epe(e,t){GP(e,t),fe(e,()=>e.activeTexture(e.TEXTURE0+t)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function UP(e,t,n){return Ks(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function VP(e,t,n){return e.getUniformLocation(t,n)}function jP(e,t,n,r){fe(e,()=>WP(e,t,r)),fe(e,()=>e.uniform1i(n,r))}function tpe(e){fe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),fe(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),fe(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function Ug(e,t,n){fe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),fe(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function Yw(e,t){fe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),fe(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function uh(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+HP(e,t))}function HP(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Ks(e,t,n){let r=fe(e,()=>t());if(r==null)throw new Error(n);return r}function GP(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let a=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${a}.`)}}function pl(e,t=2){return k.sizeFromShape(e.slice(0,e.length-t))}function hl(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function dh(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[pl(e),...hl(e)]),t}function qP(e,t=!1){let n=K().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=K().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&K().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?k.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=k.squeezeShape(e).newShape);let a=k.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=pl(e),l=2,d=2;e.length&&([l,d]=hl(e)),a=o*(l/2)*(d/2),s=k.sizeToSquarishShape(a).map(u=>u*2)}else s=k.sizeToSquarishShape(a);return s}function bg(e){return e%2===0}function sf(e,t){if(e=e.slice(-2),t=t.slice(-2),k.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||bg(n)&&bg(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&bg(e[0])&&bg(t[0])}var Vg,jg;function KP(e){if(Vg==null){let t=za(e);Vg=t.getParameter(t.MAX_TEXTURE_SIZE)}return Vg}function npe(){Vg=null}function rpe(){jg=null}function XP(e){if(jg==null){let t=za(e);jg=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,jg)}function QP(e){if(e===0)return 0;let t,n=za(e);return Xr(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Xr(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Xr(e,t){return e.getExtension(t)!=null}function e1(e){try{if(za(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function JP(e){if(e===0)return!1;let t=za(e);if(e===1){if(!Xr(t,"OES_texture_float"))return!1}else if(!Xr(t,"EXT_color_buffer_float"))return!1;return t1(t)}function ZP(e){if(e===0)return!1;let t=za(e);if(e===1){if(!Xr(t,"OES_texture_float")||!Xr(t,"WEBGL_color_buffer_float"))return!1}else{if(Xr(t,"EXT_color_buffer_float"))return t1(t);let n="EXT_color_buffer_half_float";if(Xr(t,n)){let r=t.getExtension(n);return ape(t,r)}return!1}return t1(t)}function t1(e){let t=H2(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function ape(e,t){let n=H2(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),s}function YP(e){return e!==2?!1:za(e).fenceSync!=null}function Np(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&k.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Ne=K();Ne.registerFlag("HAS_WEBGL",()=>Ne.getNumber("WEBGL_VERSION")>0);Ne.registerFlag("WEBGL_VERSION",()=>e1(2)?2:e1(1)?1:0);Ne.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ne.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ne.get("WEBGL_VERSION")===2);Ne.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ne.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ne.registerFlag("WEBGL_PACK",()=>Ne.getBool("HAS_WEBGL"));Ne.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_CLIP",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_REDUCE",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_CONV_IM2COL",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ne.getBool("WEBGL_PACK"));Ne.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>KP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>XP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=Ne.getNumber("WEBGL_VERSION");return e===0?0:QP(e)});Ne.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ne.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!qf.isMobile());Ne.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>JP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ne.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ne.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ne.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>ZP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_FENCE_API_ENABLED",()=>YP(Ne.getNumber("WEBGL_VERSION")));Ne.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ne.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ne.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});Ne.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>qf.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});Ne.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ne.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ne.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ne.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ne.registerFlag("WEBGL_EXP_CONV",()=>!1);Ne.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ne.getBool("IS_TEST"));Ne.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ne.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ne.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ne.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function rr(){let e,t,n,r,a,s,i,o,l,d;return K().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=K().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",d=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,d=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:d}}function Hu(e,t,n="index"){let r=k.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / ${a}`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${a}`:`index -= ${e[s]} * ${a}`;return`${i}; ${o};`}).join("")}function Hv(e,t,n="index"){let r=k.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function spe(e,t){let n=e.length,r=e.map(s=>`${t}[${s}]`),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function ipe(e,t,n="index"){let r=e.map((s,i)=>i),a=spe(r,t);return a.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${a[i]}`,l=i===a.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${a[i]}`:`index -= ${e[i]} * ${a[i]}`;return`${o}; ${l};`}).join("")}function q2(e){let t=k.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function K2(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var eL=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:tL}=E;function ope(e,t,n){let r=[];if(e.forEach(p=>{let h=k.sizeFromShape(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${h>1?`[${h}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){let{uniformShape:f}=X2(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`);break}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});let a=r.join(`
`),s=e.map(p=>lpe(p,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=rr(),l=cpe(o),d,u,c=fpe(o);return t.isPacked?(d=upe(t.logicalShape,i,n.enableShapeUniforms),u=hpe(o)):(d=dpe(t.logicalShape,i,n.enableShapeUniforms),u=ppe(o)),n.packedInputs&&(c+=bpe),[c,l,u,a,d,s,n.userCode].join(`
`)}function Cp(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return $pe(e,t);case 1:return Rpe(e,t);case 2:return Dpe(e,t);case 3:return Ope(e,t);case 4:return Lpe(e,t);case 5:return zpe(e);case 6:return Bpe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function nL(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return _pe(e);case 1:return Ape(e,t);case 2:return Fpe(e,t);case 3:return Mpe(e,t);default:return Ppe(e,t)}}function lpe(e,t,n=!1,r){let a="";n?a+=nL(e,r):a+=Cp(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?a+=Wpe(e,t):a+=Upe(e,t)),a}function upe(e,t,n){switch(e.length){case 0:return rL();case 1:return vpe(e,t,n);case 2:return Tpe(e,t,n);case 3:return wpe(e,t,n);default:return Spe(e,t,n)}}function dpe(e,t,n){switch(e.length){case 0:return rL();case 1:return xpe(e,t,n);case 2:return Epe(e,t,n);case 3:return kpe(e,t,n);case 4:return Ipe(e,t,n);case 5:return Npe(e,t);case 6:return Cpe(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function cpe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function ppe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function hpe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function fpe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${mpe}
    ${gpe}
    ${ype}
  `}var mpe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,gpe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ype=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,bpe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function rL(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function vpe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function xpe(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function wpe(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec3(b, r, c);
    }
  `}function kpe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Hv(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=Hu(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function Spe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let d=2;d<e.length-1;d++)i*=e[e.length-d-1],o=`
      int b${d} = index / ${i};
      index -= b${d} * ${i};
    `+o,l=`b${d}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec${e.length}(${l});
    }
  `}function Ipe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Hv(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=Hu(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function Npe(e,t){let n=Hu(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Cpe(e,t){let n=Hu(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Tpe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(k.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let a=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec2(r, c);
    }
  `}function Epe(e,t,n){return k.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Gu(e){return`offset${e}`}function _pe(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=rr();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function $pe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(a===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=Gu(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function Ape(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=rr();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function Rpe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Tp(e)}
      }
    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=Gu(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function Fpe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=rr();if(s!=null&&k.arraysEqual(n,s))return t?`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${a}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let d=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return`
    vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${d[0]}, ${d[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function Dpe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(s!=null&&k.arraysEqual(n,s)){if(t)return`
      float ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let p=s[0],h=s[1];return`
    float ${a}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:o}=k.squeezeShape(n),l=i;if(l.length<n.length){let p=Ep(e,l),h=["row","col"];return`
      ${Cp(p,t)}
      float ${a}(int row, int col) {
        return ${a}(${_p(h,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Tp(e)}
      }
    `;let d=s[0],u=s[1],c=Gu(r);return u===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `:d===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${a}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${c};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${a}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${c};
    vec2 uv = uvFromFlat(${d}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function Mpe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let p=n.slice(1),h=[1,2],f=Ep(e,p),m=["b","row","col"];return`
        ${nL(f,t)}
        vec4 ${a}(int b, int row, int col) {
          return ${a}(${_p(m,h)});
        }
      `}let o=rr();if(t)return`
    vec4 ${a}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let l=i[0],d=i[1],u=Math.ceil(n[2]/2),c=u*Math.ceil(n[1]/2);return`
    vec4 ${a}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${d}, ${c}, ${u}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function Ope(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=k.squeezeShape(n),d=o;if(d.length<n.length){let m=Ep(e,d),g=["row","col","depth"];return`
        ${Cp(m,t)}
        float ${a}(int row, int col, int depth) {
          return ${a}(${_p(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Tp(e)}
      }
    `;let u=e.shapeInfo.texShape,c=u[0],p=u[1],h=e.shapeInfo.flatOffset;if(p===s&&h==null)return t?`
      float ${a}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${a}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${c}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===i&&h==null)return t?`
      float ${a}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=Gu(r);return t?`
    float ${a}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${a}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${c}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Ppe(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=rr();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],d=l[0],u=l[1],c=Math.ceil(s[i-1]/2),p=c*Math.ceil(s[i-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${c} + (col / 2)`;for(let m=2;m<i-1;m++)h=`int b${m}, `+h,p*=s[i-m-1],f=`b${m} * ${p} + `+f;return`
    vec4 ${r}(${h}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${d});
      return ${a.texture2D}(${n}, uv);
    }
  `}function Lpe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:d}=k.squeezeShape(n);if(l.length<n.length){let b=Ep(e,l),v=["row","col","depth","depth2"];return`
      ${Cp(b,t)}
      float ${a}(int row, int col, int depth, int depth2) {
        return ${a}(${_p(v,d)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${Tp(e)}
      }
    `;let u=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,p=c[0],h=c[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(h===o&&u==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(h===s&&u==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;let y=Gu(r);return t?`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${p}, ${h}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function zpe(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:d}=k.squeezeShape(t);if(l.length<t.length){let m=Ep(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${Cp(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${_p(g,d)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${a})) +
          depth3;
        ${Tp(e)}
      }
    `;let u=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,p=c[0],h=c[1];if(h===o&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=Gu(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${a} + depth3 + ${f};
      vec2 uv = uvFromFlat(${p}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Bpe(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=k.squeezeShape(t);if(a.length<t.length){let g=Ep(e,a),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Cp(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${_p(y,s)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,d=t[2]*l,u=t[1]*d;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${d}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Tp(e)}
      }
    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===u&&c==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${d}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&c==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=Gu(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${d} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${h}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Tp(e){let t=e.name,n=k.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Wpe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=tL(e.shapeInfo.logicalShape,t.logicalShape),l=bt(i),d=i-s,u,c=["x","y","z","w","u","v"];s===0?u="":i<2&&o.length>=1?u="coords = 0;":u=o.map(g=>`coords.${c[g+d]} = 0;`).join(`
`);let p="";i<2&&s>0?p="coords":p=e.shapeInfo.logicalShape.map((g,y)=>`coords.${c[y+d]}`).join(", ");let h="return outputValue;",f=k.sizeFromShape(e.shapeInfo.logicalShape)===1,m=k.sizeFromShape(t.logicalShape)===1;if(s===1&&!f&&!m)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!m)i===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(o.length){let g=s-2,y=s-1;o.indexOf(g)>-1&&o.indexOf(y)>-1?h="return vec4(outputValue.x);":o.indexOf(g)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(y)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${a}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${p});
      ${h}
    }
  `}function Upe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&k.arraysEqual(i,s))return`
      float ${a}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let d=bt(l),u=tL(e.shapeInfo.logicalShape,t.logicalShape),c=l-o,p,h=["x","y","z","w","u","v"];o===0?p="":l<2&&u.length>=1?p="coords = 0;":p=u.map(m=>`coords.${h[m+c]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${h[g+c]}`).join(", "),`
    float ${a}() {
      ${d} coords = getOutputCoords();
      ${p}
      return get${r}(${f});
    }
  `}function bt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function X2(e,t,n){let{newShape:r,keptDims:a}=k.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&s>1&&!k.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function Ep(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function _p(e,t){return t.map(n=>e[n]).join(", ")}function Vpe(e,t,n,r){let a=n.map((u,c)=>{let p={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(p.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[c],shapeInfo:p}}),s=a.map(u=>u.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=ope(a,i,t),l=FP(e.gl,o),d=e.createProgram(l);return K().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:d,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(d),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:d,inShapeInfos:s,outShapeInfo:i},aL(e,t,d)))}function aL(e,t,n){let r=[],a=[],s,i,o,l=null,d=null;d=e.getUniformLocation(n,"NAN",!1),K().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));let u=!1;for(let c of t.variableNames){let p={name:c,uniform:e.getUniformLocation(n,c,u),offset:e.getUniformLocation(n,`offset${c}`,u)};t.enableShapeUniforms&&(p.shape=e.getUniformLocation(n,`${c}Shape`,u),p.texShape=e.getUniformLocation(n,`${c}TexShape`,u)),r.push(p)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",u),o=e.getUniformLocation(n,"outShapeStrides",u),i=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(let c of t.customUniforms)a.push(e.getUniformLocation(n,c.name,u));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:d,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function UE(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let a=n.logicalShape,s=t[r],i=s.shape;if(!k.arraysEqual(a,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!k.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function jpe(e,t,n,r,a){t.program.enableShapeUniforms||(UE(t.inShapeInfos,n),UE([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),K().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let d=n[l],{uniform:u,offset:c,shape:p,texShape:h}=t.variablesLocations[l];if(p){let{uniformShape:f}=X2(t.program.packedInputs,d.shape,d.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(p,new Int32Array(f));break;case 2:e.gl.uniform2iv(p,new Int32Array(f));break;case 3:e.gl.uniform3iv(p,new Int32Array(f));break;case 4:e.gl.uniform4iv(p,new Int32Array(f));break}}if(h&&e.gl.uniform2i(h,d.texData.texShape[0],d.texData.texShape[1]),u!=null){if(d.isUniform){if(k.sizeFromShape(d.shape)<2)e.gl.uniform1f(u,d.uniformValues[0]);else{let f=d.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(u,f)}continue}d.texData.slice!=null&&c!=null&&e.gl.uniform1i(c,d.texData.slice.flatOffset),e.setInputMatrixTexture(d.texData.texture.texture,u,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){let l=k.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let d=t.program.customUniforms[l],u=t.customUniformLocations[l],c=a[l];if(d.type==="float")e.gl.uniform1fv(u,c);else if(d.type==="vec2")e.gl.uniform2fv(u,c);else if(d.type==="vec3")e.gl.uniform3fv(u,c);else if(d.type==="vec4")e.gl.uniform4fv(u,c);else if(d.type==="int")e.gl.uniform1iv(u,c);else if(d.type==="ivec2")e.gl.uniform2iv(u,c);else if(d.type==="ivec3")e.gl.uniform3iv(u,c);else if(d.type==="ivec4")e.gl.uniform4iv(u,c);else throw Error(`uniform type ${d.type} is not supported yet.`)}e.executeProgram()}function Hpe(e,t,n){let r="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:d,uniformShape:u,keptDims:c}=X2(e.packedInputs,i.shape,l),p="",h="",f="";if(u.length===1&&e.packedInputs){let w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=`${w[0]>1}_${w[1]>1}`}else if(u.length===2&&!e.packedInputs)h=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!e.packedInputs){let w=k.computeStrides(u);f=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}let m=i.shape.length,g=u.length===2&&k.arraysEqual(i.shape,l),y=k.sizeFromShape(i.shape)===1,b=E.getBroadcastDims(i.shape,n.shape),v=!e.packedInputs&&m===n.shape.length&&k.arraysEqual(l,n.texData.texShape),x=e.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${v}_${d?c:""}_${u.length}_${y}_${b}_${g}_${p}_${h}_${f}_${x}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${K().getNumber("WEBGL_VERSION")}`,s}function zn(e){return K().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var Gpe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=af.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=rr();this.outputShape=e,this.enableShapeUniforms=zn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Hv(["r","c","d"],e):Hu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},qpe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=af.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=rr();this.outputShape=e,this.enableShapeUniforms=zn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Hv(["r","c","d"],e):Hu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},Kpe=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Kr.DOWNLOAD;let t=rr();this.outputShape=e,this.userCode=`
      ${eL}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},Xpe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Kr.DOWNLOAD;let t=rr();this.outputShape=e,this.userCode=`
      ${eL}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},Qpe={R:0,G:1,B:2,A:3},VE=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=rr();this.outputShape=e,this.enableShapeUniforms=zn(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let o=n[i];s+=`
          if(offset == ${i}) {
            result = values[${Qpe[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?K2():q2(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${s}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}},Jpe=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=rr();this.outputShape=e,this.enableShapeUniforms=zn(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?K2():q2(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${a};
        }
    `}},sL={};De(sL,{bindVertexProgramAttributeStreams:()=>fL,createBufferFromOutputTexture:()=>yL,createFloat16MatrixTexture:()=>dL,createFloat16PackedMatrixTexture:()=>hL,createFloat32MatrixTexture:()=>uL,createIndexBuffer:()=>lL,createPackedMatrixTexture:()=>pL,createUnsignedBytesMatrixTexture:()=>cL,createVertexBuffer:()=>oL,createVertexShader:()=>iL,downloadByteEncodedFloatMatrixFromOutputTexture:()=>vL,downloadFloat32MatrixFromBuffer:()=>bL,downloadMatrixFromPackedOutputTexture:()=>wL,downloadPackedMatrixFromBuffer:()=>xL,getInternalFormatForFloat16MatrixTexture:()=>J2,getInternalFormatForFloat16PackedMatrixTexture:()=>eN,getInternalFormatForFloat32MatrixTexture:()=>Q2,getInternalFormatForPackedMatrixTexture:()=>Y2,getInternalFormatForUnsignedBytesMatrixTexture:()=>Z2,uploadDenseMatrixToTexture:()=>mL,uploadPixelDataToTexture:()=>gL});function iL(e){let t=rr(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return RP(e,n)}function oL(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return OP(e,t)}function lL(e){let t=new Uint16Array([0,1,2,2,1,3]);return PP(e,t)}function xm(e,t,n,r,a,s){zP(t,n);let i=LP(e),o=e.TEXTURE_2D;return fe(e,()=>e.bindTexture(o,i)),fe(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),fe(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),fe(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),fe(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),K().getNumber("WEBGL_VERSION")===1?fe(e,()=>e.texImage2D(o,0,r,t,n,0,a,s,null)):fe(e,()=>e.texStorage2D(o,1,r,t,n)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function Q2(e){return e.internalFormatFloat}function uL(e,t,n,r){let[a,s]=vm(t,n);return xm(e,a,s,Q2(r),r.textureFormatFloat,e.FLOAT)}function J2(e){return e.internalFormatHalfFloat}function dL(e,t,n,r){let[a,s]=vm(t,n);return xm(e,a,s,J2(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Z2(e){return e.downloadTextureFormat}function cL(e,t,n,r){let[a,s]=vm(t,n);return xm(e,a,s,Z2(r),e.RGBA,e.UNSIGNED_BYTE)}function Y2(e){return e.internalFormatPackedFloat}function pL(e,t,n,r){let[a,s]=Ip(t,n);return xm(e,a,s,Y2(r),e.RGBA,e.FLOAT)}function eN(e){return e.internalFormatPackedHalfFloat}function hL(e,t,n,r){let[a,s]=Ip(t,n);return xm(e,a,s,eN(r),e.RGBA,r.textureTypeHalfFloat)}function fL(e,t,n){return fe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Zw(e,t,"clipSpacePos",n,3,20,0)&&Zw(e,t,"uv",n,2,20,12)}function mL(e,t,n,r,a,s){fe(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),K().getNumber("WEBGL_VERSION")===2?fe(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):fe(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function gL(e,t,n){fe(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?K().getNumber("WEBGL_VERSION")===2?fe(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):fe(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):K().getNumber("WEBGL_VERSION")===2?fe(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):fe(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),fe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function yL(e,t,n,r){let a=e.createBuffer();fe(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));let s=4*4*t*n;return fe(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),fe(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),fe(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function bL(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function vL(e,t,n,r){let[a,s]=vm(t,n),i=4,o=new Uint8Array(qce(t*n,i));return fe(e,()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function xL(e,t,n,r,a,s,i,o){let l=e,d=new Float32Array(Kce(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,d),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),d}function wL(e,t,n){let r=new Float32Array(t*n*4);return fe(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var Hg=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=K().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,_P(t,e)):this.gl=za(t),e=this.gl,K().getNumber("WEBGL_VERSION")===2){let a=e;this.createVertexArray=()=>fe(a,()=>a.createVertexArray()),this.bindVertexArray=s=>fe(a,()=>a.bindVertexArray(s)),this.deleteVertexArray=s=>fe(a,()=>a.deleteVertexArray(s)),this.getVertexArray=()=>fe(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){let a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>fe(e,()=>a.createVertexArrayOES()),this.bindVertexArray=s=>fe(e,()=>a.bindVertexArrayOES(s)),this.deleteVertexArray=s=>fe(e,()=>a.deleteVertexArrayOES(s)),this.getVertexArray=()=>fe(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),K().getNumber("WEBGL_VERSION")===1){let a="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=lh(this.gl,a),Xr(this.gl,s))this.textureHalfFloatExtension=lh(this.gl,s);else if(K().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Xr(this.gl,r))this.colorBufferHalfFloatExtension=lh(this.gl,r);else if(K().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Xr(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Xr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=oL(this.gl),this.indexBuffer=lL(this.gl),this.framebuffer=BP(this.gl),this.textureConfig=H2(this.gl,this.textureHalfFloatExtension)}get debug(){return K().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;fe(e,()=>e.finish()),fe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),fe(e,()=>e.deleteFramebuffer(this.framebuffer)),fe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),fe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),fe(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),uL(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),dL(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),cL(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),gL(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),mL(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),hL(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),pL(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Yw(this.gl,this.framebuffer),this.outputTexture=null),fe(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>vL(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return xL(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return bL(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=yL(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(K().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=r.clientWaitSync(a,0,0);return s===r.ALREADY_SIGNALED||s===r.CONDITION_SATISFIED},t=a}else K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>wL(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=iL(t));let n=DP(t);fe(t,()=>t.attachShader(n,this.vertexShader)),fe(t,()=>t.attachShader(n,e)),MP(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&Wg(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;fe(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),fL(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(fe(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Wg(this.gl,this.program),fe(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?UP(this.gl,e,t):VP(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),fe(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),jP(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=Ip(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Wg(this.gl,this.program),uh(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}fe(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),fe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=lh(this.gl,K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,a),a}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await k.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Zpe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in K().platform&&(n=K().platform.setTimeoutCustom.bind(K().platform)),k.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ug(this.gl,e,this.framebuffer),this.debug&&uh(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ug(this.gl,this.outputTexture,this.framebuffer),this.debug&&uh(this.gl)):Yw(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;Ug(r,e,this.framebuffer),this.debug&&uh(r),this.outputTexture=e,fe(r,()=>r.viewport(0,0,t,n)),fe(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),fe(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Zpe(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Ype,bincountImpl:kL,bincountReduceImpl:ehe,bitwiseAndImpl:the,castImpl:nhe,ceilImpl:rhe,concatImpl:ahe,equalImpl:she,expImpl:ihe,expm1Impl:ohe,floorImpl:lhe,gatherNdImpl:uhe,gatherV2Impl:dhe,greaterImpl:che,greaterEqualImpl:phe,lessImpl:hhe,lessEqualImpl:fhe,linSpaceImpl:mhe,logImpl:ghe,maxImpl:yhe,maximumImpl:bhe,minimumImpl:vhe,multiplyImpl:xhe,negImpl:whe,notEqualImpl:khe,prodImpl:She,raggedGatherImpl:Ihe,raggedRangeImpl:Nhe,raggedTensorToTensorImpl:Che,rangeImpl:The,rsqrtImpl:Ehe,scatterImpl:_he,sigmoidImpl:$he,simpleAbsImpl:SL,sliceImpl:Ahe,sparseFillEmptyRowsImpl:Rhe,sparseReshapeImpl:Fhe,sparseSegmentReductionImpl:IL,sqrtImpl:Dhe,staticRegexReplaceImpl:Mhe,stridedSliceImpl:Ohe,stringNGramsImpl:Phe,stringSplitImpl:Lhe,stringToHashBucketFastImpl:zhe,subImpl:Bhe,tileImpl:Whe,topKImpl:Uhe,transposeImpl:tN,uniqueImpl:Vhe}=_2;function NL(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function qn(e,t){return t===1?[e]:NL(e,t)}function jhe(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var Hhe=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=zn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=qn("rc",this.rank),n=bt(this.rank),r=this.getOutOfBoundsCondition(t),a=this.getSetup(t),s=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)a=`${e[e.length-1-s]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},CL=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=zn(this.outputShape.length);let n="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2===1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),n+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${Ghe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?K2():q2(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function Ghe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?ipe(["r","c","d"],"inputShape"):Hu(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var qhe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=HE(t,n),a=GE(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s=jE(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[a].pop();return this.usedTextures[a].push(o),o}let i;return r===_n.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===_n.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===_n.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===_n.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===_n.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let a=HE(n,r),s=GE(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=jE(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=K().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],d=l&&l.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[d]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Khe(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function jE(e,t,n,r,a){let s=Xhe(t,r),i;if(a){let[l,d]=Ip(e[0],e[1]);i=l*d}else{let[l,d]=vm(e[0],e[1]);i=l*d}let o=Khe(n,s);return i*o}function Xhe(e,t){switch(e){case _n.PACKED_2X2_FLOAT32:return Y2(t);case _n.PACKED_2X2_FLOAT16:return eN(t);case _n.UNPACKED_FLOAT32:return Q2(t);case _n.UNPACKED_FLOAT16:return J2(t);case _n.PACKED_4X1_UNSIGNED_BYTE:return Z2(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function Qhe(e){return K().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?_n.PACKED_2X2_FLOAT32:_n.UNPACKED_FLOAT32:e?_n.PACKED_2X2_FLOAT16:_n.UNPACKED_FLOAT16}function HE(e,t){if(e===Kr.UPLOAD)return _n.PACKED_2X2_FLOAT32;if(e===Kr.RENDER||e==null)return Qhe(t);if(e===Kr.DOWNLOAD||e===Kr.PIXELS)return _n.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function GE(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var rs=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=zn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},wa="if (isnan(x)) return x;",Jhe="return x;",qE="return abs(x);",Zhe="return (x >= 0.0) ? x : (exp(x) - 1.0);",Yhe=wa+`
  return (x < 0.0) ? 0.0 : x;
`,efe=wa+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,oi="return x;",tfe="return 1.0 / (1.0 + exp(-1.0 * x));",nfe="return x;",rfe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,afe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sfe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ife="return 1.0 / (1.0 + exp(-1.0 * x));",yi=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=zn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},ofe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=zn(this.outputShape.length);let t=e.length,n=qn("rc",t),r=bt(t),a=jhe(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},lfe=gs.whereImpl,ufe=1e-7,dfe=1e-4,Qx={};function cfe(e){return e in Qx||(Qx[e]={}),Qx[e]}var pfe=K().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),hfe=600;function ffe(){return K().global.screen==null?1024:K().global.screen.height*K().global.screen.width*window.devicePixelRatio*hfe/1024/1024}var nN=class TL extends wf{nextDataId(){return TL.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!K().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof Hg)n=t;else{let r=za(K().getNumber("WEBGL_VERSION"),t);n=new Hg(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let r=za(K().getNumber("WEBGL_VERSION"));n=new Hg(r),this.binaryCache=cfe(K().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new qhe(this.gpgpu),this.numMBBeforeWarning=ffe(),this.texData=new Sb(this,ua())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,a,s,i){let o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[a,s]},l.texShape=[a,s];let d=dh(n),u=new VE(d,!1,i),c=this.runWebGLProgram(u,[o],r,[[a,s]]);return c.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),c.dataId}write(t,n,r){if((K().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||K().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let a={id:this.nextDataId()};return this.texData.set(a,{shape:n,dtype:r,values:t,usage:Kr.UPLOAD,refCount:1}),a}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,r,a,s){if(K().getBool("DEBUG")&&this.checkNumericalProblems(n),a==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:a,values:n,usage:Kr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:r,dtype:a,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=n;if(i!=null){let p;l?p=new yi(o,oi):p=new rs(o,oi);let h=this.runWebGLProgram(p,[{dataId:t,shape:o,dtype:a}],a),f=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),f}if(r!=null)return this.convertAndCacheOnCPU(t);if(a==="string")return r;let d=this.activeTimers!=null,u;d&&(u=k.now());let c;if(a==="complex64"){let p=this.readSync(s.real.dataId),h=this.readSync(s.imag.dataId);c=E.mergeRealAndImagArrays(p,h)}else c=this.getValuesFromTexture(t);return d&&(this.downloadWaitMs+=k.now()-u),this.convertAndCacheOnCPU(t,c)}async read(t){if(this.pendingRead.has(t)){let f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}let n=this.texData.get(t),{values:r,shape:a,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let f;l?f=new yi(a,oi):f=new rs(a,oi);let m=this.runWebGLProgram(f,[{dataId:t,shape:a,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(t);if(K().getBool("DEBUG")&&!K().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&K().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d=null,u;if(i!=="complex64"&&K().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);let f=this.texData.get(u.dataId);d=this.gpgpu.createBufferFromTexture(f.texture.texture,...yg(a))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let c;if(i==="complex64"){let f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],g=f[1];c=E.mergeRealAndImagArrays(m,g)}else if(d==null)c=this.getValuesFromTexture(t);else{let f=k.sizeFromShape(a);c=this.gpgpu.downloadFloat32MatrixFromBuffer(d,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),d!=null){let f=this.gpgpu.gl;fe(f,()=>f.deleteBuffer(d))}let p=this.convertAndCacheOnCPU(t,c),h=this.pendingRead.get(t);return this.pendingRead.delete(t),h.forEach(f=>f(p)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&ua().removeDataId(t,this),this.pendingDeletes--),p}readToGPU(t,n={}){let r=this.texData.get(t),{values:a,shape:s,slice:i,dtype:o,isPacked:l,texture:d}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let h;l?h=new yi(s,oi):h=new rs(s,oi);let f=this.runWebGLProgram(h,[{dataId:t,shape:s,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(d==null)throw a!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(t,n.customTexShape),c=ua().makeTensorFromTensorInfo(u),p=this.texData.get(u.dataId);return Object.assign({tensorRef:c},p.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(a=>k.decodeString(a));return Ve(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ve(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let r=t[n];if(!$P(r))throw K().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:r,isPacked:a}=this.texData.get(t),s=k.sizeFromShape(n);if(K().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let p=this.decode(t),h=this.texData.get(p.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...yg(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(p),f}let i=K().getBool("WEBGL_PACK")&&a===!0,o=i?dh(n):n,l=i?new Xpe(o):new Kpe(o),d=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:t}],"float32"),u=this.texData.get(d.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(d),c}timerAvailable(){return K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,r=[],a=!1;this.programTimersStack==null?(this.programTimersStack=r,a=!0):this.activeTimers.push(r),this.activeTimers=r,t();let s=k.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=k.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,a&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(s);o.kernelMs=k.sum(l),o.getExtraProfileInfo=()=>l.map((d,u)=>({name:i[u],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:k.now(),endMs:null}}endTimer(t){return K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=k.now(),t)}async getQueryTime(t){if(K().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:r,texShape:a,usage:s,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,d=this.dataRefCount.get(l);d>1?this.dataRefCount.set(l,d-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(a,r),this.textureManager.releaseTexture(n,a,s,i)));let u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=pfe){return K().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&k.sizeFromShape(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){E.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return lfe(t.shape,n)}packedUnaryOp(t,n,r){let a=new yi(t.shape,n),s=this.compileAndRun(a,[t],r);return ua().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let a=SL(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,a)}if(K().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,qE,t.dtype);let n=new rs(t.shape,qE),r=this.compileAndRun(n,[t]);return ua().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&k.isString(r[0])){let s=r.map(i=>k.encodeString(i));a=this.write(s,t,n)}else a=this.write(r,t,n);return this.texData.get(a).usage=null,{dataId:a,shape:t,dtype:n}}makeOutput(t,n,r){return ua().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){let n=new ofe(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new Hhe(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let r=[pl(t.shape),...hl(t.shape)],a={dtype:t.dtype,shape:r,dataId:t.dataId},s=[pl(n),...hl(n)],i=new CL(s,r),o=!0,l=[r],d=this.runWebGLProgram(i,[a],t.dtype,l,o);return{dataId:d.dataId,shape:n,dtype:d.dtype}}decode(t,n){let r=this.texData.get(t),{isPacked:a,shape:s,dtype:i}=r;if(n!=null){let p=k.sizeFromShape(s),h=n[0]*n[1]*4;k.assert(p<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=dh(s),l;a?l=new qpe(o):l=new Gpe(o);let d=!0,u=[n??yg(o)],c=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,u,d,n);return{dtype:i,shape:s,dataId:c.dataId}}runWebGLProgram(t,n,r,a,s=!1,i){let o=this.makeTensorInfo(t.outputShape,r),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===af.DENSE){let y=i??yg(t.outputShape);l.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),k.sizeFromShape(o.shape)===0)return l.values=k.getTypedArrayFromDType(o.dtype,0),o;let d=[],u=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&k.sizeFromShape(y.shape)<=K().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),d.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!sf(b.shape,y.shape)){let v=y,x=y.shape;y.shape=b.shape,y=this.packedReshape(y,x),d.push(y),b=this.texData.get(y.dataId),v.shape=x}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);let c={shape:o.shape,texData:l,isUniform:!1},p=Hpe(t,u,c),h=this.getAndSaveBinary(p,()=>Vpe(this.gpgpu,t,u,c)),f=this.activeTimers!=null,m;f&&(m=this.startTimer()),K().get("ENGINE_COMPILE_ONLY")||jpe(this.gpgpu,h,u,c,a),d.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));let g=K().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){let y=k.now();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!K().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){let y=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),y}return o}compileAndRun(t,n,r,a,s=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,a,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(K().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=j(()=>{if(!K().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=K().getBool("DEBUG");K().set("DEBUG",!1);let n=this.abs(Ce(1e-8)).dataSync()[0];if(K().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?ufe:dfe}uploadToGPU(t){let n=this.texData.get(t),{shape:r,dtype:a,values:s,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let d=this.activeTimers!=null,u;d&&(u=k.now());let c=n.texShape;if(c==null&&(c=qP(r,l),n.texShape=c),s!=null){let p=dh(r),h,f=c[1],m=c[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!g)&&([f,m]=Ip(c[0],c[1])),l?h=new Jpe(p,g):h=new VE(p,g);let y=g?[m,f]:c,b=this.makeTensorInfo(y,a),v=this.texData.get(b.dataId);g?v.usage=Kr.PIXELS:v.usage=Kr.UPLOAD,v.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,m,s);let x=[[m,f]],w=this.runWebGLProgram(h,[b],a,x,!0),I=this.texData.get(w.dataId);n.texShape=I.texShape,n.isPacked=I.isPacked,n.usage=I.usage,K().get("ENGINE_COMPILE_ONLY")?this.disposeData(w.dataId):(n.texture=I.texture,n.values=null,this.texData.delete(w.dataId)),this.disposeIntermediateTensorInfo(b),d&&(this.uploadWaitMs+=k.now()-u)}else{let p=this.acquireTexture(c,o,a,l);n.texture=p}}convertAndCacheOnCPU(t,n){let r=this.texData.get(t),{dtype:a}=r;return n!=null&&(r.values=mfe(n,a)),r.values}acquireTexture(t,n,r,a){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,a)}computeBytes(t,n){return t[0]*t[1]*k.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let r=new Promise(a=>{try{this.checkCompletion_(n),a(!0)}catch(s){throw s}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await HS(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(G2(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:r,infLoc:a,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=aL(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=a,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";let{texture:a,height:s,width:i,channels:o}=t,l=ua().backend;if(!l.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let d=l.writeTexture(a,n,r,s,i,o);return ua().makeTensorFromDataId(d,n,r,l)}};nN.nextDataId=0;function mfe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var gfe="4.22.0";function EL(){K().set("WEBGL_FORCE_F16_TEXTURES",!0)}qf.isBrowser()&&Wb("webgl",()=>new nN,2);var yfe={forceHalfFloat:EL},rN=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,fl=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=E.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=zn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},qu=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,$p=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=E.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=zn(a);let s="";if(r)if(a===0||k.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${bt(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=qn("coords",a);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function zr(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var bfe={kernelName:Xl,backendName:"webgl",kernelFunc:zr};function uo(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=zr({inputs:{x:r},backend:n}),l=zr({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var vfe={kernelName:Cb,backendName:"webgl",kernelFunc:uo},_L="return (a < 0.) ? b * a : a;",$L=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function xfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",k.createScalarValue(s,"float32")),o=K().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $p($L,a.shape,i.shape):new fl(_L,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var wfe={kernelName:Yl,backendName:"webgl",kernelFunc:xfe},AL="return (a < 0.) ? b * a : a;",RL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function kfe(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=K().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $p(RL,r.shape,a.shape):new fl(AL,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}var Sfe={kernelName:mu,backendName:"webgl",kernelFunc:kfe},Ap="if (isnan(x)) return x;";function nt({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let{x:i}=a,o=s,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let c=o.texData.get(i.dataId),p=n(c.values,l);return o.makeTensorInfo(i.shape,l,p)}let d=K().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,u;return d?u=new yi(i.shape,t):u=new rs(i.shape,e),o.runWebGLProgram(u,[i],l)}}function Rn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:d}=i,u=o;if(r&&l.dtype==="complex64"){let f=u.texData.get(l.dataId),m=u.texData.get(d.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(v=>{let[x,w]=v,I={dataId:x.dataId,dtype:x.dtype,shape:l.shape},N={dataId:w.dataId,dtype:w.dtype,shape:d.shape},T=new fl(e,l.shape,d.shape);return u.runWebGLProgram(T,[I,N],ea(x.dtype,w.dtype))}),b=uo({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}let c=s||ea(l.dtype,d.dtype);if((l.dtype==="string"||d.dtype==="string"||u.shouldExecuteOnCPU([l,d]))&&a!=null){let f=u.texData.get(l.dataId).values,m=u.texData.get(d.dataId).values,g=l.dtype==="string"?E.fromUint8ToStringArray(f):f,y=l.dtype==="string"?E.fromUint8ToStringArray(m):m,[b,v]=a(l.shape,d.shape,g,y,c),x=u.makeTensorInfo(v,c),w=u.texData.get(x.dataId);return w.values=b,x}let p=K().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,h;return p?h=new $p(t,l.shape,d.shape,n):h=new fl(e,l.shape,d.shape),u.runWebGLProgram(h,[l,d],c)}}function of(e,t=!1){if(e==="linear")return t?nfe:Jhe;if(e==="relu")return t?afe:Yhe;if(e==="elu")return t?rfe:Zhe;if(e==="relu6")return t?sfe:efe;if(e==="prelu")return t?RL:AL;if(e==="leakyrelu")return t?$L:_L;if(e==="sigmoid")return t?ife:tfe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var FL=class{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=zn(this.outputShape.length);let d=r?e[1]:e[2],u=Math.ceil(d/2),c=r?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${v};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${c});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${f[0]});
          result += (${h[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${g}

        setOutput(result);
      }
    `}},KE={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},XE=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=E.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},QE="return a * b;";function aN(e){let{inputs:t,backend:n}=e,{a:r,b:a}=t,s=E.upcastType(r.dtype,a.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),d=new XE(KE.REAL,r.shape,a.shape),u=new XE(KE.IMAG,r.shape,a.shape),c=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:a.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:a.shape}],p=n.runWebGLProgram(d,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),f=uo({inputs:{real:p,imag:h},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}if(n.shouldExecuteOnCPU([r,a])){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),[d,u]=xhe(r.shape,a.shape,o.values,l.values,s),c=n.makeTensorInfo(u,s),p=n.texData.get(c.dataId);return p.values=d,c}let i;return K().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new $p(QE,r.shape,a.shape):i=new fl(QE,r.shape,a.shape),n.runWebGLProgram(i,[r,a],s)}var Ife={kernelName:cu,backendName:"webgl",kernelFunc:aN};function Nfe(e,t,n){let r=[pl(e.shape),...hl(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[pl(t),...hl(t)],i=new CL(s,r),o=!0,l=[r],d=n.runWebGLProgram(i,[a],e.dtype,l,o);return{dataId:d.dataId,shape:t,dtype:d.dtype}}function he(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=k.sizeFromShape(a.shape),l=k.inferFromImplicitShape(s,o),d=k.sizeFromShape(l);k.assert(o===d,()=>`The new shape (${l}) has ${d} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let u=i.texData.get(a.dataId);return u.isPacked&&!sf(a.shape,l)&&!(u.texture!==null&&sf(u.shape,l))?Nfe(a,l,i):(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype})}var Cfe={kernelName:Xc,backendName:"webgl",kernelFunc:he},JE=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let u=1/t;l=`sumValue += dot(values * ${k.isInt(u)?u.toPrecision(2):u}, ones);`}let d="";a%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},Tfe=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let d=Math.floor(n/4)*4,u=n%4,c=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(i="1.0",c=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(i="0.0",c=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let h="";a%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${d};
        if (${u===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${u===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${u===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${c}
        }
        setOutput(${l});
      }
    `}};function Efe(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=E.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function Ku(e,t,n,r){let a=Efe(e.shape),s=e;for(let i=0;i<a.length;i++){let{inSize:o,windowSize:l,outSize:d}=a[i],u,c;n==="mean"?u=i===0?new JE({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:d},o):new JE({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:d}):u=new Tfe({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:d},n),c=s,s=r.runWebGLProgram(u,[s],t),c.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(c)}return s}var _fe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=bt(this.rank),a=$fe(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}};function $fe(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}var Afe=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let d=0;d<n.length;d++)n[d]=e[t[d]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=bt(this.rank),a=NL("rc",this.rank),s=new Array(this.rank);for(let d=0;d<t.length;d++)s[t[d]]=a[d];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function Gv(e,t,n){let r=K().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Afe(e.shape,t):new _fe(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function Rfe(e,t,n,r){let a=t,s=e.shape.length,i=k.parseAxisParam(a,e.shape),o=i,l=E.getAxesPermutation(o,s),d=l!=null,u=e;d&&(u=Gv(e,l,r),o=E.getInnerMostAxes(o.length,s)),E.assertAxesAreInnerMostDims("sum",o,s);let[c,p]=E.computeOutAndReduceShapes(u.shape,o),h=c;n&&(h=E.expandShapeToKeepDim(c,i));let f=k.sizeFromShape(p),m=k.sizeFromShape(e.shape)/f,g=he({inputs:{x:u},attrs:{shape:[m,f]},backend:r}),y=Bb(e.dtype),b=Ku(g,y,"sum",r),v=he({inputs:{x:b},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),d&&r.disposeIntermediateTensorInfo(u),v}function qv(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return Rfe(a,s,i,n)}var Ffe={kernelName:Ru,backendName:"webgl",kernelFunc:qv};function Zn(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,i=n,o=a.shape.length,l=new Array(o);for(let u=0;u<l.length;u++)l[u]=a.shape[s[u]];let d;if(i.shouldExecuteOnCPU([a])){let u=i.texData.get(a.dataId).values,c=tN(u,a.shape,a.dtype,s,l);d=i.makeTensorInfo(l,a.dtype);let p=i.texData.get(d.dataId);p.values=c}else d=Gv(a,s,i);return d}var Dfe={kernelName:As,backendName:"webgl",kernelFunc:Zn},DL=1e3;function jy({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let d=e.shape.length,u=t.shape.length,c=n?e.shape[d-2]:e.shape[d-1],p=r?t.shape[u-1]:t.shape[u-2],h=n?e.shape[d-1]:e.shape[d-2],f=r?t.shape[u-2]:t.shape[u-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=k.sizeFromShape(m),b=k.sizeFromShape(g),v=hp.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);k.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let x=n?[y,c,h]:[y,h,c],w=r?[b,f,p]:[b,p,f],I=he({inputs:{x:e},backend:a,attrs:{shape:x}}),N=he({inputs:{x:t},backend:a,attrs:{shape:w}}),T=[I,N],A=Math.max(y,b),R=n?I.shape[1]:I.shape[2],F=s!=null,C=i!=null,M=l==="leakyrelu",B=l!=null?of(l,!0):null,U=F||C||M||B!=null,G;if((h===1||f===1)&&R>DL&&U===!1){let P=I,q=N;n&&(P=Zn({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),T.push(P)),r&&(q=Zn({inputs:{x:N},backend:a,attrs:{perm:[0,2,1]}}),T.push(q));let Q=f!==1,J=f===1,re=P;Q&&(re=he({inputs:{x:P},backend:a,attrs:{shape:[A,R,1]}}),T.push(re));let ae=f===1?2:1,ie=q;J&&(ie=he({inputs:{x:q},backend:a,attrs:{shape:[A,1,R]}}),T.push(ie));let le=aN({inputs:{a:re,b:ie},backend:a});G=qv({inputs:{x:le},backend:a,attrs:{axis:ae,keepDims:!0}}),T.push(le)}else{let P=ea(e.dtype,t.dtype),q=new FL(x,w,[A,h,f],n,r,F,B,C,M),Q=[I,N];if(s!=null&&Q.push(s),C&&Q.push(i),M){let J=a.makeTensorInfo([],"float32",k.createScalarValue(o,"float32"));Q.push(J),T.push(J)}G=a.runWebGLProgram(q,Q,P)}let X=he({inputs:{x:G},backend:a,attrs:{shape:v}});T.push(G);for(let P of T)a.disposeIntermediateTensorInfo(P);return X}function Mfe(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:d,activation:u,leakyreluAlpha:c}=r;return jy({a,b:s,transposeA:l,transposeB:d,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:c,activation:u})}var Ofe={kernelName:Jo,backendName:"webgl",kernelFunc:Mfe},ZE="return abs(x);";function Pfe(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=n.texData.get(r.dataId),i=SL(s.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let a;return K().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new yi(r.shape,ZE):a=new rs(r.shape,ZE),n.runWebGLProgram(a,[r],r.dtype)}var Lfe={kernelName:cc,backendName:"webgl",kernelFunc:Pfe},zfe=wa+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Bfe=nt({opSnippet:zfe}),Wfe={kernelName:xl,backendName:"webgl",kernelFunc:Bfe},Ufe=wa+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Vfe=nt({opSnippet:Ufe}),jfe={kernelName:wl,backendName:"webgl",kernelFunc:Vfe},YE="return a + b;",Hfe=Rn({opSnippet:YE,packedOpSnippet:YE,supportsComplex:!0,cpuKernelImpl:Ype}),Gfe={kernelName:Yi,backendName:"webgl",kernelFunc:Hfe},qfe=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`float v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},Kfe=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`vec4 v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function Gg(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return zr({inputs:{x:r[0]},backend:n});if(r.length>K().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=Gg({inputs:r.slice(0,o),backend:n}),d=Gg({inputs:r.slice(o),backend:n});return Gg({inputs:[l,d],backend:n})}let a=r.map(o=>o.dtype).reduce((o,l)=>ea(o,l)),s=r.map(o=>o.shape),i=K().getBool("WEBGL_PACK")?new Kfe(r[0].shape,s):new qfe(r[0].shape,s);return n.runWebGLProgram(i,r,a)}var Xfe={kernelName:kl,backendName:"webgl",kernelFunc:Gg};function Qfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=k.parseAxisParam(s,a.shape),d=l,u=E.getAxesPermutation(d,o),c=a;u!=null&&(c=Zn({inputs:{x:a},backend:n,attrs:{perm:u}}),d=E.getInnerMostAxes(d.length,o)),E.assertAxesAreInnerMostDims("all",d,o);let[p,h]=E.computeOutAndReduceShapes(c.shape,d),f=k.sizeFromShape(h),m=he({inputs:{x:c},backend:n,attrs:{shape:[-1,f]}}),g=Ku(m,m.dtype,"all",n),y;if(i){let b=E.expandShapeToKeepDim(p,l);y=he({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=he({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(c),y}var Jfe={kernelName:pc,backendName:"webgl",kernelFunc:Qfe};function Zfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=k.parseAxisParam(s,a.shape),d=l,u=E.getAxesPermutation(d,o),c=a;u!=null&&(c=Zn({inputs:{x:a},backend:n,attrs:{perm:u}}),d=E.getInnerMostAxes(d.length,o)),E.assertAxesAreInnerMostDims("any",d,o);let[p,h]=E.computeOutAndReduceShapes(c.shape,d),f=k.sizeFromShape(h),m=he({inputs:{x:c},backend:n,attrs:{shape:[-1,f]}}),g=Ku(m,m.dtype,"any",n),y;if(i){let b=E.expandShapeToKeepDim(p,l);y=he({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=he({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(c),y}var Yfe={kernelName:hc,backendName:"webgl",kernelFunc:Zfe},eme=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},tme=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,k.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=bt(o),d=qn("coords",o),u,c;if(s===1){c=o+1;let N=bt(c);u=`
        ${N} sourceLocR = ${N}(${d.join()}, 0);
        ++${d[o-1]};
        ${N} sourceLocG = ${N}(${d.join()}, 0);
        ++${d[o-2]};
        ${N} sourceLocA = ${N}(${d.join()}, 0);
        --${d[o-1]};
        ${N} sourceLocB = ${N}(${d.join()}, 0);
        --${d[o-2]};`}else c=o,u=`
        ${l} sourceLocR = coords;
        ++${d[o-1]};
        ${l} sourceLocG = coords;
        ++${d[o-2]};
        ${l} sourceLocA = coords;
        --${d[o-1]};
        ${l} sourceLocB = coords;
        --${d[o-2]};`;let p=["x","y","z","w","u","v"].slice(0,c),h="."+p[c-1],f=p.map(N=>"int "+N),m=qn("sourceLocR",c-1).concat("inIdx.r"),g=qn("sourceLocG",c-1).concat("inIdx.g"),y=qn("sourceLocB",c-1).concat("inIdx.b"),b=qn("sourceLocA",c-1).concat("inIdx.a"),v=n==="max"?"greaterThan":"lessThan",x=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,I=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${I}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${d[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${d[o-2]} < ${i[o-2]-1};
        ${u}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${x}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function ML(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];r!=null&&(a=r.shape[0],s=r.shape[1]);let i=E.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new eme(o,n,r==null),d=[t];r!=null&&d.push(r);let u=e.runWebGLProgram(l,d,"int32");if(u.shape[1]===1)return u;let c=ML(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}function OL(e,t,n,r=null){let a=r!=null?r.shape:t.shape,s=a[a.length-1],i=E.computeOptimalWindowSize(s),o=new tme(a,i,n,r==null),l=r==null?[t]:[t,r],d=e.runWebGLProgram(o,l,"int32");if(d.shape.length===t.shape.length){let u=OL(e,t,n,d);return e.disposeIntermediateTensorInfo(d),u}return d}function PL(e,t,n,r){let a=[n];if(E.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!K().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),s.push(l));let[d,u]=E.computeOutAndReduceShapes(l.shape,a),c=k.sizeFromShape(u),p=he({inputs:{x:l},backend:e,attrs:{shape:[-1,c]}});s.push(p);let h=ML(e,p,r);s.push(h);let f=he({inputs:{x:h},backend:e,attrs:{shape:d}});return s.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return OL(e,t,r)}function nme(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=k.parseAxisParam(s,a.shape),o=E.getAxesPermutation(i,a.shape.length),l=a,d=[];o!=null&&(l=Zn({inputs:{x:a},backend:n,attrs:{perm:o}}),d.push(l),i=E.getInnerMostAxes(i.length,l.shape.length)),E.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let u=PL(n,l,i[0],"max");return d.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var rme={kernelName:fc,backendName:"webgl",kernelFunc:nme};function ame(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=k.parseAxisParam(s,a.shape),o=E.getAxesPermutation(i,a.shape.length),l=a,d=[];o!=null&&(l=Zn({inputs:{x:a},backend:n,attrs:{perm:o}}),d.push(l),i=E.getInnerMostAxes(i.length,l.shape.length)),E.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let u=PL(n,l,i[0],"min");return d.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var sme={kernelName:mc,backendName:"webgl",kernelFunc:ame},ime=wa+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ome=nt({opSnippet:ime}),lme={kernelName:Sl,backendName:"webgl",kernelFunc:ome},ume=wa+"return log(x + sqrt(x * x + 1.0));",dme=nt({opSnippet:ume}),cme={kernelName:Il,backendName:"webgl",kernelFunc:dme},pme=wa+`
  return atan(x);
`,hme=nt({opSnippet:pme}),fme={kernelName:Nl,backendName:"webgl",kernelFunc:hme},mme=rN+`
  return atan(a, b);
`,gme=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+qu+`
  return result;
`,yme=Rn({opSnippet:mme,packedOpSnippet:gme}),bme={kernelName:Tl,backendName:"webgl",kernelFunc:yme},vme=wa+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,xme=nt({opSnippet:vme}),wme={kernelName:Cl,backendName:"webgl",kernelFunc:xme},lf=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,d=e.dilationWidth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let N=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${p}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${u};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${c};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${N} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?m:g:`wR * ${c} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b="max",v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(v="avgValue / max(count, 1.0)");let x=Math.floor(s/4)*4,w=s%4,I=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${p}, ${h});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${u};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${x}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${I}
          }

          int xC = xCCorner + ${x};
          if (${w===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${w===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${w===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${I}
          }
        }
        setOutput(${v});
      }
    `}},sN=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,d=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b=t==="avg",v="0.0";if(b||(v="-1.0 / 1e-20"),n){let A=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${u}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${c}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");let I=Math.floor(s/4)*4,N=s%4,T=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${I}; wC += 4) {
              int xC = xCCorner + wC * ${c};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                getValue(batch, xD, xR, xC + 3 * ${c}, ch)
              );

              ${T}
            }

            int xC = xCCorner + ${I};
            if (${N===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${N===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                initializationValue,
                initializationValue
              );

              ${T}
            } else if (${N===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                initializationValue
              );

              ${T}
            }
          }
        }
        setOutput(${w});
      }
    `}};function kme(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Np(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,d=1;k.assert(E.eitherStridesOrDilationsAreOne(i,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let u=E.computePool2DInfo(a.shape,s,i,d,o,l);if(u.filterWidth===1&&u.filterHeight===1&&k.arraysEqual(u.inShape,u.outShape))return zr({inputs:{x:a},backend:n});let c=new lf(u,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}var Sme={kernelName:El,backendName:"webgl",kernelFunc:kme};function Ime(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:d}=r,u=[1,1,1],c=E.computePool3DInfo(a.shape,s,i,u,o,l,d),p=new sN(c,"avg",!1);return n.runWebGLProgram(p,[a],"float32")}var Nme={kernelName:gc,backendName:"webgl",kernelFunc:Ime},Cme=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,d=o-1-e.padInfo.top,u=l-1-e.padInfo.left,c=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${u});
      const float avgMultiplier = float(${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Tme=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,d=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=u-1-e.padInfo.front,f=c-1-e.padInfo.top,m=p-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${f}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Eme(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:d,dimRoundingMode:u}=r,c=[1,1,1],p=E.computePool3DInfo(i.shape,o,l,c,d,u),h=new Tme(p);return n.runWebGLProgram(h,[a],i.dtype)}var _me={kernelName:If,backendName:"webgl",kernelFunc:Eme};function $me(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;Np([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:d}=r,u=E.computePool2DInfo(i.shape,o,l,1,d),c=new Cme(u);return n.runWebGLProgram(c,[a],i.dtype)}var Ame={kernelName:Sf,backendName:"webgl",kernelFunc:$me};function Rme(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;return jy({a,b:s,transposeA:i,transposeB:o,backend:n})}var Fme={kernelName:_l,backendName:"webgl",kernelFunc:Rme},Dme=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],E.assertAndGetBroadcastShape(e,t),E.assertAndGetBroadcastShape(e,n);let i="0.0";r!=null&&(E.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";a!=null&&(E.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},Mme=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],E.assertAndGetBroadcastShape(e,t),E.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";r!=null&&(E.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";a!=null&&(E.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},Ome=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;k.assert(a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k.assert(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let d=[r,a,s],u=null;i!=null&&(u=i.shape,d.push(i));let c=null;o!=null&&(c=o.shape,d.push(o));let p=K().getBool("WEBGL_PACK_NORMALIZATION")?new Mme(r.shape,a.shape,s.shape,u,c,l):new Dme(r.shape,a.shape,s.shape,u,c,l);return t.runWebGLProgram(p,d,d[0].dtype)},Pme={kernelName:ql,backendName:"webgl",kernelFunc:Ome},Lme=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=bt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=zme(this.rank),r,a=e.map((s,i)=>`sourceLoc.${n1[i]} = start[${i}] + coords.${n1[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},n1=["x","y","z","w","u","v"];function zme(e){if(e===1)return"sourceLoc";if(e<=6)return n1.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var Bme=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=bt(this.rank),n=qn("coords",this.rank),r=qn("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${s};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,u)=>`start[${u}]`).join()});`:e.map((d,u)=>`${r[u]} = ${n[u]} + start[${u}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function Wme(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=ln.computeFlatOffset(t,k.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function Rp(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=ln.parseSliceParams(a,s,i);if(ln.assertParamsValid(a,o,l),k.sizeFromShape(l)===0)return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||a.dtype==="string"){let c=n.texData.get(a.dataId),p=Ahe(c.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,p)}let{isPacked:d}=n.texData.get(a.dataId),u=ln.isSliceContinous(a.shape,o,l);if(d||!u){let c=K().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bme(l):new Lme(l),p=[o];return n.runWebGLProgram(c,[a],a.dtype,p)}return n.uploadToGPU(a.dataId),Wme(a,o,l,n)}var Ume={kernelName:np,backendName:"webgl",kernelFunc:Rp},Vme=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;k.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((b,v)=>b*v),l=E.getReshaped(a.shape,s,o),d=E.getPermuted(l.length,s.length),u=E.getReshapedPermuted(a.shape,s,o),c=E.getSliceBeginCoords(i,s.length),p=E.getSliceSize(u,i,s.length),h=[],f=he({inputs:{x:a},backend:n,attrs:{shape:l}}),m=Zn({inputs:{x:f},backend:n,attrs:{perm:d}}),g=he({inputs:{x:m},backend:n,attrs:{shape:u}}),y=Rp({inputs:{x:g},backend:n,attrs:{begin:c,size:p}});return h.push(f),h.push(m),h.push(g),h.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},jme={kernelName:yc,backendName:"webgl",kernelFunc:Vme};function Hme(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),d=kL(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,d)}var Gme={kernelName:bc,backendName:"webgl",kernelFunc:Hme},qme=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Kme=`
  return float(int(a.r) & int(b.r));
`;function Xme(e){let{inputs:t,backend:n}=e,{a:r,b:a}=t,s=K().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=K().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||i===1){let l=n.texData.get(r.dataId).values,d=n.texData.get(a.dataId).values,[u,c]=the(r.shape,a.shape,l,d,r.dtype),p=n.makeTensorInfo(c,r.dtype),h=n.texData.get(p.dataId);return h.values=u,p}let o;return s?o=new $p(qme,r.shape,a.shape,!1):o=new fl(Kme,r.shape,a.shape),n.runWebGLProgram(o,[r,a],r.dtype)}var Qme={kernelName:vc,backendName:"webgl",kernelFunc:Xme};function Jme(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=E.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Zme={kernelName:Nf,backendName:"webgl",kernelFunc:Jme},Yme="return float(a != b);",LL=Rn({opSnippet:Yme,cpuKernelImpl:khe,dtype:"bool"}),ege={kernelName:Vc,backendName:"webgl",kernelFunc:LL};function wm(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return zr({inputs:{x:a.complexTensorInfos.real},backend:n})}var tge={kernelName:Lb,backendName:"webgl",kernelFunc:wm},nge="return float(int(x));";function rge(e,t){let n=new rs(e.shape,nge),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function r1(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return zr({inputs:{x:a},backend:n});let i=Dt(a.shape),o=r1({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=uo({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(a.dtype==="complex64"){let i=wm({inputs:{input:a},backend:n}),o=r1({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!k.hasEncodingLoss(a.dtype,s)){let i=zr({inputs:{x:a},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([a])){let i=n.texData.get(a.dataId).values,[o,l,d]=nhe(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,d)}if(s==="int32")return rge(a,n);if(s==="bool"){let i=n.makeTensorInfo([],"bool",k.getTypedArrayFromDType("bool",1)),o=LL({inputs:{a,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var age={kernelName:$l,backendName:"webgl",kernelFunc:r1},e_="return ceil(x);",sge=nt({opSnippet:e_,packedOpSnippet:e_,cpuKernelImpl:rhe}),ige={kernelName:Al,backendName:"webgl",kernelFunc:sge},oge=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},lge=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function uge(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o;K().getBool("WEBGL_PACK_CLIP")?o=new lge(a.shape):o=new oge(a.shape);let l=[[s],[i]];return n.runWebGLProgram(o,[a],a.dtype,l)}var dge={kernelName:eo,backendName:"webgl",kernelFunc:uge},cge=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function t_(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function pge(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new cge(r.shape),i=[t_(r,a.complexTensorInfos.real),t_(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var hge={kernelName:Cf,backendName:"webgl",kernelFunc:pge},fge=class{constructor(e){this.outputShape=[],this.outputShape=E.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},mge=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=E.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=bt(r),s=qn("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,m)=>`T${m}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],d=i.slice(-2),u=i.join(),c=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${u}), vec2(${d.join()}));
        }`;for(let f=1;f<o.length;f++){let m=o[f-1];c+=`
        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {
          return getChannel(
            getT${f}(${vg(i,l,m)}),
            vec2(${vg(d,l,m)}));
        }`}let p=o.length,h=o[o.length-1];c+=`
        return getChannel(
          getT${p}(${vg(i,l,h)}),
          vec2(${vg(d,l,h)}));`,this.userCode=`
      float getValue(${i.map(f=>"int "+f)}) {
        ${c}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[r-1]} = ${s[r-1]} + 1;
        if (${s[r-1]} < ${n[r-1]}) {
          result.g = getValue(${s});
        }

        ${s[r-2]} = ${s[r-2]} + 1;
        if (${s[r-2]} < ${n[r-2]}) {
          result.a = getValue(${s});
        }

        ${s[r-1]} = ${s[r-1]} - 1;
        if (${s[r-2]} < ${n[r-2]} &&
            ${s[r-1]} < ${n[r-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function vg(e,t,n){let r=e.indexOf(t);return e.map((a,s)=>s===r?`${a} - ${n}`:a).join()}function Kv(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return zr({inputs:{x:a.complexTensorInfos.imag},backend:n})}var gge={kernelName:Db,backendName:"webgl",kernelFunc:Kv};function ch(e,t,n){let r=e[0].dtype;if(r==="complex64"){let h=e.map(b=>wm({inputs:{input:b},backend:n})),f=e.map(b=>Kv({inputs:{input:b},backend:n})),m=ch(h,t,n),g=ch(f,t,n),y=uo({inputs:{real:m,imag:g},backend:n});return h.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let a=n.shouldExecuteOnCPU(e);if(r==="string"&&(a=!0),a){let h=e.map(x=>{let w=[-1,k.sizeFromShape(x.shape.slice(t))];return he({inputs:{x},backend:n,attrs:{shape:w}})}),f=h.map(x=>({vals:n.readSync(x.dataId),shape:x.shape})),m=E.computeOutShape(h.map(x=>x.shape),1),g=h[0].shape[0]===1,y=ahe(f,m,r,g),b=E.computeOutShape(e.map(x=>x.shape),t),v=n.makeTensorInfo(b,r,y);return h.forEach(x=>n.disposeIntermediateTensorInfo(x)),v}let s=e.filter(h=>k.sizeFromShape(h.shape)>0),i=K().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let h=i?new rs(e[0].shape,oi):new yi(e[0].shape,oi);return n.runWebGLProgram(h,e,r)}let o=K().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let h=[];for(let m=0;m<s.length;m+=o){let g=s.slice(m,m+o);h.push(ch(g,t,n))}let f=ch(h,t,n);for(let m of h)n.disposeIntermediateTensorInfo(m);return f}if(i){let h=new mge(s.map(f=>f.shape),t);return n.runWebGLProgram(h,s,r)}let{tensors2D:l,outShape:d}=yge(s,t,n),u=new fge(l.map(h=>h.shape)),c=n.runWebGLProgram(u,l,r);l.forEach(h=>n.disposeIntermediateTensorInfo(h));let p=he({inputs:{x:c},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(c),p}function yge(e,t,n){let r=E.computeOutShape(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>he({inputs:{x:a},attrs:{shape:[-1,k.sizeFromShape(a.shape.slice(t))]},backend:n})),outShape:r}}function zL(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=k.parseAxisParam(a,t[0].shape)[0],i=t.map(d=>d.shape);E.assertParamsConsistent(i,s);let o=E.computeOutShape(t.map(d=>d.shape),s);if(k.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(d=>k.sizeFromShape(d.shape)>0);return l.length===1?zr({inputs:{x:l[0]},backend:n}):ch(l,s,n)}var bge={kernelName:xc,backendName:"webgl",kernelFunc:zL},BL=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,d=e.dilationHeight,u=e.dilationWidth,c=e.filterHeight,p=e.filterWidth,h=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,y=m?2:3,b=m?3:1,v="",x="";n&&(r?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:v=`
          float activation(float x) {
            ${n}
          }
        `,x="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${u};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${x}
        setOutput(result);
      }
    `}},vge=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,d=e.dilationWidth,u=e.filterDepth,c=e.filterHeight,p=e.filterWidth,h=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${u}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},WL=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zn(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,d=e.filterWidth,u=d,c=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<d;m++)c+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;c+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<d;m++)c+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;c+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(u+1)/2;m++){let g=m*2;if(c+=`
           xC = xCCorner + ${g*o};
           `,i===1){if(g<d&&(s%2===1?(c+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,o===1&&g>0?c+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:c+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):c+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<d)){let y=s%2===0?k.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(c+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,o>1?c+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:c+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):y===1?c+=`
                     xC${g+1} = xTexelC${g};
                     `:c+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<d&&(s%2===1?(c+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<d&&(c+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(c+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<d&&(c+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<d&&(c+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<d&&(c+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}c+=`
     }
   `,c+=`
     }
   `,c+=`
     }
   `;let p="",h="";n&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:a?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:p=`vec4 activation(vec4 x) {
           ${n}
         }`,h="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${c}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${h}
         setOutput(result);
       }
     `}},xge=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=zn(this.outputShape.length);let{dataFormat:n}=t,r=rr(),a=n==="channelsLast",s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let d=0;d<=1;d++)for(let u=0;u<=1;u++)l+=`
          blockIndex = rc.z + ${u};
          pos = rc.y + ${d};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+u}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+u}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function Hy(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function UL({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,d=r.texData.get(e.dataId),u=n.inChannels,c=l[0]*l[1]*l[2],p=n.outChannels,h=n.dataFormat==="channelsLast",f=!1,m=!1,g,y=[];if(s!=null){let b=Hy(s.shape,h);b!=null&&(s=he({inputs:{x:s},backend:r,attrs:{shape:b}}),y.push(s))}if(a!=null){let b=Hy(a.shape,h);b!=null&&(a=he({inputs:{x:a},backend:r,attrs:{shape:b}}),y.push(a))}if(!((c===1||p===1)&&u>DL)&&d.isPacked&&h&&d.texture!=null&&l[2]%2!==0&&k.arraysEqual(d.shape.slice(-3),l.slice(-3))){let b=l[0]*l[1]*(l[2]+1),v={dataId:e.dataId,shape:[1,b,n.inChannels],dtype:e.dtype},x=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,k.assert(sf(d.shape,v.shape),()=>`packed reshape ${d.shape} to ${v.shape} isn't free`);let w=he({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(w);let I=jy({a:v,b:w,backend:r,transposeA:f,transposeB:m,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),N=r.texData.get(I.dataId);k.assert(N.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=x,N.shape=n.outShape,g=zr({inputs:{x:I},backend:r}),g.shape=n.outShape,y.push(I)}else{let b=n.outHeight*n.outWidth,v=he({inputs:{x:e},backend:r,attrs:{shape:h?[n.batchSize,b,n.inChannels]:[n.batchSize,n.inChannels,b]}}),x=he({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),w=jy({a:h?v:x,b:h?x:v,transposeA:!h,transposeB:m,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i});g=he({inputs:{x:w},backend:r,attrs:{shape:n.outShape}}),y.push(v),y.push(x),y.push(w)}for(let b of y)r.disposeIntermediateTensorInfo(b);return g}function VL({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:d,inChannels:u,outWidth:c,outHeight:p,dataFormat:h}=n,f=h==="channelsLast",m=l*d*u,g=p*c,y=[n.batchSize,m,g],b=!0,v=!1,x=[];if(s!=null){let P=Hy(s.shape,f);P!=null&&(s=he({inputs:{x:s},backend:r,attrs:{shape:P}}),x.push(s))}if(a!=null){let P=Hy(a.shape,f);P!=null&&(a=he({inputs:{x:a},backend:r,attrs:{shape:P}}),x.push(a))}let w=he({inputs:{x:t},backend:r,attrs:{shape:[1,m,k.sizeFromShape(t.shape)/m]}});x.push(w);let I=new xge(y,n),N=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],T=r.runWebGLProgram(I,[e],"float32",N),A=he({inputs:{x:T},backend:r,attrs:{shape:y}});x.push(T),x.push(A);let R=a!=null,F=s!=null,C=o==="leakyrelu",M=o?of(o,!0):null,B=new FL(f?A.shape:w.shape,f?w.shape:A.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,v,R,M,F,C),U=f?[A,w]:[w,A];if(a&&U.push(a),F&&U.push(s),C){let P=r.makeTensorInfo([],"float32",k.createScalarValue(i,"float32"));U.push(P),x.push(P)}let G=r.runWebGLProgram(B,U,"float32"),X=he({inputs:{x:G},backend:r,attrs:{shape:n.outShape}});x.push(G);for(let P of x)r.disposeIntermediateTensorInfo(P);return X}function wge(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:d,dimRoundingMode:u}=r,c=E.convertConv2DDataFormat(l),p=E.computeConv2DInfo(a.shape,s.shape,i,d,o,u,!1,c),h;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))h=UL({x:a,filter:s,convInfo:p,backend:n});else if(p.strideWidth<=2&&c==="channelsLast"&&K().getBool("WEBGL_EXP_CONV")){let m=new WL(p),g=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];h=n.runWebGLProgram(m,[a,s],"float32",g)}else if(K().getBool("WEBGL_CONV_IM2COL"))h=VL({x:a,filter:s,convInfo:p,backend:n});else{let m=new BL(p);h=n.runWebGLProgram(m,[a,s],"float32")}let f=he({inputs:{x:h},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(h),f}var kge={kernelName:Rl,backendName:"webgl",kernelFunc:wge},Sge=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Ige=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,d=s?2:3,u=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${u}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Nge=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Cge=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,d=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Tge(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:d,filterShape:u}=r,c=E.convertConv2DDataFormat(l),p=E.computeConv2DInfo(a.shape,u,i,1,o,d,!1,c),h=new Sge(p);return n.runWebGLProgram(h,[a,s],"float32")}var Ege={kernelName:Tb,backendName:"webgl",kernelFunc:Tge},_ge=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=zn(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function $ge(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:d,dimRoundingMode:u}=r,c=E.convertConv2DDataFormat(d),p=E.computeConv2DInfo(i,s.shape,o,1,l,u,!1,c);if(K().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&c==="channelsLast"){let h=[[p.strideHeight,p.strideWidth]],f=new _ge(p);return n.runWebGLProgram(f,[a,s],"float32",h)}else{let h=new Ige(p);return n.runWebGLProgram(h,[a,s],"float32")}}var Age={kernelName:Fl,backendName:"webgl",kernelFunc:$ge};function Rge(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,d=E.computeConv3DInfo(a.shape,s.shape,i,l,o),u=new vge(d);return n.runWebGLProgram(u,[a,s],"float32")}var Fge={kernelName:Dl,backendName:"webgl",kernelFunc:Rge};function Dge(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,d=E.computeConv3DInfo(a.shape,l,i,1,o),u=new Nge(d);return n.runWebGLProgram(u,[a,s],"float32")}var Mge={kernelName:wc,backendName:"webgl",kernelFunc:Dge};function Oge(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,d=E.computeConv3DInfo(l,s.shape,o,1,i),u=new Cge(d);return n.runWebGLProgram(u,[a,s],"float32")}var Pge={kernelName:kc,backendName:"webgl",kernelFunc:Oge},Lge=Ap+`
  return cos(x);
`,zge=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${qu}
  return result;
`,Bge=nt({opSnippet:Lge,packedOpSnippet:zge}),Wge={kernelName:Ml,backendName:"webgl",kernelFunc:Bge},Uge=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Vge=nt({opSnippet:Uge}),jge={kernelName:Ol,backendName:"webgl",kernelFunc:Vge},Hge=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[d]=t,[u,c]=n;this.outputShape=[d,u,c,l];let p=r==="bilinear"?1:0,[h,f]=[`${i-1}.0`,`${o-1}.0`],[m,g,y]=u>1?[`${(i-1)/(u-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,v,x]=c>1?[`${(o-1)/(c-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${v};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${x};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},Gge=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:d}=r,u=new Hge(a.shape,s.shape,o,l,d);return n.runWebGLProgram(u,[a,s,i],"float32")},qge={kernelName:Ic,backendName:"webgl",kernelFunc:Gge},uf;(function(e){e.Prod="*",e.Sum="+"})(uf||(uf={}));var n_=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===uf.Prod?"1.0":"0.0",i=n?s:`getX(${r_(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",d="";n?(l=r?`end != ${o-1}`:"end != 0",d=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${bt(a)} coords = getOutputCoords();
        int end = ${a_(a,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${d};
          ${a_(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${r_(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function r_(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function a_(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function jL(e,t,n,r,a,s){let i=t.shape.length,o=E.getAxesPermutation([r],i),l=t;o!=null&&(l=Zn({inputs:{x:t},backend:n,attrs:{perm:o}}));let d=E.getInnerMostAxes(1,i)[0];if(d!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let u=l.shape[d],c=zr({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(u))-1;p++){let h=new n_(e,l.shape,!1,s),f=[[p]],m=c;c=n.runWebGLProgram(h,[c],c.dtype,f),n.disposeIntermediateTensorInfo(m)}if(a){let p=new n_(e,l.shape,a,s),h=c;c=n.runWebGLProgram(p,[c],c.dtype),n.disposeIntermediateTensorInfo(h)}if(o!=null){let p=E.getUndoAxesPermutation(o),h=Zn({inputs:{x:c},backend:n,attrs:{perm:p}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),h}return c}function Kge(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return jL(uf.Prod,a,n,s,i,o)}var Xge={kernelName:Sc,backendName:"webgl",kernelFunc:Kge};function Qge(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return jL(uf.Sum,a,n,s,i,o)}var Jge={kernelName:Pl,backendName:"webgl",kernelFunc:Qge};function Zge(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.readSync(a.dataId),d=n.readSync(s.dataId),u=kL(l,d,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(a.shape.length===2){let l=n.bufferSync(a),d=n.bufferSync(s),u=ehe(l,d,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var Yge={kernelName:Tf,backendName:"webgl",kernelFunc:Zge},eye=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function tye(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],d=i==="NHWC"?a.shape[2]:a.shape[3],u=i==="NHWC"?a.shape[3]:a.shape[1],c=l*s,p=d*s,h=u/(s*s),f=i==="NHWC"?[o,c,p,h]:[o,h,c,p],m=new eye(f,s,i);return n.runWebGLProgram(m,[a],a.dtype)}var nye={kernelName:Nc,backendName:"webgl",kernelFunc:tye},HL=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zn(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",d="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,d="result = activation(result);");let u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${u}
        ${d}
        setOutput(result);
      }
    `}},GL=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zn(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,d=e.filterHeight,u=e.filterWidth,c=u,p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)p+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;p+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let g=0;g<u;g++)p+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(c+1)/2;g++){let y=g*2;if(p+=`
          xC = xCCorner + ${y*l};
          `,o===1){if(y<u&&(i%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,l===1&&y>0?p+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<u)){let b=i%2===0?k.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,l>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:p+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):b===1?p+=`
                    xC${y+1} = xTexelC${y};
                    `:p+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<u&&(i%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<u&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<u&&(p+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<u&&(p+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<u&&(p+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let h="",f="";n&&(r?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:h=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `}};function rye(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:d}=r,u=l;u==null&&(u=[1,1]),k.assert(E.eitherStridesOrDilationsAreOne(i,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=E.computeConv2DInfo(a.shape,s.shape,i,u,o,d,!0),p;K().getBool("WEBGL_PACK_DEPTHWISECONV")&&c.strideWidth<=2&&c.outChannels/c.inChannels===1?p=new GL(c):p=new HL(c);let h=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];return n.runWebGLProgram(p,[a,s],"float32",h)}var aye={kernelName:Ll,backendName:"webgl",kernelFunc:rye},sye=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},iye=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function oye(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:d,filterShape:u}=r,c=E.computeConv2DInfo(a.shape,u,i,o,l,d,!0),p=new sye(c);return n.runWebGLProgram(p,[a,s],"float32")}var lye={kernelName:Eb,backendName:"webgl",kernelFunc:oye};function uye(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:d,inputShape:u}=r,c=E.computeConv2DInfo(u,s.shape,i,o,l,d,!0),p=new iye(c);return n.runWebGLProgram(p,[a,s],"float32")}var dye={kernelName:_b,backendName:"webgl",kernelFunc:uye},cye=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function pye(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=k.sizeFromShape(r.shape),i=he({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new cye(s),l=n.runWebGLProgram(o,[i],i.dtype),d=he({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),d}var hye={kernelName:Ef,backendName:"webgl",kernelFunc:pye},fye=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:d}=e,{top:u,left:c}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${s});
      const ivec2 pads = ivec2(${u}, ${c});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function mye(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,d=E.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),u,c=new fye(d);u=n.runWebGLProgram(c,[a,s],"float32");let p=he({inputs:{x:u},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(u),p}var gye={kernelName:zl,backendName:"webgl",kernelFunc:mye};function yye(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=E.decodeEinsumEquation(a,s.length);E.checkEinsumDimSizes(i.length,l,s);let{path:d,steps:u}=E.getEinsumComputePath(o,l),c=u.length,p=null,h=i.length,f=[];for(let m=0;m<c;++m){for(let g of u[m]){let{permutationIndices:y,expandDims:b}=E.getEinsumPermutation(h,l[g]),v;E.isIdentityPermutation(y)?v=s[g]:(v=Zn({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),f.push(v));let x=v.shape.slice();for(let w=0;w<b.length;++w)x.splice(b[w],0,1);k.arraysEqual(v.shape,x)||(v=he({inputs:{x:v},backend:n,attrs:{shape:x}}),f.push(v)),p===null?p=v:(p=aN({inputs:{a:v,b:p},backend:n}),f.push(p))}m<c-1&&(d[m]>=0&&(p=qv({inputs:{x:p},backend:n,attrs:{axis:d[m]-(i.length-h),keepDims:!1}}),f.push(p)),h--)}for(let m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}var bye={kernelName:Ab,backendName:"webgl",kernelFunc:yye},vye="return (x >= 0.0) ? x : (exp(x) - 1.0);",xye=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,wye=nt({opSnippet:vye,packedOpSnippet:xye}),kye={kernelName:Wl,backendName:"webgl",kernelFunc:wye},Sye="return (b >= 0.0) ? a : a * (b + 1.0);",Iye=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Nye=e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=K().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $p(Iye,r.shape,a.shape):new fl(Sye,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)},Cye={kernelName:Cc,backendName:"webgl",kernelFunc:Nye},Tye=`
  return vec4(equal(a, b));
`,Eye="return float(a == b);",_ye=Rn({opSnippet:Eye,packedOpSnippet:Tye,dtype:"bool",cpuKernelImpl:she}),$ye={kernelName:Tc,backendName:"webgl",kernelFunc:_ye},Aye=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${E.ERF_P};
  float a1 = ${E.ERF_A1};
  float a2 = ${E.ERF_A2};
  float a3 = ${E.ERF_A3};
  float a4 = ${E.ERF_A4};
  float a5 = ${E.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Rye=nt({opSnippet:Aye}),Fye={kernelName:Ul,backendName:"webgl",kernelFunc:Rye},Dye=Ap+`
  return exp(x);
`,Mye=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qL=nt({opSnippet:Dye,packedOpSnippet:Mye,cpuKernelImpl:ihe,dtype:"float32"}),Oye={kernelName:Vl,backendName:"webgl",kernelFunc:qL};function a1(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(k.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),he({inputs:{x:s},backend:r,attrs:{shape:o}})}var Pye={kernelName:Ec,backendName:"webgl",kernelFunc:a1},s_="return exp(x) - 1.0;",Lye=nt({opSnippet:s_,packedOpSnippet:s_,cpuKernelImpl:ohe}),zye={kernelName:jl,backendName:"webgl",kernelFunc:Lye},i_=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function KL(e,t,n){let r=n.texData.get(e.dataId),a=k.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=a/s,o=he({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,d=new i_("real",l,t),u=new i_("imag",l,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],p=n.runWebGLProgram(d,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),f=uo({inputs:{real:p,imag:h},backend:n});n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h);let m=he({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function Bye(e){let{inputs:t,backend:n}=e,{input:r}=t;return KL(r,!1,n)}var Wye={kernelName:Rb,backendName:"webgl",kernelFunc:Bye},Uye=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function km(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||k.inferDtype(a),s==="string"){let i=k.getArrayFromDType(s,k.sizeFromShape(r));return i.fill(a),t.makeTensorInfo(r,s,i)}else{let i=new Uye(r,a),o=[[a]];return t.runWebGLProgram(i,[],s,o)}}var Vye={kernelName:_f,backendName:"webgl",kernelFunc:km},jye=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Hye={kernelName:_c,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new jye(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},o_="return floor(x);",Gye=nt({opSnippet:o_,packedOpSnippet:o_,cpuKernelImpl:lhe}),qye={kernelName:Hl,backendName:"webgl",kernelFunc:Gye},Kye=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Xye=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Qye=Rn({opSnippet:Kye,packedOpSnippet:Xye,dtype:"int32"}),Jye={kernelName:Gl,backendName:"webgl",kernelFunc:Qye},Zye=class{constructor(e){this.variableNames=["A"];let t=rr(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},Yye=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=rr(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},ebe={kernelName:Sy,backendName:"webgl",kernelFunc:tbe},td,Jx=K().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function tbe(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,[l,d]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],u=[d,l],c=[d,l,s];if(o||i){let m=K().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(td==null||m!==Jx)&&(Jx=m,td=document.createElement("canvas").getContext("2d",{willReadFrequently:Jx})),td.canvas.width=l,td.canvas.height=d,td.drawImage(a,0,0,l,d),a=td.canvas}let p=n.makeTensorInfo(u,"int32");n.texData.get(p.dataId).usage=Kr.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),a);let h=K().getBool("WEBGL_PACK")?new Yye(c):new Zye(c),f=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),f}function nbe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:d,dataFormat:u,dilations:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=E.convertConv2DDataFormat(u),g=E.computeConv2DInfo(a.shape,s.shape,l,c,d,p,!1,m),y,b=[],v=i!=null,x=o!=null,w=h==="leakyrelu",I=()=>{let T=[a,s],A=(R,F)=>{if(F==="NCHW"&&R.shape.length===1&&R.shape[0]!==1){let C=he({inputs:{x:R},backend:n,attrs:{shape:[R.shape[0],1,1]}});return b.push(C),C}return R};if(v&&T.push(A(i,u)),x&&T.push(A(o,u)),w){let R=n.makeTensorInfo([],"float32",k.createScalarValue(f,"float32"));T.push(R),b.push(R)}return T};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=UL({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&K().getBool("WEBGL_EXP_CONV")){let T=h?of(h,!0):null,A=new WL(g,v,T,x,w),R=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=I();y=n.runWebGLProgram(A,F,"float32",R)}else if(K().getBool("WEBGL_CONV_IM2COL"))y=VL({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:f});else{let T=h?of(h,!1):null,A=new BL(g,v,T,x,w),R=I();y=n.runWebGLProgram(A,R,"float32")}let N=he({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(T=>n.disposeIntermediateTensorInfo(T)),N}var rbe={kernelName:Zo,backendName:"webgl",kernelFunc:nbe};function abe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:d,dilations:u,dimRoundingMode:c,activation:p,leakyreluAlpha:h}=r,f=[],m=u;m==null&&(m=[1,1]),k.assert(E.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let g=E.computeConv2DInfo(a.shape,s.shape,l,m,d,c,!0),y=K().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=p?of(p,y):null,v=[a,s],x=i!=null,w=o!=null,I=p==="leakyrelu";if(x&&v.push(i),w&&v.push(o),I){let R=n.makeTensorInfo([],"float32",k.createScalarValue(h,"float32"));v.push(R),f.push(R)}let N;y?N=new GL(g,x,b,w,I):N=new HL(g,x,b,w,I);let T=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=n.runWebGLProgram(N,v,"float32",T);return f.forEach(R=>n.disposeIntermediateTensorInfo(R)),A}var sbe={kernelName:Yo,backendName:"webgl",kernelFunc:abe},ibe=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=bt(n.length),s=`
    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function obe(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=k.sizeFromShape(r.shape),[l,d,u,c]=E.prepareAndValidate(r,a),p=he({inputs:{x:a},backend:n,attrs:{shape:[d,i]}}),h=he({inputs:{x:r},backend:n,attrs:{shape:[k.sizeFromShape(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,a])||r.dtype==="string"){let y=n.readSync(a.dataId),b=n.bufferSync(r),v=uhe(y,b,r.dtype,d,i,u,c,r.shape,o);return n.makeTensorInfo(l,r.dtype,v.values)}let f=new ibe(i,c,[d,u],r.shape),m=n.runWebGLProgram(f,[h,p],h.dtype),g=he({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var lbe={kernelName:Ac,backendName:"webgl",kernelFunc:obe},ube=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=bt(this.rank),r=dbe(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function dbe(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)a===2?r.push("index"):r.push(`${n[a]}`);return r.join()}function XL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=k.parseAxisParam(i,a.shape)[0];if(K().get("DEBUG")){let b=n.readSync(s.dataId),v=a.shape[l];for(let x=0;x<b.length;++x){let w=b[x];k.assert(w<=v-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${v-1}]`)}}let d=E.segment_util.collectGatherOpShapeInfo(a,s,l,o),u=k.sizeFromShape(s.shape),c=[],p=he({inputs:{x:a},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),h=he({inputs:{x:s},backend:n,attrs:{shape:[d.batchSize,u/d.batchSize]}});c.push(p),c.push(h);let f=[d.batchSize,d.outerSize,u/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([a,s])||a.dtype==="string"){let b=n.bufferSync(h),v=n.bufferSync(p),x=dhe(v,b,f);return c.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(d.outputShape,x.dtype,x.values)}let m=new ube(p.shape,f),g=n.runWebGLProgram(m,[p,h],p.dtype);c.push(g);let y=he({inputs:{x:g},backend:n,attrs:{shape:d.outputShape}});return c.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}var cbe={kernelName:$c,backendName:"webgl",kernelFunc:XL},pbe="return float(a > b);",hbe=`
  return vec4(greaterThan(a, b));
`,fbe=Rn({opSnippet:pbe,packedOpSnippet:hbe,cpuKernelImpl:che,dtype:"bool"}),mbe={kernelName:Rc,backendName:"webgl",kernelFunc:fbe},gbe="return float(a >= b);",ybe=`
  return vec4(greaterThanEqual(a, b));
`,bbe=Rn({opSnippet:gbe,packedOpSnippet:ybe,dtype:"bool",cpuKernelImpl:phe}),vbe={kernelName:Kl,backendName:"webgl",kernelFunc:bbe};function xbe(e){let{inputs:t,backend:n}=e,{input:r}=t;return KL(r,!0,n)}var wbe={kernelName:Fb,backendName:"webgl",kernelFunc:xbe},kbe="return float(!isnan(x) && !isinf(x));",Sbe=nt({opSnippet:kbe,dtype:"bool"}),Ibe={kernelName:Ql,backendName:"webgl",kernelFunc:Sbe},Nbe="return float(isinf(x));",Cbe=nt({opSnippet:Nbe,dtype:"bool"}),Tbe={kernelName:Jl,backendName:"webgl",kernelFunc:Cbe},Ebe="return float(isnan(x));",_be=nt({opSnippet:Ebe,dtype:"bool"}),$be={kernelName:Zl,backendName:"webgl",kernelFunc:_be},Abe="return float(a < b);",Rbe=`
  return vec4(lessThan(a, b));
`,Fbe=Rn({opSnippet:Abe,packedOpSnippet:Rbe,cpuKernelImpl:hhe,dtype:"bool"}),Dbe={kernelName:Fc,backendName:"webgl",kernelFunc:Fbe},Mbe="return float(a <= b);",Obe=`
  return vec4(lessThanEqual(a, b));
`,Pbe=Rn({opSnippet:Mbe,packedOpSnippet:Obe,cpuKernelImpl:fhe,dtype:"bool"}),Lbe={kernelName:Dc,backendName:"webgl",kernelFunc:Pbe};function zbe(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=mhe(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var Bbe={kernelName:Mc,backendName:"webgl",kernelFunc:zbe},Wbe=Ap+`
  return x < 0.0 ? 0./0. : log(x);
`,Ube=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Vbe=nt({opSnippet:Wbe,packedOpSnippet:Ube,cpuKernelImpl:ghe}),jbe={kernelName:eu,backendName:"webgl",kernelFunc:Vbe},Hbe=Ap+`
  return log(1.0 + x);
`,Gbe=nt({opSnippet:Hbe}),qbe={kernelName:tu,backendName:"webgl",kernelFunc:Gbe},Kbe="return float(a >= 1.0 && b >= 1.0);",Xbe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Qbe=Rn({opSnippet:Kbe,packedOpSnippet:Xbe,dtype:"bool"}),Jbe={kernelName:Oc,backendName:"webgl",kernelFunc:Qbe},Zbe="return float(!(x >= 1.0));",Ybe=nt({opSnippet:Zbe}),eve={kernelName:Pc,backendName:"webgl",kernelFunc:Ybe},tve="return float(a >= 1.0 || b >= 1.0);",nve=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,rve=Rn({opSnippet:tve,packedOpSnippet:nve,dtype:"bool"}),ave={kernelName:Lc,backendName:"webgl",kernelFunc:rve},sve=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},ive=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},ove=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,d=K().getBool("WEBGL_PACK_NORMALIZATION")?new ive(a.shape,s,i,o,l):new sve(a.shape,s,i,o,l);return n.runWebGLProgram(d,[a],a.dtype)},lve={kernelName:nu,backendName:"webgl",kernelFunc:ove},uve=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},dve=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:d,beta:u}=r,c=new uve(a.shape,o,l,d,u);return n.runWebGLProgram(c,[a,s,i],a.dtype)},cve={kernelName:zc,backendName:"webgl",kernelFunc:dve};function pve(e,t,n,r){let a=k.sizeFromShape(t),s=k.sizeFromShape(e.shape)/a,i=he({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=Ku(i,e.dtype,"max",r),l=he({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function QL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=k.parseAxisParam(s,a.shape),d=l,u=E.getAxesPermutation(d,o),c=u!=null,p=n.shouldExecuteOnCPU([a]),h=a;if(c){if(p){let b=n.texData.get(h.dataId).values,v=new Array(o);for(let I=0;I<v.length;I++)v[I]=a.shape[u[I]];let x=tN(b,a.shape,a.dtype,u,v);h=n.makeTensorInfo(v,a.dtype);let w=n.texData.get(h.dataId);w.values=x}else h=Gv(a,u,n);d=E.getInnerMostAxes(d.length,o)}E.assertAxesAreInnerMostDims("max",d,o);let[f,m]=E.computeOutAndReduceShapes(h.shape,d),g=f;i&&(g=E.expandShapeToKeepDim(f,l));let y;if(p){let b=n.texData.get(h.dataId).values,v=yhe(b,k.sizeFromShape(m),g,a.dtype);y=n.makeTensorInfo(g,a.dtype);let x=n.texData.get(y.dataId);x.values=v}else y=pve(h,m,g,n);return c&&n.disposeIntermediateTensorInfo(h),y}var hve={kernelName:ru,backendName:"webgl",kernelFunc:QL},fve=rN+`
  return max(a, b);
`,mve=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+qu+`
  return result;
`,gve=Rn({opSnippet:fve,packedOpSnippet:mve,cpuKernelImpl:bhe}),yve={kernelName:au,backendName:"webgl",kernelFunc:gve};function bve(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Np(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,d=1;k.assert(E.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let u=E.computePool2DInfo(a.shape,s,i,d,o,l);if(u.filterWidth===1&&u.filterHeight===1&&k.arraysEqual(u.inShape,u.outShape))return zr({inputs:{x:a},backend:n});let c=new lf(u,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}var vve={kernelName:su,backendName:"webgl",kernelFunc:bve};function xve(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:d}=r,u=[1,1,1],c=E.computePool3DInfo(a.shape,s,i,u,o,d,l),p=new sN(c,"max",!1);return n.runWebGLProgram(p,[a],a.dtype)}var wve={kernelName:Bc,backendName:"webgl",kernelFunc:xve},kve=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Sve=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,d=e.effectiveFilterWidth,u=o-1-e.padInfo.front,c=l-1-e.padInfo.top,p=d-1-e.padInfo.left,h=o*l*d-1;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${c}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Ive(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:d,dimRoundingMode:u}=r,c=[1,1,1],p=E.computePool3DInfo(i.shape,o,l,c,d,u),h=new sN(p,"max",!0),f=n.runWebGLProgram(h,[i],i.dtype),m=new Sve(p),g=n.runWebGLProgram(m,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var Nve={kernelName:Af,backendName:"webgl",kernelFunc:Ive};function Cve(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;Np([s,i],"maxPoolGrad");let{filterSize:l,strides:d,pad:u,dimRoundingMode:c}=r,p=E.computePool2DInfo(o.shape,l,d,1,u,c),h=!0,f=new lf(p,"max",h),m=n.runWebGLProgram(f,[o],o.dtype),g=new kve(p),y=n.runWebGLProgram(g,[a,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var Tve={kernelName:$f,backendName:"webgl",kernelFunc:Cve};function Eve(e,t,n,r){let a=new lf(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");a=new lf(n,"max",!0,!0,t);let i=r.runWebGLProgram(a,[e],"float32");return[s,i]}var _ve={kernelName:Rf,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;k.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let d=[1,1];k.assert(E.eitherStridesOrDilationsAreOne(s,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);let u=E.computePool2DInfo(r.shape,a,s,d,i),[c,p]=Eve(r,o,u,l);return[c,p]}};function $ve(e,t,n,r){let a=k.sizeFromShape(t),s=k.sizeFromShape(e.shape)/a,i=he({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=Ku(i,"float32","mean",r),l=he({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var Ave={kernelName:iu,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:s}=t,i=n,o=r.shape.length,l=k.parseAxisParam(s,r.shape),d=l,u=E.getAxesPermutation(d,o),c=u!=null,p=i.shouldExecuteOnCPU([r]),h=[],f=r;if(c){if(p){let v=i.texData.get(f.dataId).values,x=new Array(o);for(let N=0;N<x.length;N++)x[N]=r.shape[u[N]];let w=tN(v,r.shape,r.dtype,u,x);f=i.makeTensorInfo(x,r.dtype);let I=i.texData.get(f.dataId);I.values=w}else f=Gv(r,u,i);h.push(f),d=E.getInnerMostAxes(d.length,o)}E.assertAxesAreInnerMostDims("sum",d,o);let[m,g]=E.computeOutAndReduceShapes(f.shape,d),y=m;a&&(y=E.expandShapeToKeepDim(m,l));let b=$ve(f,g,y,i);for(let v of h)i.disposeIntermediateTensorInfo(v);return b}};function Rve(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=k.parseAxisParam(s,a.shape),d=l,u=E.getAxesPermutation(d,o),c=a;u!=null&&(c=Zn({inputs:{x:a},backend:n,attrs:{perm:u}}),d=E.getInnerMostAxes(d.length,a.shape.length)),E.assertAxesAreInnerMostDims("min",d,o);let[p,h]=E.computeOutAndReduceShapes(c.shape,d),f=k.sizeFromShape(h),m=he({inputs:{x:c},backend:n,attrs:{shape:[-1,f]}}),g=Ku(m,m.dtype,"min",n),y;if(i){let b=E.expandShapeToKeepDim(p,l);y=he({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=he({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(c),y}var Fve={kernelName:ou,backendName:"webgl",kernelFunc:Rve},Dve=rN+`
  return min(a, b);
`,Mve=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+qu+`
  return result;
`,Ove=Rn({opSnippet:Dve,packedOpSnippet:Mve,cpuKernelImpl:vhe}),Pve={kernelName:lu,backendName:"webgl",kernelFunc:Ove},Lve=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((d,u)=>d[0]+e[u]+d[1]);let r=e.length,a=bt(r),s=t.map(d=>d[0]).join(","),i=t.map((d,u)=>d[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},zve=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((h,f)=>h[0]+e[f]+h[1]);let r=e.length,a=bt(r),s=t.map(h=>h[0]).join(","),i=t.map((h,f)=>h[0]+e[f]).join(","),o=qn("rc",r),l=qn("source",r),d=`${o[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${l.slice(-2).join()})`,c=n==="reflect"?0:1,p="";if(r===1){let h=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${c};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${c};
        }
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[r-1]} += 1;
        if(${d}) {
          ${h}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
      `}else{let h=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${c}) +
                gte * ((end - 1) * 2 - source + ${c});
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[r-1]} += 1;
        if(${d}) {
          ${h}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${h}
          result[2] = getChannel(getX(${l.join()}), ${u});
          ${o[r-1]} += 1;
          if(${d}) {
            ${h}
            result[3] = getChannel(getX(${l.join()}), ${u});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},Bve=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=K().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zve(r.shape,a,s):new Lve(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)},Wve={kernelName:uu,backendName:"webgl",kernelFunc:Bve},Uve=`if (b == 0.0) return NAN;
  return mod(a, b);`,Vve=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+qu+`
  return result;
`,jve=Rn({opSnippet:Uve,packedOpSnippet:Vve}),Hve={kernelName:du,backendName:"webgl",kernelFunc:jve},Gve=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},qve=`
if (a == b) {
  return 1.0;
};
return a / b;`,Kve=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,JL=Rn({opSnippet:qve,packedOpSnippet:Kve,checkOutOfBounds:!0}),Xve={kernelName:Bl,backendName:"webgl",kernelFunc:JL},l_="return a - b;",ZL=Rn({opSnippet:l_,packedOpSnippet:l_,supportsComplex:!0,cpuKernelImpl:Bhe}),Qve={kernelName:Mu,backendName:"webgl",kernelFunc:ZL};function YL(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=k.parseAxisParam([s],a.shape),o=QL({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=E.expandShapeToKeepDim(o.shape,i),d=he({inputs:{x:o},backend:n,attrs:{shape:l}}),u=ZL({inputs:{a,b:d},backend:n}),c=qL({inputs:{x:u},backend:n}),p=qv({inputs:{x:c},backend:n,attrs:{axis:i,keepDims:!1}}),h=he({inputs:{x:p},backend:n,attrs:{shape:l}}),f=JL({inputs:{a:c,b:h},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}var Jve={kernelName:Fu,backendName:"webgl",kernelFunc:YL};function Zve(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:YL({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),d=l.shape[0],u=l.shape[1],c=new Gve(d,u,s),p=[[i]],h=n.runWebGLProgram(c,[l],"int32",p);return o||n.disposeIntermediateTensorInfo(l),h}var Yve={kernelName:Wc,backendName:"webgl",kernelFunc:Zve},exe=wa+`
  return -x;
`,txe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function nxe(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let s=n.texData.get(r.dataId),[i,o]=whe(s.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let a;return K().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new yi(r.shape,txe):a=new rs(r.shape,exe),n.runWebGLProgram(a,[r],r.dtype)}var rxe={kernelName:Uc,backendName:"webgl",kernelFunc:nxe},axe=gs.nonMaxSuppressionV3Impl;function sxe(e){E.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,d=n.readSync(a.dataId),u=n.readSync(s.dataId),{selectedIndices:c}=axe(d,u,i,o,l);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}var ixe={kernelName:jc,backendName:"webgl",kernelFunc:sxe},oxe=gs.nonMaxSuppressionV4Impl;function lxe(e){E.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:d}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:p,validOutputs:h}=oxe(u,c,i,o,l,d);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var uxe={kernelName:Hc,backendName:"webgl",kernelFunc:lxe},dxe=gs.nonMaxSuppressionV5Impl;function cxe(e){E.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:d}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),p=i,h=o,f=l,m=d,{selectedIndices:g,selectedScores:y}=dxe(u,c,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var pxe={kernelName:Gc,backendName:"webgl",kernelFunc:cxe},hxe=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},fxe=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,d=k.sizeFromShape(a.shape),u=new hxe(d,i,o,l),c=he({inputs:{x:a},backend:n,attrs:{shape:[d]}}),p=n.runWebGLProgram(u,[c],s);n.disposeIntermediateTensorInfo(c);let h=[...a.shape,i],f=he({inputs:{x:p},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(p),f},mxe={kernelName:pu,backendName:"webgl",kernelFunc:fxe};function Gy(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let a=wm({inputs:{input:r},backend:n}),s=Gy({inputs:{x:a},backend:n}),i=Kv({inputs:{input:r},backend:n}),o=Gy({inputs:{x:i},backend:n}),l=uo({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return km({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var gxe={kernelName:cp,backendName:"webgl",kernelFunc:Gy};function ez(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let a=wm({inputs:{input:r},backend:n}),s=ez({inputs:{x:a},backend:n}),i=Kv({inputs:{input:r},backend:n}),o=Gy({inputs:{x:i},backend:n}),l=uo({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return km({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var yxe={kernelName:qc,backendName:"webgl",kernelFunc:ez};function bxe(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return a1({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{k.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),k.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let c=a1({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(c),c}),d=zL({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),d}var vxe={kernelName:Kc,backendName:"webgl",kernelFunc:bxe},xxe=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,d)=>l[0]+e[d]+l[1]);let r=e.length,a=bt(r),s=t.map(l=>l[0]).join(","),i=t.map((l,d)=>l[0]+e[d]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},wxe=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let r=e.length,a=bt(r),s=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),o=qn("rc",r),l=qn("source",r),d=`${o[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${l.slice(-2).join()})`,c=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${d}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let f=0,m=r===1?2:4;f<m;f++)h+=`
        ${c[f]}
        if (${p}) {
          result[${f}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${f}] = getChannel(getX(${l.join()}), ${u});
        }
      `;h+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}},tz=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(k.sizeFromShape(a.shape)===0){let d=s.map((u,c)=>u[0]+a.shape[c]+u[1]);return km({backend:n,attrs:{shape:d,value:i,dtype:a.dtype}})}let o=K().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wxe(a.shape,s,i):new xxe(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},kxe={kernelName:hu,backendName:"webgl",kernelFunc:tz},Sxe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Ixe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+qu+`
  return result;
`,Nxe=Rn({opSnippet:Sxe,packedOpSnippet:Ixe}),Cxe={kernelName:fu,backendName:"webgl",kernelFunc:Nxe};function Txe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=[],d=k.parseAxisParam(s,a.shape),u=d,c=E.getAxesPermutation(u,o),p=a;c!=null&&(p=Zn({inputs:{x:a},backend:n,attrs:{perm:c}}),u=E.getInnerMostAxes(u.length,o),l.push(p)),E.assertAxesAreInnerMostDims("prod",u,o);let h;if(n.shouldExecuteOnCPU([p])){let f=n.texData.get(p.dataId).values,{outVals:m,outShape:g,outDtype:y}=She(p.shape,p.dtype,f,u);h=n.makeTensorInfo(g,y,m)}else{let[f,m]=E.computeOutAndReduceShapes(p.shape,u),g=k.sizeFromShape(m),y=he({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}}),b=Bb(a.dtype),v=Ku(y,b,"prod",n);h=he({inputs:{x:v},backend:n,attrs:{shape:f}}),l.push(y),l.push(v)}if(i){l.push(h);let f=E.expandShapeToKeepDim(h.shape,d);h=he({inputs:{x:h},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),h}var Exe={kernelName:gu,backendName:"webgl",kernelFunc:Txe};function _xe(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(y=>n.readSync(y.dataId)),d=a.map(y=>y.shape),u=n.readSync(s.dataId),c=n.readSync(i.dataId),[p,h,f]=Ihe(l,d,u,s.shape,s.dtype,c,i.shape,o),m=p.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,s.dtype,h);return m.concat([g])}var $xe={kernelName:Mb,backendName:"webgl",kernelFunc:_xe};function Axe(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[d,u]=Nhe(i,r.shape,r.dtype,o,a.shape,l,s.shape),c=n.makeTensorInfo([d.length],"int32",d),p=n.makeTensorInfo([u.length],r.dtype,u);return[c,p]}var Rxe={kernelName:Ob,backendName:"webgl",kernelFunc:Axe};function Fxe(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,d=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId),p=o.map(g=>n.readSync(g.dataId)),h=o.map(g=>g.shape),[f,m]=Che(d,a.shape,u,s.shape,s.dtype,c,i.shape,p,h,l);return n.makeTensorInfo(f,s.dtype,m)}var Dxe={kernelName:Pb,backendName:"webgl",kernelFunc:Fxe},nz=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=The(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},Mxe={kernelName:Ff,backendName:"webgl",kernelFunc:nz},Oxe="return 1.0 / x;",Pxe=nt({opSnippet:Oxe}),Lxe={kernelName:yu,backendName:"webgl",kernelFunc:Pxe},zxe=wa+`
  return (x < 0.0) ? 0.0 : x;
`,Bxe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Wxe=nt({opSnippet:zxe,packedOpSnippet:Bxe}),Uxe={kernelName:bu,backendName:"webgl",kernelFunc:Wxe},Vxe=wa+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,jxe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Hxe=nt({opSnippet:Vxe,packedOpSnippet:jxe}),Gxe={kernelName:wu,backendName:"webgl",kernelFunc:Hxe},qxe=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let d=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],c;a?c="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":c="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/u[0]},
          ${d[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${c};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},Kxe=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let d=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],c;a?c="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":c="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/u[0]},
          ${d[1]/u[1]},
          ${d[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${c};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Xxe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,d]=o,u=K().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Kxe(a.shape,l,d,s,i):new qxe(a.shape,l,d,s,i);return n.runWebGLProgram(u,[a],"float32")}var Qxe={kernelName:xu,backendName:"webgl",kernelFunc:Xxe},Jxe=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],d=o[0]/l[0],u=o[1]/l[1],c=1/d,p=1/u,h=Math.ceil(c)*2+2,f=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${u});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${p});

        const int winHeight = int(${h});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Zxe(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new Jxe(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var Yxe={kernelName:Jc,backendName:"webgl",kernelFunc:Zxe},e0e=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let d=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0",p;a?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/u[0]},
          ${d[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},t0e=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let d=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0",p;a?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/u[0]},
          ${d[1]/u[1]},
          ${d[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function n0e(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,d]=o,u=K().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new t0e(a.shape,l,d,s,i):new e0e(a.shape,l,d,s,i);return n.runWebGLProgram(u,[a],a.dtype)}var r0e={kernelName:vu,backendName:"webgl",kernelFunc:n0e},a0e=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],d=o[0]/l[0],u=o[1]/l[1],c=1/d,p=1/u,h=Math.ceil(c)*2+2,f=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${u});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${p});

        const int winHeight = int(${h});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function s0e(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new a0e(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var i0e={kernelName:Qc,backendName:"webgl",kernelFunc:s0e},o0e=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,a=e.map((i,o)=>r(o)).join(","),s=bt(n);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}},l0e=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=qn("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=bt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${a}){
            result.g = ${l(r.slice())};
          }
          if(${s}) {
            result.b = ${d(r.slice())};
            if(${a}) {
              result.a = ${u(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(h){return c(h)}function l(h){return h[n-1]="("+h[n-1]+" + 1)",c(h)}function d(h){return h[n-2]="("+h[n-2]+" + 1)",c(h)}function u(h){return h[n-1]="("+h[n-1]+" + 1)",h[n-2]="("+h[n-2]+" + 1)",c(h)}function c(h){let f=e.map((y,b)=>p(b,h)),m=f.join(","),g=f.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function p(h,f){return t.indexOf(h)!==-1&&e[h]!==1?`${e[h]} - ${f[h]} - 1`:`${f[h]}`}}};function u0e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=k.parseAxisParam(s,a.shape);if(i===0)return zr({inputs:{x:a},backend:n});let l=K().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new l0e(a.shape,o):new o0e(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}var d0e={kernelName:ku,backendName:"webgl",kernelFunc:u0e},c0e=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},p0e={kernelName:pp,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=new c0e(r.shape,s),[d,u]=E.getImageCenter(i,r.shape[1],r.shape[2]),c=[[d,u,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,c)}},h0e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,f0e=nt({opSnippet:h0e}),m0e={kernelName:Su,backendName:"webgl",kernelFunc:f0e},g0e="return inversesqrt(x);",y0e=nt({opSnippet:g0e,cpuKernelImpl:Ehe}),b0e={kernelName:Iu,backendName:"webgl",kernelFunc:y0e},iN=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let l=bt(a.length),d=bt(s.length),u="";n===1?u="i":n===2&&(u="i, j");let c=`getIndices(${u})`,p="";r===1?p="i":r===2&&(p="i, coords[1]");let h=`getUpdates(${p})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${c});
              flattenedIndex += index * ${g};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}},v0e=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=bt(a.length),d=bt(s.length),u="";n===1?u="i":n===2&&(u="i, j");let c=`getIndices(${u})`,p="";r===1?p="i":r===2&&(p="i, coords[1]");let h=`getUpdates(${p})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${c});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${h};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function x0e(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:d,strides:u,outputSize:c}=E.calculateShapes(s,a,i),p=[c/d,d];if(c===0)return n.makeTensorInfo(i,a.dtype);let h=he({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=he({inputs:{x:s},backend:n,attrs:{shape:[l,d]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g;K().getBool("WEBGL_PACK")?g=new v0e(l,o,h.shape.length,f.shape.length,u,p):g=new iN(l,o,h.shape.length,f.shape.length,u,p);let y=n.runWebGLProgram(g,[f,h,m],f.dtype),b=he({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}var w0e={kernelName:Zc,backendName:"webgl",kernelFunc:x0e},k0e=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=K().getNumber("WEBGL_VERSION")===2?a:s,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function S0e(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new k0e(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}var I0e={kernelName:ep,backendName:"webgl",kernelFunc:S0e},N0e=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,a;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)a="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let d=0;d<t.length;d++)l.push(`${i[d]}`),d<e&&o.push(`${i[d]}`);r=o.join(),a=l.join()}let s=bt(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}};function C0e(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new N0e(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],ea(a.dtype,s.dtype))}var T0e={kernelName:tp,backendName:"webgl",kernelFunc:C0e},E0e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${E.SELU_SCALEALPHA};
  float scale = ${E.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,_0e=nt({opSnippet:E0e}),$0e={kernelName:Nu,backendName:"webgl",kernelFunc:_0e},A0e=Ap+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,R0e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,F0e=nt({opSnippet:A0e,packedOpSnippet:R0e,cpuKernelImpl:$he}),D0e={kernelName:_u,backendName:"webgl",kernelFunc:F0e},M0e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,O0e=nt({opSnippet:M0e}),P0e={kernelName:Eu,backendName:"webgl",kernelFunc:O0e},L0e=Ap+`
  return sin(x);
`,z0e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${qu}
  return result;
`,B0e=nt({opSnippet:L0e,packedOpSnippet:z0e}),W0e={kernelName:Cu,backendName:"webgl",kernelFunc:B0e},U0e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,V0e=nt({opSnippet:U0e}),j0e={kernelName:Tu,backendName:"webgl",kernelFunc:V0e},H0e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,G0e=nt({opSnippet:H0e}),q0e={kernelName:$u,backendName:"webgl",kernelFunc:G0e},K0e=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;k.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let d=[],u=tz({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=E.getReshaped(u.shape,s,o,!1),p=E.getPermuted(c.length,s.length,!1),h=E.getReshapedPermuted(u.shape,s,o,!1),f=he({inputs:{x:u},backend:n,attrs:{shape:c}}),m=Zn({inputs:{x:f},backend:n,attrs:{perm:p}}),g=he({inputs:{x:m},backend:n,attrs:{shape:h}});return d.push(u),d.push(f),d.push(m),d.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},X0e={kernelName:rp,backendName:"webgl",kernelFunc:K0e};function Q0e(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),d=n.readSync(s.dataId),u=n.readSync(i.dataId)[0],[c,p,h,f,m]=Rhe(o,r.shape,r.dtype,l,a.dtype,d,u);return[n.makeTensorInfo(p,r.dtype,c),n.makeTensorInfo([p[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var J0e={kernelName:Df,backendName:"webgl",kernelFunc:Q0e};function Z0e(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[d,u,c]=Fhe(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(u,r.dtype,d),n.makeTensorInfo([c.length],s.dtype,new Int32Array(c))]}var Y0e={kernelName:sp,backendName:"webgl",kernelFunc:Z0e};function ewe(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[d,u]=IL(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,d)}var twe={kernelName:Mf,backendName:"webgl",kernelFunc:ewe};function nwe(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[d,u]=IL(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,d)}var rwe={kernelName:Of,backendName:"webgl",kernelFunc:nwe};function awe(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:d,sliceSize:u,strides:c,outputSize:p}=E.calculateShapes(s,a,o),h=!1;if(s.dtype==="string"){let y=n.bufferSync(a),b=n.bufferSync(s),v=k.decodeString(n.readSync(i.dataId)[0]),x=_he(y,b,o,p,u,d,l,c,v,h);return n.makeTensorInfo(o,x.dtype,x.values)}let f=new iN(d,l,a.shape.length,s.shape.length,c,[p,1],h),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=he({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var swe={kernelName:ip,backendName:"webgl",kernelFunc:awe};function iwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=k.parseAxisParam(i,a.shape)[0],l=E.prepareSplitSize(a,s,o),d=a.shape.length,u=new Array(d).fill(0),c=a.shape.slice();return l.map(p=>{let h=[...c];h[o]=p;let f=Rp({inputs:{x:a},backend:n,attrs:{begin:u,size:h}});return u[o]+=p,f})}var owe={kernelName:ap,backendName:"webgl",kernelFunc:iwe},u_="return sqrt(x);",lwe=nt({opSnippet:u_,packedOpSnippet:u_,cpuKernelImpl:Dhe}),uwe={kernelName:Au,backendName:"webgl",kernelFunc:lwe},dwe="return x * x;",cwe=nt({opSnippet:dwe}),pwe={kernelName:Pf,backendName:"webgl",kernelFunc:cwe},d_="return (a - b) * (a - b);",hwe=Rn({opSnippet:d_,packedOpSnippet:d_}),fwe={kernelName:Du,backendName:"webgl",kernelFunc:hwe};function mwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=E.fromUint8ToStringArray(s),o=Mhe(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}var gwe={kernelName:Lf,backendName:"webgl",kernelFunc:mwe};function ywe({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=wa+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new rs(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}var bwe={kernelName:no,backendName:"webgl",kernelFunc:ywe},vwe=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=bt(n.length),s=bt(n.length),i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((l,d)=>(o++,n.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${o-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function xwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:d,ellipsisMask:u,newAxisMask:c,shrinkAxisMask:p}=r,{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=ln.sliceInfo(a.shape,s,i,o,l,d,u,c,p),w;if(m)w=he({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){k.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let N=ln.computeOutShape(b,v,x),T=Rp({inputs:{x:a},backend:n,attrs:{begin:b,size:N}});w=he({inputs:{x:T},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(T)}else if(n.shouldExecuteOnCPU([a])){let N=n.readSync(a.dataId),T=Ve(a.shape,a.dtype,N),A=Ohe(h,T,x,b);w=n.makeTensorInfo(f,a.dtype,A.values)}else{let N=new vwe(b,x,h);w=n.runWebGLProgram(N,[a],a.dtype)}let I=he({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),I}var wwe={kernelName:op,backendName:"webgl",kernelFunc:xwe};function kwe(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:d}=r,{data:u,dataSplits:c}=t,p=n.readSync(u.dataId),h=n.readSync(c.dataId),[f,m]=Phe(p,h,a,s,i,o,l,d);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}var Swe={kernelName:zf,backendName:"webgl",kernelFunc:kwe};function Iwe(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[d,u,c]=Lhe(o,l,a),p=u.length;return[n.makeTensorInfo([p,2],"int32",d),n.makeTensorInfo([p],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(c))]}var Nwe={kernelName:Bf,backendName:"webgl",kernelFunc:Iwe};function Cwe(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=zhe(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var Twe={kernelName:Wf,backendName:"webgl",kernelFunc:Cwe},Ewe="return tan(x);",_we=nt({opSnippet:Ewe}),$we={kernelName:Ou,backendName:"webgl",kernelFunc:_we},Awe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Rwe=nt({opSnippet:Awe}),Fwe={kernelName:Pu,backendName:"webgl",kernelFunc:Rwe};function Dwe(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:d,strides:u,outputSize:c}=E.calculateShapes(i,s,a.shape),p=[c/d,d];if(c===0)return n.makeTensorInfo(a.shape,s.dtype);let h=he({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=he({inputs:{x:i},backend:n,attrs:{shape:[l,d]}}),m=he({inputs:{x:a},backend:n,attrs:{shape:p}}),g=new iN(l,o,h.shape.length,f.shape.length,u,p,!1,!0),y=n.runWebGLProgram(g,[f,h,m],m.dtype),b=he({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}var Mwe={kernelName:Yc,backendName:"webgl",kernelFunc:Dwe},Owe=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=bt(this.rank),a=Pwe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}};function Pwe(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}function rz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if(a.dtype==="string"||a.shape.length>5){let o=n.readSync(a.dataId),l=a.dtype==="string"?o.map(c=>k.decodeString(c)):o,d=Ve(a.shape,a.dtype,l),u=Whe(d,s);return n.makeTensorInfo(u.shape,u.dtype,u.values)}let i=new Owe(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var Lwe={kernelName:to,backendName:"webgl",kernelFunc:rz},zwe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Bwe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function vo(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function c_(e){let t=1;for(;t<e;)t*=2;return t}function Wwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=K().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=K().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=a.shape,u=d[d.length-1];if(n.shouldExecuteOnCPU([a])||u<o||s>l){let A=n.readSync(a.dataId),[R,F]=Uhe(A,d,a.dtype,s,i);return[n.makeTensorInfo(R.shape,R.dtype,R.values),n.makeTensorInfo(F.shape,F.dtype,F.values)]}if(s===0)return d[d.length-1]=0,[n.makeTensorInfo(d,a.dtype,[]),n.makeTensorInfo(d,"int32",[])];if(u===1)return[a,km({attrs:{shape:d,dtype:"int32",value:0},backend:n})];let c=n.texData.get(a.dataId),p=c!==null&&c.isPacked,h=p?n.unpackTensor(a):a,f=k.sizeFromShape(d)/u,m=he({inputs:{x:h},attrs:{shape:[f,u]},backend:n});p&&vo(n,h);let g=c_(s),y=c_(u),b=null,v=()=>b===null?[m,m]:[m,b],x=(A,R,F)=>{let C=v(),M=new zwe(F),B=[[u],[b===null?1:0],[Number.NEGATIVE_INFINITY],[A],[R]],U=b;b=n.runWebGLProgram(M,C,"int32",B),vo(n,U)};for(let A=1;A<g;A*=2){let R=A*2;for(let F=A;F>=1;F/=2)x(R,F,[f,y])}for(let A=y;A>g;A/=2){let R=v(),F=new Bwe([f,A/2]),C=[[u],[b===null?1:0],[g]],M=b;b=n.runWebGLProgram(F,R,"int32",C),vo(n,M);let B=g/2,U=B*2;for(let G=B;G>=1;G/=2)x(U,G,b.shape)}let w=b;b=Rp({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),vo(n,w);let I=XL({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});vo(n,m);let N=d.slice(0,-1);N.push(s),w=b,b=he({inputs:{x:b},attrs:{shape:N},backend:n}),vo(n,w);let T=I;return I=he({inputs:{x:I},attrs:{shape:N},backend:n}),vo(n,T),[I,b]}var Uwe={kernelName:lp,backendName:"webgl",kernelFunc:Wwe},Vwe=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function jwe(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:d}=r,[u,c,p,h]=a.shape,[f,m]=d??[c,p],g=[u,f,m,h],y=new Vwe(c,p,i,o,l,g);return n.runWebGLProgram(y,[a,s],"float32")}var Hwe={kernelName:up,backendName:"webgl",kernelFunc:jwe};function Gwe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;Np(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:d}=Vhe(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([d.length],"int32",d)]}var qwe={kernelName:Uf,backendName:"webgl",kernelFunc:Gwe};function Kwe(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],d=new Array(o-1),u=0;for(let m=0;m<o;m++)m!==s&&(d[u++]=i.shape[m]);let c=[],p=new Array(o).fill(0),h=i.shape.slice();h[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){p[s]=m;let g=Rp({inputs:{x:i},backend:n,attrs:{begin:p,size:h}}),y=he({inputs:{x:g},backend:n,attrs:{shape:d}});f[m]=y,c.push(g)}return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Xwe={kernelName:dp,backendName:"webgl",kernelFunc:Kwe},Qwe=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o="0.0",l="sumValue",d=Math.floor(n/4)*4,u=n%4,c=`
        sumValue += dot(values, segFilter);
    `,p="";a%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let h="";a%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${c}
        }

        int inIdx = inOffset + ${d};
        if (${u===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${c}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${c}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${c}
        }
        setOutput(${l});
      }
    `}};function Jwe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],d=0,u=E.getAxesPermutation([d],o),c=a;u!=null&&(c=Zn({inputs:{x:a},backend:n,attrs:{perm:u}}),l.push(c),d=E.getInnerMostAxes(1,o)[0]);let p=E.segment_util.computeOutShape(c.shape,d,i),h=k.sizeFromShape([c.shape[d]]),f=he({inputs:{x:c},backend:n,attrs:{shape:[-1,h]}});l.push(f);let m=Bb(a.dtype),g=(x,w,I,N,T)=>{let A=x.shape[0],R=x.shape[1],F=E.segment_util.segOpComputeOptimalWindowSize(R,T),C={windowSize:F,inSize:R,batchSize:A,numSegments:T},M=new Qwe(C,w),B=n.compileAndRun(M,[x,I],N);if(l.push(B),B.shape[1]===T)return B;let U=nz({backend:n,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),G=rz({inputs:{x:U},backend:n,attrs:{reps:[R/F]}});return l.push(U),l.push(G),g(B,w,G,N,T)},y=g(f,"unsortedSegmentSum",s,m,i),b=he({inputs:{x:y},backend:n,attrs:{shape:p}}),v=b;if(u!=null){l.push(b);let x=E.getUndoAxesPermutation(u);v=Zn({inputs:{x:v},backend:n,attrs:{perm:x}})}return l.forEach(x=>n.disposeIntermediateTensorInfo(x)),v}var Zwe={kernelName:Vf,backendName:"webgl",kernelFunc:Jwe},Ywe=[Ofe,Lfe,Wfe,jfe,Gfe,Xfe,Jfe,Yfe,rme,sme,lme,cme,fme,bme,wme,Sme,Nme,_me,Ame,Fme,Pme,jme,Gme,Qme,Zme,age,ige,dge,vfe,hge,bge,kge,Ege,Age,Fge,Mge,Pge,Wge,jge,qge,Xge,Jge,Yge,nye,aye,lye,dye,hye,gye,bye,kye,Cye,$ye,Fye,Oye,Pye,zye,Wye,Vye,Hye,qye,Jye,ebe,rbe,sbe,lbe,cbe,mbe,vbe,bfe,wbe,gge,Ibe,Tbe,$be,wfe,Dbe,Lbe,Bbe,jbe,qbe,Jbe,eve,ave,lve,cve,hve,yve,vve,wve,Nve,Tve,_ve,Ave,Fve,Pve,Wve,Hve,Yve,Ife,rxe,ixe,uxe,pxe,ege,mxe,yxe,vxe,kxe,Cxe,Sfe,Exe,$xe,Rxe,Dxe,Mxe,tge,Xve,Lxe,Uxe,Gxe,Cfe,Qxe,Yxe,r0e,i0e,d0e,p0e,m0e,b0e,w0e,I0e,T0e,$0e,D0e,P0e,W0e,j0e,Ume,Jve,q0e,X0e,J0e,Y0e,twe,rwe,swe,owe,uwe,pwe,fwe,gwe,bwe,wwe,Swe,Nwe,Twe,Qve,Ffe,$we,Fwe,Mwe,Lwe,Uwe,Hwe,Dfe,qwe,Xwe,Zwe,gxe];for(let e of Ywe)jf(e);var at;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(at||(at={}));var df;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(df||(df={}));var az;function e1e(e){az=e.wasm.cwrap(Jo,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function t1e(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:d,activation:u,leakyreluAlpha:c}=r,p=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,f=0;if(i!=null){let T=n.dataIdMap.get(i.dataId);if(T.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${T.shape.length}.`);f=T.id}let m=o==null?0:n.dataIdMap.get(o.dataId).id,g=df[u];if(g==null)throw new Error(`${u} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=d?s.shape[1]:s.shape[2],v=hp.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),x=n.makeOutput([...v,y,b],a.dtype),w=n.dataIdMap.get(x.dataId).id,I=new Uint8Array(new Int32Array(a.shape).buffer),N=new Uint8Array(new Int32Array(s.shape).buffer);return az(p,I,a.shape.length,h,N,s.shape.length,l,d,g,f,m,c||0,w),x}var n1e={kernelName:Jo,backendName:"wasm",setupFunc:e1e,kernelFunc:t1e};function et(e,t){let n;function r(s){n=s.wasm.cwrap(e,null,["number","number","number"])}function a(s){let{backend:i,inputs:{x:o}}=s,l=i.dataIdMap.get(o.dataId).id,d=i.makeOutput(o.shape,t||o.dtype),u=i.dataIdMap.get(d.dataId).id;return k.sizeFromShape(d.shape)===0||n(l,at[o.dtype],u),d}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:a}}var r1e=et(cc),a1e=et(xl),s1e=et(wl);function rn(e,t,n){let r;function a(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:o,inputs:l}=i,{a:d,b:u}=l,c=o.dataIdMap.get(d.dataId).id,p=o.dataIdMap.get(u.dataId).id,h=n??d.dtype,f=E.assertAndGetBroadcastShape(d.shape,u.shape),m=o.makeOutput(f,h);if(k.sizeFromShape(f)===0)return m;let g=new Uint8Array(new Int32Array(d.shape).buffer),y=new Uint8Array(new Int32Array(u.shape).buffer),b=o.dataIdMap.get(m.dataId).id;return r(c,g,d.shape.length,p,y,u.shape.length,at[d.dtype],b),m}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:s}}var i1e=rn(Yi),sz;function o1e(e){sz=e.wasm.cwrap(kl,null,["array","number","number","number"])}function l1e(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(k.sizeFromShape(r.shape)===0)return r;let a=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return sz(s,a.length,at[r.dtype],i),r}var u1e={kernelName:kl,backendName:"wasm",setupFunc:o1e,kernelFunc:l1e};function Xv(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return Xn(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var d1e={kernelName:Xl,backendName:"wasm",kernelFunc:Xv},iz;function c1e(e){iz=e.wasm.cwrap(As,null,["number","array","number","number","number","array","number"])}function Hi(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=h1e(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=p1e(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let f=Xv({inputs:t,backend:n});return f.shape=o,f}let d=n.makeOutput(o,l.dtype),u=n.dataIdMap.get(l.dataId).id,c=n.dataIdMap.get(d.dataId).id,p=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return iz(u,h,l.shape.length,at[l.dtype],c,p,s.length),d}function p1e(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function h1e(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)e[a]!==1&&n.push(e[a]),e[t[a]]!==1&&r.push(t[a]);for(let a=0;a<r.length;++a){let s=-1;for(let i=0;i<r.length;++i)r[i]>=a&&(s===-1||r[s]>r[i])&&(s=i);r[s]=a}return[n,r]}var f1e={kernelName:As,backendName:"wasm",kernelFunc:Hi,setupFunc:c1e};function co(e,t,n){let r=e.shape,a=e.shape.length,s=k.parseAxisParam(t,r),i=s,o=E.getAxesPermutation(i,a),l=null,d=!1;if(o!=null){let u=new Array(a);for(let p=0;p<u.length;p++)u[p]=r[o[p]];i=E.getInnerMostAxes(i.length,a),l=Hi({inputs:{x:e},attrs:{perm:o},backend:n});let c=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==c&&(d=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:d}}var oz;function m1e(e){oz=e.wasm.cwrap(pc,null,["number, number, number"])}function g1e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:d,axes:u,originalAxes:c,inputWasTransposed:p}=co(i,a,t);if(p){let b=t.dataIdMap.get(d.dataId).id;l=d,o=b}let h=l.shape.length;E.assertAxesAreInnerMostDims("all",u,h);let[f,m]=E.computeOutAndReduceShapes(l.shape,u),g=k.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(k.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;oz(o,g,b)}if(p&&t.disposeData(d.dataId),s){let b=E.expandShapeToKeepDim(y.shape,c);y.shape=b}return y}var y1e={kernelName:pc,backendName:"wasm",setupFunc:m1e,kernelFunc:g1e},lz;function b1e(e){lz=e.wasm.cwrap(hc,null,["number, number, number"])}function v1e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:d,axes:u,originalAxes:c,inputWasTransposed:p}=co(i,a,t);if(p){let b=t.dataIdMap.get(d.dataId).id;l=d,o=b}let h=l.shape.length;E.assertAxesAreInnerMostDims("any",u,h);let[f,m]=E.computeOutAndReduceShapes(l.shape,u),g=k.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(k.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;lz(o,g,b)}if(p&&t.disposeData(d.dataId),s){let b=E.expandShapeToKeepDim(y.shape,c);y.shape=b}return y}var x1e={kernelName:hc,backendName:"wasm",setupFunc:b1e,kernelFunc:v1e};function uz(e){let t;function n(a){t=a.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(a){let{backend:s,inputs:i,attrs:o}=a,{axis:l}=o,{x:d}=i,u=s.dataIdMap.get(d.dataId).id,c=u,p=d,{transposed:h,axes:f,inputWasTransposed:m}=co(d,l,s);if(m){let w=s.dataIdMap.get(h.dataId).id;w!==u&&(p=h,c=w)}let g=p.shape.slice(0,-1),y=s.makeOutput(g,"int32"),b=s.dataIdMap.get(y.dataId).id,v=k.sizeFromShape(y.shape),x=p.shape[f[0]];return t(c,at[p.dtype],v,x,b),m&&s.disposeData(h.dataId),y}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var w1e=uz(fc),k1e=uz(mc),S1e=et(Sl),I1e=et(Il),N1e=et(Nl),C1e=rn(Tl),T1e=et(Cl),dz;function E1e(e){dz=e.wasm.cwrap(El,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _1e(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:d}=n,u=E.computePool2DInfo(a.shape,i,o,1,l,d),c=u.filterHeight,p=u.filterWidth,h=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,y=u.strideHeight,b=u.strideWidth,v=u.inChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);if(u.dilationWidth!==1||u.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${u.dilationHeight}, ${u.dilationWidth}].`);let x=r.makeOutput(u.outShape,"float32"),w=r.dataIdMap.get(x.dataId).id;return dz(s,a.shape[0],a.shape[1],a.shape[2],c,p,h,f,m,g,y,b,v,w),x}var $1e={kernelName:El,backendName:"wasm",setupFunc:E1e,kernelFunc:_1e},cz;function A1e(e){cz=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function R1e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:d}=r,u=E.computePool3DInfo(a.shape,s,i,1,o,l,d),c=n.makeOutput(u.outShape,a.dtype);return cz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var F1e={kernelName:gc,backendName:"wasm",setupFunc:A1e,kernelFunc:R1e},pz;function D1e(e){pz=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function M1e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:d}=r,u=E.computePool3DInfo(s.shape,i,o,1,l,d),c=n.makeOutput(s.shape,s.dtype);return pz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left,u.filterDepth,u.filterHeight,u.filterWidth),c}var O1e={kernelName:If,backendName:"wasm",setupFunc:D1e,kernelFunc:M1e},hz;function P1e(e){hz=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function L1e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l}=r,d=E.computePool2DInfo(s.shape,i,o,1,l),u=n.makeOutput(s.shape,s.dtype);return hz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left,d.filterHeight,d.filterWidth),u}var z1e={kernelName:Sf,backendName:"wasm",setupFunc:P1e,kernelFunc:L1e};function pr(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=k.sizeFromShape(r.shape),i=k.inferFromImplicitShape(a,s);return k.assert(s===k.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var B1e={kernelName:Xc,backendName:"wasm",kernelFunc:pr},fz;function W1e(e){fz=e.wasm.cwrap(_l,null,["number","array","number","number","array","number","number","number","number"])}function U1e(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,d=s.shape.length,u=i?a.shape[l-2]:a.shape[l-1],c=o?s.shape[d-1]:s.shape[d-2],p=i?a.shape[l-1]:a.shape[l-2],h=o?s.shape[d-2]:s.shape[d-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=k.sizeFromShape(f),y=k.sizeFromShape(m),b=hp.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([p,h]);k.assert(u===c,()=>`Error in matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let v=i?[g,u,p]:[g,p,u],x=o?[y,h,c]:[y,c,h],w=pr({inputs:{x:a},backend:n,attrs:{shape:v}}),I=pr({inputs:{x:s},backend:n,attrs:{shape:x}}),N=n.dataIdMap.get(w.dataId).id,T=n.dataIdMap.get(I.dataId).id,A=i?w.shape[2]:w.shape[1],R=o?I.shape[1]:I.shape[2],F=Math.max(g,y),C=n.makeOutput([F,A,R],w.dtype),M=n.dataIdMap.get(C.dataId).id,B=new Uint8Array(new Int32Array(w.shape).buffer),U=new Uint8Array(new Int32Array(I.shape).buffer);return fz(N,B,w.shape.length,T,U,I.shape.length,i,o,M),n.disposeData(w.dataId),n.disposeData(I.dataId),C.shape=b,C}var V1e={kernelName:_l,backendName:"wasm",setupFunc:W1e,kernelFunc:U1e};function ml(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=ln.parseSliceParams(t,n,r),o=ln.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),d=a.makeOutput(i,t.dtype),u=k.computeStrides(t.shape),c=a.dataIdMap.get(d.dataId);if(o){let f=ln.computeFlatOffset(s,u);return t.dtype==="string"?c.stringBytes=l.slice(f,f+k.sizeFromShape(i)):a.typedArrayFromHeap(d).set(l.subarray(f,f+k.sizeFromShape(i))),d}if(t.dtype==="string"){let f=By(l,s,i,t.shape,t.dtype);return c.stringBytes=f,d}let p=a.typedArrayFromHeap(d),h=t.shape.length;if(h===2)j1e(l,u[0],p,s,i);else if(h===3)H1e(l,u[0],u[1],p,s,i);else if(h===4)G1e(l,u[0],u[1],u[2],p,s,i);else{let f=By(l,s,i,t.shape,t.dtype);p.set(f)}return d}function j1e(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let d=i;d<l;d++){let u=d*t+o;n.set(e.subarray(u,u+a[1]),s),s+=a[1]}}function H1e(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],d=a[2],u=o+s[0],c=l+s[1];for(let p=o;p<u;p++)for(let h=l;h<c;h++){let f=p*t+h*n+d;r.set(e.subarray(f,f+s[2]),i),i+=s[2]}}function G1e(e,t,n,r,a,s,i){let o=0,l=s[0],d=s[1],u=s[2],c=l+i[0],p=d+i[1],h=u+i[2],f=s[3];for(let m=l;m<c;m++)for(let g=d;g<p;g++)for(let y=u;y<h;y++){let b=m*t+g*n+y*r+f;a.set(e.subarray(b,b+i[3]),o),o+=i[3]}}var q1e={kernelName:np,backendName:"wasm",kernelFunc:ml};function K1e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce((y,b)=>y*b),l=E.getReshaped(a.shape,s,o),d=E.getPermuted(l.length,s.length),u=E.getReshapedPermuted(a.shape,s,o),c=E.getSliceBeginCoords(i,s.length),p=E.getSliceSize(u,i,s.length),h=pr({inputs:{x:a},backend:n,attrs:{shape:l}}),f=Hi({inputs:{x:h},backend:n,attrs:{perm:d}}),m=pr({inputs:{x:f},backend:n,attrs:{shape:u}}),g=ml({inputs:{x:m},backend:n,attrs:{begin:c,size:p}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}var X1e={kernelName:yc,backendName:"wasm",kernelFunc:K1e},mz;function Q1e(e){mz=e.wasm.cwrap(bc,null,["number","number","boolean","number","number","number"])}function J1e(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,o=s.shape.reduce((c,p)=>c*p,1)!==0,l=a.shape.length===1?[i]:[a.shape[0],i],d=t.makeOutput(l,s.dtype);function u(c){return t.dataIdMap.get(c.dataId).id}return mz(u(a),i,o,u(s),at[s.dtype],u(d)),d}var Z1e={kernelName:bc,backendName:"wasm",setupFunc:Q1e,kernelFunc:J1e},Y1e=rn(vc);function eke(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(a),o=E.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var tke={kernelName:Nf,backendName:"wasm",kernelFunc:eke};function po(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var nke={kernelName:$l,backendName:"wasm",kernelFunc:po},rke=et(Al),gz;function ake(e){gz=e.wasm.cwrap(eo,null,["number","number","number","number"])}function ske(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),d=n.dataIdMap.get(l.dataId).id;return gz(o,s,i,d),l}var ike={kernelName:eo,backendName:"wasm",setupFunc:ake,kernelFunc:ske};function yz(e){let{inputs:t,backend:n}=e,r=k.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map(h=>h.shape);E.assertParamsConsistent(a,r);let s=E.computeOutShape(t.map(h=>h.shape),r),i=t.filter(h=>k.sizeFromShape(h.shape)>0);if(i.length===1)return Xv({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(k.sizeFromShape(s)===0)return o;if(i[0].dtype==="string"){let h=i.map(v=>{let x=[-1,k.sizeFromShape(v.shape.slice(r))];return pr({inputs:{x:v},backend:n,attrs:{shape:x}})}),f=h.map(v=>({vals:n.readSync(v.dataId),shape:v.shape}));s=E.computeOutShape(h.map(v=>v.shape),1);let m=h[0].shape[0]===1,g=R2(f,s,t[0].dtype,m),y=E.computeOutShape(i.map(v=>v.shape),r);o.shape=y;let b=n.dataIdMap.get(o.dataId);return b.stringBytes=E.fromStringArrayToUint8(g),h.forEach(v=>n.disposeData(v.dataId)),o}let l=k.sizeFromShape(i[0].shape.slice(0,r)),d=0,u=i.map(h=>{let f=k.sizeFromShape(h.shape.slice(r));return d+=f,f}),c=i.map(h=>n.typedArrayFromHeap(h)),p=n.typedArrayFromHeap(o);for(let h=0;h<l;h++){let f=h*d;for(let m=0;m<c.length;m++){let g=u[m],y=h*g,b=c[m].subarray(y,y+g);p.set(b,f),f+=g}}return o}var oke={kernelName:xc,backendName:"wasm",kernelFunc:yz},bz;function lke(e){bz=e.wasm.cwrap(Rl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function uke(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:d,pad:u,dimRoundingMode:c,dataFormat:p}=n,h=E.convertConv2DDataFormat(p),f=E.computeConv2DInfo(a.shape,s.shape,l,d,u,c,!1,h),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,v=f.padInfo.bottom,x=f.padInfo.left,w=f.dilationHeight,I=f.dilationWidth,N=f.strideHeight,T=f.strideWidth,A=f.inChannels,R=f.outChannels,F=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(f.outShape,"float32"),M=r.dataIdMap.get(C.dataId).id;return bz(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,v,x,F,w,I,N,T,A,R,M),C}var dke={kernelName:Rl,backendName:"wasm",setupFunc:lke,kernelFunc:uke},vz;function cke(e){vz=e.wasm.cwrap(Fl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function pke(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:d,inputShape:u}=r,c=1,p=E.convertConv2DDataFormat(l),h=E.computeConv2DInfo(u,s.shape,i,c,o,d,!1,p),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:b,inWidth:v,outChannels:x,outHeight:w,outWidth:I,strideHeight:N,strideWidth:T}=h,A=m-1-h.padInfo.top,R=g-1-h.padInfo.left,F=h.dataFormat==="channelsLast",C=k.computeStrides(h.inShape),M=k.computeStrides(a.shape),[B,U,G]=k.computeStrides(s.shape),X=C[0],P=F?C[1]:C[2],q=F?C[2]:1,Q=F?1:C[1],J=M[0],re=F?M[1]:M[2],ae=F?M[2]:1,ie=F?1:M[1],le=t.makeOutput(h.inShape,"float32"),xe=t.dataIdMap.get(le.dataId).id,we=t.dataIdMap.get(a.dataId).id,ge=t.dataIdMap.get(s.dataId).id;return vz(we,ge,f,m,g,b,v,y,w,I,x,N,T,A,R,B,U,G,X,P,q,Q,J,re,ae,ie,xe),le}var hke={kernelName:Fl,backendName:"wasm",setupFunc:cke,kernelFunc:pke},xz;function fke(e){xz=e.wasm.cwrap(Dl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function mke(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let d=E.computeConv3DInfo(a.shape,s.shape,i,l,o),u=n.makeOutput(d.outShape,a.dtype);return xz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),u}var gke={kernelName:Dl,backendName:"wasm",setupFunc:fke,kernelFunc:mke},wz;function yke(e){wz=e.wasm.cwrap(wc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bke(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let d=E.computeConv3DInfo(a.shape,l,i,1,o),u=n.makeOutput(d.filterShape,s.dtype);return wz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),u}var vke={kernelName:wc,backendName:"wasm",setupFunc:yke,kernelFunc:bke},kz;function xke(e){kz=e.wasm.cwrap(kc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wke(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let d=E.computeConv3DInfo(l,s.shape,o,1,i),u=n.makeOutput(d.inShape,a.dtype);return kz(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),u}var kke={kernelName:kc,backendName:"wasm",setupFunc:xke,kernelFunc:wke},Ske=et(Ml),Ike=et(Ol),s1;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(s1||(s1={}));var Sz;function Nke(e){Sz=e.wasm.cwrap(Ic,null,["number","number","number","number","array","number","number","number","number","number"])}function Cke(e){let{backend:t,inputs:n,attrs:r}=e,{method:a,extrapolationValue:s,cropSize:i}=r,{image:o,boxes:l,boxInd:d}=n,u=l.shape[0],[c,p]=i,h=[u,c,p,o.shape[3]],f=t.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=po({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let g=f.id,y=t.dataIdMap.get(l.dataId).id,b=t.dataIdMap.get(d.dataId).id,v=t.makeOutput(h,"float32"),x=t.dataIdMap.get(v.dataId).id,w=new Uint8Array(new Int32Array(o.shape).buffer);return Sz(g,y,b,u,w,c,p,s1[a],s,x),m!=null&&t.disposeData(m.dataId),v}var Tke={kernelName:Ic,backendName:"wasm",setupFunc:Nke,kernelFunc:Cke},Iz;function Eke(e){Iz=e.wasm.cwrap(Sc,null,["number","number","number","number","number","number"])}function _ke(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;k.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`);let d=E.getAxesPermutation([s],l),u=a;d!==null&&(u=Hi({inputs:{x:a},attrs:{perm:d},backend:n}));let c=E.getInnerMostAxes(1,l)[0];E.assertAxesAreInnerMostDims("cumprod",[c],l);let p=n.makeOutput(u.shape,u.dtype),h=u.shape[c],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(p.dataId).id;Iz(f,i?1:0,o?1:0,h,m,at[a.dtype]);let g=p;if(d!==null){let y=E.getUndoAxesPermutation(d);g=Hi({inputs:{x:p},attrs:{perm:y},backend:n}),n.disposeData(u.dataId),n.disposeData(p.dataId)}return g}var $ke={kernelName:Sc,backendName:"wasm",setupFunc:Eke,kernelFunc:_ke},Nz;function Ake(e){Nz=e.wasm.cwrap(Pl,null,["number","number","number","number","number","number"])}function Rke(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;k.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`);let d=E.getAxesPermutation([s],l),u=a;d!==null&&(u=Hi({inputs:{x:a},attrs:{perm:d},backend:n}));let c=E.getInnerMostAxes(1,l)[0];E.assertAxesAreInnerMostDims("cumsum",[c],l);let p=n.makeOutput(u.shape,u.dtype),h=u.shape[c],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(p.dataId).id;Nz(f,i?1:0,o?1:0,h,m,at[a.dtype]);let g=p;if(d!==null){let y=E.getUndoAxesPermutation(d);g=Hi({inputs:{x:p},attrs:{perm:y},backend:n}),n.disposeData(u.dataId),n.disposeData(p.dataId)}return g}var Fke={kernelName:Pl,backendName:"wasm",setupFunc:Ake,kernelFunc:Rke},Cz;function Dke(e){Cz=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function Mke(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i,binaryOutput:o}=r,l=s.shape.reduce((p,h)=>p*h,1)!==0,d=a.shape.length===1?[i]:[a.shape[0],i],u=t.makeOutput(d,s.dtype);function c(p){return t.dataIdMap.get(p.dataId).id}return Cz(c(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,i,l,c(s),at[s.dtype],o,c(u)),u}var Oke={kernelName:Tf,backendName:"wasm",setupFunc:Dke,kernelFunc:Mke},Tz;function Pke(e){Tz=e.wasm.cwrap(Nc,null,["number","number","number","array","number","array","array","number","number"])}function Lke(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],d=i==="NHWC"?a.shape[2]:a.shape[3],u=i==="NHWC"?a.shape[3]:a.shape[1],c=l*s,p=d*s,h=u/(s*s),f=i==="NHWC"?[o,c,p,h]:[o,h,c,p],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(k.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(f).buffer),v=new Uint8Array(new Int32Array(k.computeStrides(f)).buffer),x=t.dataIdMap.get(m.dataId).id;return Tz(g,s,i==="NHWC"?1:0,y,a.shape.length-1,b,v,f.length,x),m}var zke={kernelName:Nc,backendName:"wasm",setupFunc:Pke,kernelFunc:Lke},Ez;function Bke(e){Ez=e.wasm.cwrap(Ll,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Wke(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:d,pad:u,dimRoundingMode:c}=n,p=d??[1,1],h=E.computeConv2DInfo(a.shape,s.shape,l,p,u,c,!0),f=h.filterHeight,m=h.filterWidth,g=h.padInfo.top,y=h.padInfo.right,b=h.padInfo.bottom,v=h.padInfo.left,x=h.dilationHeight,w=h.dilationWidth,I=h.strideHeight,N=h.strideWidth,T=h.inChannels,A=h.outChannels,R=h.padInfo.type==="SAME"?1:0;if(h.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let F=r.makeOutput(h.outShape,"float32"),C=r.dataIdMap.get(F.dataId).id;return Ez(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,v,R,x,w,I,N,T,A,C),F}var Uke={kernelName:Ll,backendName:"wasm",setupFunc:Bke,kernelFunc:Wke},_z;function Vke(e){_z=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function jke(e){let{inputs:t,backend:n}=e,{x:r}=t,a=k.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return _z(n.dataIdMap.get(r.dataId).id,at[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}var Hke={kernelName:Ef,backendName:"wasm",setupFunc:Vke,kernelFunc:jke},$z;function Gke(e){$z=e.wasm.cwrap(zl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function qke(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);let d=E.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),u=n.makeOutput(d.outShape,a.dtype);return $z(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,at[a.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),u}var Kke={kernelName:zl,backendName:"wasm",setupFunc:Gke,kernelFunc:qke},Az;function Xke(e){Az=e.wasm.cwrap(Wd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Qke(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:d}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let u=E.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",d),c=n.makeOutput(s.shape,s.dtype);return Az(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,at[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}var Jke={kernelName:Wd,backendName:"wasm",setupFunc:Xke,kernelFunc:Qke},Rz;function Zke(e){Rz=e.wasm.cwrap(Bd,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Yke(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:d}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let u=E.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",d),c=n.makeOutput(a.shape,a.dtype);return Rz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,at[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}var eSe={kernelName:Bd,backendName:"wasm",setupFunc:Zke,kernelFunc:Yke},tSe=et(Wl),Fz;function nSe(e){Fz=e.wasm.cwrap(Cc,null,["number","number","number"])}function rSe(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=n.makeOutput(a.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return Fz(i(a),i(r),i(s)),s}var aSe={kernelName:Cc,backendName:"wasm",setupFunc:nSe,kernelFunc:rSe},sSe=!1,iSe=rn(Tc,sSe,"bool"),oSe=et(Ul),lSe=et(Vl,"float32");function i1(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(k.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),pr({inputs:{x:a},backend:r,attrs:{shape:o}})}var uSe={kernelName:Ec,backendName:"wasm",kernelFunc:i1},dSe=et(jl,"float32");function Dz(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||k.inferDtype(n);let s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var cSe={kernelName:_f,backendName:"wasm",kernelFunc:Dz},Mz;function pSe(e){Mz=e.wasm.cwrap(_c,null,["number","number","number","number","number","number"])}function hSe(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,d,u]=r.shape;return Mz(s,o,l,d,u,i),a}var fSe={kernelName:_c,backendName:"wasm",kernelFunc:hSe,setupFunc:pSe},mSe=et(Hl),gSe=rn(Gl),Oz;function ySe(e){Oz=e.wasm.cwrap(ql,null,["number","number","number","number","number","number","number"])}function bSe(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:d}=n,u=t.dataIdMap.get(s.dataId).id,c=t.dataIdMap.get(i.dataId).id,p=t.dataIdMap.get(o.dataId).id,h=l!=null?t.dataIdMap.get(l.dataId).id:0,f=d!=null?t.dataIdMap.get(d.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(k.sizeFromShape(s.shape)===0)return m;let g=t.dataIdMap.get(m.dataId).id;return Oz(u,c,p,h,f,a,g),m}var vSe={kernelName:ql,backendName:"wasm",setupFunc:ySe,kernelFunc:bSe},Pz;function xSe(e){Pz=e.wasm.cwrap(Zo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wSe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:d,dilations:u,dataFormat:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=E.computeConv2DInfo(a.shape,s.shape,l,u,d,p),g=df[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(i!=null){let ae=r.dataIdMap.get(i.dataId);if(ae.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ae.shape.length}.`);if(ae.shape[0]!==v)throw new Error(`FusedConv2D bias shape (${ae.shape}) does not match the number of output channels (${v})`);x=ae.id}let w=m.filterHeight,I=m.filterWidth,N=m.padInfo.top,T=m.padInfo.right,A=m.padInfo.bottom,R=m.padInfo.left,F=m.dilationHeight,C=m.dilationWidth,M=m.strideHeight,B=m.strideWidth,U=m.inChannels,G=m.padInfo.type==="SAME"?1:0,X=m.batchSize,P=m.inHeight,q=m.inWidth;if(c!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let Q=r.makeOutput(m.outShape,"float32"),J=r.dataIdMap.get(Q.dataId).id,re=o==null?0:r.dataIdMap.get(o.dataId).id;return Pz(y,X,P,q,b,w,I,x,N,T,A,R,G,F,C,M,B,U,v,g,re,f||0,J),Q}var kSe={kernelName:Zo,backendName:"wasm",setupFunc:xSe,kernelFunc:wSe},Lz;function SSe(e){Lz=e.wasm.cwrap(Yo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ISe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:d,dilations:u,dataFormat:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=E.computeConv2DInfo(a.shape,s.shape,l,u,d,p,!0),g=df[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(i!=null){let ae=r.dataIdMap.get(i.dataId);if(ae.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ae.shape.length}.`);if(ae.shape[0]!==v)throw new Error(`FusedDepthwiseConv2D bias shape (${ae.shape}) does not match the number of output channels (${v})`);x=ae.id}let w=m.filterHeight,I=m.filterWidth,N=m.padInfo.top,T=m.padInfo.right,A=m.padInfo.bottom,R=m.padInfo.left,F=m.dilationHeight,C=m.dilationWidth,M=m.strideHeight,B=m.strideWidth,U=m.inChannels,G=m.padInfo.type==="SAME"?1:0,X=m.batchSize,P=m.inHeight,q=m.inWidth;if(c!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let Q=r.makeOutput(m.outShape,"float32"),J=r.dataIdMap.get(Q.dataId).id,re=o==null?0:r.dataIdMap.get(o.dataId).id;return Lz(y,X,P,q,b,w,I,x,N,T,A,R,G,F,C,M,B,U,v,g,re,f||0,J),Q}var NSe={kernelName:Yo,backendName:"wasm",setupFunc:SSe,kernelFunc:ISe},zz;function CSe(e){zz=e.wasm.cwrap(Ac,null,["number","number","number","number","number","number","array","number"])}function TSe(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=jS.prepareAndValidate(r,a),d=t.makeOutput(s,r.dtype);if(i===0)return d;let u=a.shape,c=u[u.length-1],p=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(d.dataId).id;return zz(p,at[r.dtype],h,i,c,o,f,m),d}var ESe={kernelName:Ac,backendName:"wasm",setupFunc:CSe,kernelFunc:TSe},Bz;function _Se(e){Bz=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function $Se(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=k.parseAxisParam(i,a.shape)[0],d=t.readSync(s.dataId),u=a.shape[l];for(let N=0;N<d.length;++N){let T=d[N];k.assert(T<=u-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${u-1}]`)}let c=E.segment_util.collectGatherOpShapeInfo(a,s,l,o),p=pr({inputs:{x:a},attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]},backend:t}),h=k.sizeFromShape(s.shape),f=pr({inputs:{x:s},attrs:{shape:[c.batchSize,h/c.batchSize]},backend:t}),m=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize],g=t.makeOutput(m,a.dtype);if(k.sizeFromShape(a.shape)===0)return g;let y=p.shape.length-1,b=t.dataIdMap.get(p.dataId).id,v=t.dataIdMap.get(f.dataId).id,x=t.dataIdMap.get(g.dataId).id,w=new Uint8Array(new Int32Array(k.computeStrides(p.shape)).buffer),I=new Uint8Array(new Int32Array(k.computeStrides(m)).buffer);return Bz(b,at[a.dtype],w,y,v,c.batchSize,I,x),t.disposeData(p.dataId),t.disposeData(f.dataId),g.shape=c.outputShape,g}var ASe={kernelName:$c,backendName:"wasm",setupFunc:_Se,kernelFunc:$Se},RSe=!1,FSe=rn(Rc,RSe,"bool"),DSe=!1,MSe=rn(Kl,DSe,"bool"),OSe=et(Ql,"bool"),PSe=et(Jl,"bool"),LSe=et(Zl,"bool"),Wz;function zSe(e){Wz=e.wasm.cwrap(Yl,null,["number","number","number","number"])}function BSe(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(k.sizeFromShape(t.shape)!==0){let i=r.dataIdMap.get(s.dataId).id;Wz(a,at[t.dtype],n,i)}return s}var WSe={kernelName:Yl,backendName:"wasm",setupFunc:zSe,kernelFunc:BSe},USe=!1,VSe=rn(Fc,USe,"bool"),jSe=!1,HSe=rn(Dc,jSe,"bool"),Uz;function GSe(e){Uz=e.wasm.cwrap(Mc,null,["number","number","number","number"])}function qSe(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return Uz(n.dataIdMap.get(o.dataId).id,r,a,i),o}var KSe={kernelName:Mc,backendName:"wasm",setupFunc:GSe,kernelFunc:qSe},XSe=et(eu),QSe=et(tu),JSe=!1,ZSe=rn(Oc,JSe,"bool"),YSe=et(Pc),eIe=!1,tIe=rn(Lc,eIe,"bool"),nIe=!1,rIe=rn(WR,nIe,"bool"),Vz;function aIe(e){Vz=e.wasm.cwrap(nu,null,["number","number","number","number","number","number","number"])}function sIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;if(a.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let d=n.makeOutput(a.shape,a.dtype);return Vz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,a.shape[3],s,i,o,l),d}var iIe={kernelName:nu,backendName:"wasm",setupFunc:aIe,kernelFunc:sIe},jz;function oIe(e){jz=e.wasm.cwrap(zc,null,["number","number","number","number","number","number","number","number","number"])}function lIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:d,beta:u}=r;if(a.dtype!=="float32"||s.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let c=n.makeOutput(a.shape,a.dtype);return jz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(c.dataId).id,i.shape[3],o,l,d,u),c}var uIe={kernelName:zc,backendName:"wasm",setupFunc:oIe,kernelFunc:lIe},Hz;function dIe(e){Hz=e.wasm.cwrap(ru,null,["number","number","number","number"])}function cIe(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:d,axes:u,originalAxes:c,inputWasTransposed:p}=co(i,a,t);if(p){let b=t.dataIdMap.get(d.dataId).id;l=d,o=b}let h=l.shape.length;E.assertAxesAreInnerMostDims("max",u,h);let[f,m]=E.computeOutAndReduceShapes(l.shape,u),g=k.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(k.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;Hz(o,at[i.dtype],g,b)}if(p&&t.disposeData(d.dataId),s){let b=E.expandShapeToKeepDim(y.shape,c);y.shape=b}return y}var pIe={kernelName:ru,backendName:"wasm",setupFunc:dIe,kernelFunc:cIe},hIe=rn(au),Gz;function fIe(e){Gz=e.wasm.cwrap(su,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function mIe(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;k.assert(a.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:d}=n,u=E.computePool2DInfo(a.shape,i,o,1,l,d),c=u.filterHeight,p=u.filterWidth,h=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,y=u.dilationHeight,b=u.dilationWidth,v=u.strideHeight,x=u.strideWidth,w=u.inChannels,I=u.outChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);let N=r.makeOutput(u.outShape,"float32"),T=r.dataIdMap.get(N.dataId).id;return Gz(s,a.shape[0],a.shape[1],a.shape[2],c,p,h,f,m,g,y,b,v,x,w,I,T),N}var gIe={kernelName:su,backendName:"wasm",setupFunc:fIe,kernelFunc:mIe},qz;function yIe(e){qz=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:d}=r,u=E.computePool3DInfo(a.shape,s,i,1,o,l,d),c=n.makeOutput(u.outShape,a.dtype);return qz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var vIe={kernelName:Bc,backendName:"wasm",setupFunc:yIe,kernelFunc:bIe},Kz;function xIe(e){Kz=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wIe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:d}=r,u=E.computePool3DInfo(s.shape,i,o,1,l,d),c=n.makeOutput(s.shape,s.dtype);return Kz(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var kIe={kernelName:Af,backendName:"wasm",setupFunc:xIe,kernelFunc:wIe},Xz;function SIe(e){Xz=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function IIe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:d}=r,u=E.computePool2DInfo(s.shape,i,o,1,l,d),c=n.makeOutput(s.shape,s.dtype);return Xz(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),c}var NIe={kernelName:$f,backendName:"wasm",setupFunc:SIe,kernelFunc:IIe},Qz;function CIe(e){Qz=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function TIe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=r;k.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let d=[1,1];k.assert(E.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let u=E.computePool2DInfo(a.shape,s,i,[1,1],o),c=n.makeOutput(u.outShape,a.dtype),p=n.makeOutput(u.outShape,"int32");return Qz(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,n.dataIdMap.get(p.dataId).id,at[a.dtype],l,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),[c,p]}var EIe={kernelName:Rf,backendName:"wasm",setupFunc:CIe,kernelFunc:TIe},Jz;function _Ie(e){Jz=e.wasm.cwrap(iu,null,["number, number, number"])}function $Ie(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,d=i,{transposed:u,axes:c,originalAxes:p,inputWasTransposed:h}=co(i,a,t),f=c;if(h){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(d=u,l=x,f=E.getInnerMostAxes(f.length,d.shape.length))}E.assertAxesAreInnerMostDims("mean",f,d.shape.length);let[m,g]=E.computeOutAndReduceShapes(d.shape,f),y=k.sizeFromShape(g),b=d;d.dtype!=="float32"&&(b=po({backend:t,inputs:{x:d},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let v=t.makeOutput(m,"float32");if(k.sizeFromShape(d.shape)!==0){let x=t.dataIdMap.get(v.dataId).id;Jz(l,y,x)}if(h&&t.disposeData(u.dataId),s){let x=E.expandShapeToKeepDim(v.shape,p);v.shape=x}return d.dtype!=="float32"&&t.disposeData(b.dataId),v}var AIe={kernelName:iu,backendName:"wasm",setupFunc:_Ie,kernelFunc:$Ie},Zz;function RIe(e){Zz=e.wasm.cwrap(ou,null,["number","number","number","number"])}function FIe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,d=i,{transposed:u,axes:c,originalAxes:p,inputWasTransposed:h}=co(i,a,t);if(h){let v=t.dataIdMap.get(u.dataId).id;v!==o&&(d=u,l=v)}let f=d.shape.length;E.assertAxesAreInnerMostDims("min",c,f);let[m,g]=E.computeOutAndReduceShapes(d.shape,c),y=k.sizeFromShape(g),b=t.makeOutput(m,d.dtype);if(k.sizeFromShape(d.shape)!==0){let v=t.dataIdMap.get(b.dataId).id;Zz(l,at[i.dtype],y,v)}if(h&&t.disposeData(u.dataId),s){let v=E.expandShapeToKeepDim(b.shape,p);b.shape=v}return b}var DIe={kernelName:ou,backendName:"wasm",setupFunc:RIe,kernelFunc:FIe},MIe=rn(lu),o1;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(o1||(o1={}));var Yz;function OIe(e){Yz=e.wasm.cwrap(uu,null,["number","array","number","number","array","array","number","number"])}function PIe(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map((f,m)=>f[0]+t.shape[m]+f[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,d=new Uint8Array(new Int32Array(t.shape).buffer),u=r.map(f=>f[0]),c=r.map(f=>f[1]),p=new Uint8Array(new Int32Array(u).buffer),h=new Uint8Array(new Int32Array(c).buffer);return Yz(i,d,t.shape.length,at[t.dtype],p,h,o1[a],l),o}var LIe={kernelName:uu,backendName:"wasm",kernelFunc:PIe,setupFunc:OIe},eB;function zIe(e){eB=e.wasm.cwrap(Fu,null,["number","number","number","number"])}function tB(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=k.sizeFromShape(n.shape)/o;return k.sizeFromShape(s.shape)===0||eB(a,i,o,l),s}var BIe={kernelName:Fu,backendName:"wasm",setupFunc:zIe,kernelFunc:tB},nB;function WIe(e){nB=e.wasm.cwrap(Wc,null,["number","number","number","number","number","number"])}function UIe(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;if(a.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:tB({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[d,u]=l.shape,c=n.makeOutput([d,s],"int32");return nB(n.dataIdMap.get(l.dataId).id,d,u,s,i,n.dataIdMap.get(c.dataId).id),o||n.disposeData(l.dataId),c}var VIe={kernelName:Wc,backendName:"wasm",setupFunc:WIe,kernelFunc:UIe},jIe=rn(du),HIe=rn(cu),GIe=et(Uc);function oN(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}var rB;function qIe(e){rB=e.wasm.cwrap(jc,"number",["number","number","number","number","number"])}function KIe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,d=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(l.dataId).id,c=rB(d,u,s,a,i),{pSelectedIndices:p,selectedSize:h,pSelectedScores:f,pValidOutputs:m}=oN(t,c);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([h],"int32",p)}var XIe={kernelName:jc,backendName:"wasm",setupFunc:qIe,kernelFunc:KIe},aB;function QIe(e){aB=e.wasm.cwrap(Hc,"number",["number","number","number","number","number","bool"])}function JIe(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:d}=n,u=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(d.dataId).id,p=aB(u,c,s,a,i,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=oN(t,p);t.wasm._free(m);let y=t.makeOutput([f],"int32",h),b=t.makeOutput([],"int32",g);return[y,b]}var ZIe={kernelName:Hc,backendName:"wasm",setupFunc:QIe,kernelFunc:JIe},sB;function YIe(e){sB=e.wasm.cwrap(Gc,"number",["number","number","number","number","number","number"])}function e2e(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:d}=n,u=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(d.dataId).id,p=sB(u,c,s,a,i,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=oN(t,p);t.wasm._free(g);let y=t.makeOutput([f],"int32",h),b=t.makeOutput([f],"float32",m);return[y,b]}var t2e={kernelName:Gc,backendName:"wasm",setupFunc:YIe,kernelFunc:e2e},n2e=!1,r2e=rn(Vc,n2e,"bool"),iB;function a2e(e){iB=e.wasm.cwrap(pu,null,["number","number","number","number","number"])}function s2e(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,d=n.makeOutput([...a.shape,i],s),u=n.dataIdMap.get(d.dataId).id,c=n.dataIdMap.get(a.dataId).id;return iB(c,i,o,l,u),d}var i2e={kernelName:pu,backendName:"wasm",setupFunc:a2e,kernelFunc:s2e};function o2e(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var l2e={kernelName:qc,backendName:"wasm",kernelFunc:o2e};function u2e(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return i1({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{k.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),k.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let c=i1({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(c),c}),d=yz({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeData(u.dataId)),d}var d2e={kernelName:Kc,backendName:"wasm",kernelFunc:u2e},oB;function c2e(e){oB=e.wasm.cwrap(hu,null,["number","array","number","number","array","array","number","number"])}function p2e(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map((f,m)=>f[0]+t.shape[m]+f[1]);if(k.sizeFromShape(t.shape)===0)return Dz({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,d=new Uint8Array(new Int32Array(t.shape).buffer),u=r.map(f=>f[0]),c=r.map(f=>f[1]),p=new Uint8Array(new Int32Array(u).buffer),h=new Uint8Array(new Int32Array(c).buffer);return oB(i,d,t.shape.length,at[t.dtype],p,h,a,l),o}var lB={kernelName:hu,backendName:"wasm",kernelFunc:p2e,setupFunc:c2e},h2e=rn(fu),uB;function f2e(e){uB=e.wasm.cwrap(mu,null,["number","number","number"])}function m2e(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,d=l;l.dtype!=="float32"&&(d=po({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(d.dataId).id);let u=n.makeOutput(r.shape,"float32"),c=n.dataIdMap.get(u.dataId).id;return uB(o,i,c),l.dtype!=="float32"&&n.disposeData(d.dataId),u}var g2e={kernelName:mu,backendName:"wasm",setupFunc:f2e,kernelFunc:m2e},dB;function y2e(e){dB=e.wasm.cwrap(gu,null,["number","number","number","number"])}function b2e(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,d=i,{transposed:u,axes:c,originalAxes:p,inputWasTransposed:h}=co(i,a,t),f=c;if(h){let v=t.dataIdMap.get(u.dataId).id;v!==o&&(d=u,l=v,f=E.getInnerMostAxes(f.length,d.shape.length))}E.assertAxesAreInnerMostDims("prod",f,d.shape.length);let[m,g]=E.computeOutAndReduceShapes(d.shape,f),y=k.sizeFromShape(g),b=t.makeOutput(m,d.dtype);if(k.sizeFromShape(d.shape)!==0){let v=t.dataIdMap.get(b.dataId).id;dB(l,y,at[b.dtype],v)}if(h&&t.disposeData(u.dataId),s){let v=E.expandShapeToKeepDim(b.shape,p);b.shape=v}return b}var v2e={kernelName:gu,backendName:"wasm",setupFunc:y2e,kernelFunc:b2e},x2e=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=M2(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},w2e={kernelName:Ff,backendName:"wasm",kernelFunc:x2e},k2e=rn(Bl),S2e=et(yu),I2e=et(bu),N2e=et(wu),cB;function C2e(e){cB=e.wasm.cwrap(xu,null,["number","number","number","number","number","number","number","number","number","number"])}function T2e(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,d]=o,[u,c,p,h]=a.shape,f=[u,l,d,h],m=t.dataIdMap.get(a.dataId),g;m.dtype!=="float32"&&(g=po({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let y=m.id,b=t.makeOutput(f,"float32");if(k.sizeFromShape(a.shape)===0)return b;let v=t.dataIdMap.get(b.dataId).id;return cB(y,u,c,p,h,l,d,s?1:0,i?1:0,v),g!=null&&t.disposeData(g.dataId),b}var E2e={kernelName:xu,backendName:"wasm",setupFunc:C2e,kernelFunc:T2e},pB;function _2e(e){pB=e.wasm.cwrap(Jc,null,["number","number","number","array","array","boolean"])}function $2e(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId),d;return l.dtype!=="float32"&&(d=po({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(d.dataId)),pB(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),d!=null&&n.disposeData(d.dataId),o}var A2e={kernelName:Jc,backendName:"wasm",setupFunc:_2e,kernelFunc:$2e},hB;function R2e(e){hB=e.wasm.cwrap(vu,null,["number","number","number","number","number","number","number","number","number","number"])}function F2e(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,d]=o,[u,c,p,h]=a.shape,f=[u,l,d,h],m=t.makeOutput(f,"float32");if(k.sizeFromShape(a.shape)===0)return m;let g=t.dataIdMap.get(a.dataId),y;g.dtype!=="float32"&&(y=po({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let b=g.id,v=t.dataIdMap.get(m.dataId).id;return hB(b,u,c,p,h,l,d,s?1:0,i?1:0,v),y!=null&&t.disposeData(y.dataId),m}var D2e={kernelName:vu,backendName:"wasm",setupFunc:R2e,kernelFunc:F2e},fB;function M2e(e){fB=e.wasm.cwrap(Qc,null,["number","number","number","array","array","boolean"])}function O2e(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId),d;return l.dtype!=="float32"&&(d=po({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(d.dataId)),fB(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),d!=null&&n.disposeData(d.dataId),o}var P2e={kernelName:Qc,backendName:"wasm",setupFunc:M2e,kernelFunc:O2e},mB;function L2e(e){mB=e.wasm.cwrap(ku,null,["number","array","number","array","number","number"])}function z2e(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=k.parseAxisParam(s,a.shape);if(a.shape.length===0)return Xv({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,d=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(i).buffer),c=new Uint8Array(new Int32Array(a.shape).buffer);mB(l,u,i.length,c,a.shape.length,d);let p=pr({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),p}var B2e={kernelName:ku,backendName:"wasm",kernelFunc:z2e,setupFunc:L2e},gB;function W2e(e){gB=e.wasm.cwrap(pp,null,["number","number","number","number","number","number","number","number","array","number","number"])}function U2e(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),d=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(l.dataId).id,[c,p,h,f]=a.shape,[m,g]=E.getImageCenter(o,p,h),y=i===0,b=255,v=typeof i=="number"?[i,i,i,y?0:b]:[...i,b],x=new Uint8Array(new Int32Array(v).buffer);return gB(d,c,p,h,f,s,m,g,x,v.length,u),l}var V2e={kernelName:pp,backendName:"wasm",kernelFunc:U2e,setupFunc:W2e},j2e=et(Su),H2e=et(Iu),yB;function G2e(e){yB=e.wasm.cwrap(Zc,null,["number","number","number","number","number","number","array","number","number"])}function q2e(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(k.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:d,sliceSize:u,strides:c,outputSize:p}=cv.calculateShapes(s,a,i),h=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(c).buffer),g=t.dataIdMap.get(o.dataId).id;return yB(h,f,at[s.dtype],l,d,u,m,p,g),o}var K2e={kernelName:Zc,backendName:"wasm",setupFunc:G2e,kernelFunc:q2e},bB;function X2e(e){bB=e.wasm.cwrap(ep,null,["number","number","number","number","number","number","bool","number"])}function Q2e(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(d){return n.dataIdMap.get(d.dataId).id}return bB(l(a),l(s),a.shape[0],a.shape[1],s.shape[1],at[a.dtype],i==="left",l(o)),o}var J2e={kernelName:ep,backendName:"wasm",setupFunc:X2e,kernelFunc:Q2e},vB;function Z2e(e){vB=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Y2e(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,d=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(d.dataId).id,c=r.shape.length,p=a.shape.length,h=c===0||c>1||p===1?1:k.sizeFromShape(a.shape.slice(1));return vB(i,o,l,h,u),d}var eNe={kernelName:tp,backendName:"wasm",kernelFunc:Y2e,setupFunc:Z2e},tNe=et(Nu),xB;function nNe(e){xB=e.wasm.cwrap(_u,null,["number","number"])}function rNe(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return k.sizeFromShape(a.shape)===0||xB(r,s),a}var aNe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:nNe,kernelFunc:rNe},sNe=et(Eu),iNe=et(Cu),oNe=et(Tu),lNe=et($u);function uNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=k.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let d=lB.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=E.getReshaped(d.shape,s,o,!1),c=E.getPermuted(u.length,s.length,!1),p=E.getReshapedPermuted(d.shape,s,o,!1),h=pr({inputs:{x:d},backend:n,attrs:{shape:u}}),f=Hi({inputs:{x:h},backend:n,attrs:{perm:c}}),m=pr({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeData(d.dataId),n.disposeData(h.dataId),n.disposeData(f.dataId),m}var dNe={kernelName:rp,backendName:"wasm",kernelFunc:uNe},wB;function cNe(e){wB=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function pNe(e){let{backend:t,inputs:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=n,o=r.shape[0],l=r.shape[1],d=t.readSync(s.dataId)[0],u=[o+d,l],c=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(a.dataId).id,h=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(u,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(u.slice(0,1),a.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([d],"bool"),v=t.dataIdMap.get(b.dataId).id,x=t.makeOutput([o],r.dtype),w=t.dataIdMap.get(x.dataId).id,I=t.makeOutput([4],"int32"),N=t.dataIdMap.get(I.dataId).id,T=wB(c,p,at[a.dtype],o,d,l,h,m,y,v,w,N),A=t.readSync(I.dataId),R;switch(A[0]){case 1:{R=E.getSparseFillEmptyRowsIndicesDenseShapeMismatch(A[1]);break}case 2:{R=E.getSparseFillEmptyRowsNegativeIndexErrorMessage(A[1],A[2]);break}case 3:R=E.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(A[1],A[2],A[3]);break;default:R=""}if(t.disposeData(I.dataId),R)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(x.dataId),new Error(R);let F=f,C=g;return T!==u[0]&&(F=ml({inputs:{x:f},attrs:{begin:0,size:[T,l]},backend:t}),C=ml({inputs:{x:g},attrs:{begin:0,size:T},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[F,C,b,x]}var hNe={kernelName:Df,backendName:"wasm",setupFunc:cNe,kernelFunc:pNe},kB;function fNe(e){kB=e.wasm.cwrap(sp,null,["number","number","number","number","number","number","number"])}function mNe(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,d=r.shape[0],u=k.sizeFromShape(s.shape),c=t.makeOutput([d,u],r.dtype),p=t.dataIdMap.get(c.dataId).id,h=t.makeOutput([u],s.dtype),f=t.dataIdMap.get(h.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;kB(i,o,l,d,p,f,g);let y=t.readSync(m.dataId),b;switch(y[0]){case 0:{b=E.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=E.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=E.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let v=Array.from(t.readSync(a.dataId)),x=Array.from(t.readSync(h.dataId));b=E.getSparseReshapeInputOutputMultipleErrorMessage(v,x);break}case 4:{let v=Array.from(t.readSync(a.dataId)),x=Array.from(t.readSync(h.dataId));b=E.getSparseReshapeInputOutputMismatchErrorMessage(v,x);break}default:b=""}if(t.disposeData(m.dataId),b)throw t.disposeData(c.dataId),t.disposeData(h.dataId),new Error(b);return[c,h]}var gNe={kernelName:sp,backendName:"wasm",setupFunc:fNe,kernelFunc:mNe},SB;function IB(e){SB=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function NB(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],d=o>0?l+1:0;if(d<0)throw new Error(E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let u=a.shape.slice();u[0]=d;let c=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(u,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;SB(c,at[a.dtype],a.shape[0],p,h,m,y,t,0);let b=n.readSync(g.dataId),v;switch(b[0]){case 0:{v=E.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{v=E.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:v=E.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b[1],b[2]);break;case 3:v=E.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b[1],b[2],b[3]);break;default:v=""}if(n.disposeData(g.dataId),v)throw n.disposeData(f.dataId),new Error(v);return f}function yNe(e){return NB(e,!0)}var bNe={kernelName:Mf,backendName:"wasm",setupFunc:IB,kernelFunc:yNe};function vNe(e){return NB(e,!1)}var xNe={kernelName:Of,backendName:"wasm",setupFunc:IB,kernelFunc:vNe},CB;function wNe(e){CB=e.wasm.cwrap(ip,null,["number","number","number","number","number","number","number","number","array","number","number"])}function kNe(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(k.sizeFromShape(o)===0)return l;let{sliceRank:d,numUpdates:u,sliceSize:c,strides:p,outputSize:h}=E.calculateShapes(s,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(p).buffer),b=t.dataIdMap.get(l.dataId).id;return CB(f,m,s.shape.length,g,at[i.dtype],d,u,c,y,h,b),l}var SNe={kernelName:ip,backendName:"wasm",setupFunc:wNe,kernelFunc:kNe};function INe(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=k.parseAxisParam(i,a.shape)[0],l=E.prepareSplitSize(a,s,o),d=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map(c=>{let p=[...u];p[o]=c;let h=ml({inputs:{x:a},attrs:{begin:d,size:p},backend:r});return d[o]+=c,h})}var NNe={kernelName:ap,backendName:"wasm",kernelFunc:INe},CNe=et(Au),TNe=et(Pf),ENe=rn(Du),TB;function _Ne(e){TB=e.wasm.cwrap(no,null,["number","number","number","number"])}function $Ne(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return TB(i,a,at[s.dtype],l),o}var ANe={kernelName:no,backendName:"wasm",setupFunc:_Ne,kernelFunc:$Ne},EB;function RNe(e){EB=e.wasm.cwrap(op,null,["number","array","number","array","array","array","array","array","number","number"])}function FNe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{begin:s,end:i,strides:o,beginMask:l,endMask:d,ellipsisMask:u,newAxisMask:c,shrinkAxisMask:p}=r,{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=ln.sliceInfo(a.shape,s,i,o,l,d,u,c,p),w;if(m)w=pr({inputs:{x:a},backend:t,attrs:{shape:f}});else if(g||y){k.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let I=ln.computeOutShape(b,v,x),N=ml({inputs:{x:a},backend:t,attrs:{begin:b,size:I}});w=pr({inputs:{x:N},backend:t,attrs:{shape:f}}),t.disposeData(N.dataId)}else{let I=t.makeOutput(h,"float32"),N=t.dataIdMap.get(a.dataId).id,T=new Uint8Array(new Int32Array(k.computeStrides(a.shape)).buffer),A=new Uint8Array(new Int32Array(b).buffer),R=new Uint8Array(new Int32Array(v).buffer),F=new Uint8Array(new Int32Array(x).buffer),C=new Uint8Array(new Int32Array(h).buffer),M=new Uint8Array(new Int32Array(k.computeStrides(h)).buffer),B=t.dataIdMap.get(I.dataId).id;EB(N,T,a.shape.length,A,R,F,C,M,h.length,B),w=pr({inputs:{x:I},backend:t,attrs:{shape:f}}),t.disposeData(I.dataId)}return w}var DNe={kernelName:op,backendName:"wasm",setupFunc:RNe,kernelFunc:FNe};function MNe(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:d,padWidth:u,preserveShortSequences:c}=r,p=t.readSync(a.dataId),h=t.readSync(s.dataId),[f,m]=P2(p,h,i,o,l,d,u,c),g=t.makeOutput([f.length],"string"),y=t.dataIdMap.get(g.dataId);y.stringBytes=f;let b=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(b).set(m),[g,b]}var ONe={kernelName:zf,backendName:"wasm",kernelFunc:MNe};function PNe(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[d,u,c]=L2(o,l[0],i),p=u.length,h=t.makeOutput([p,2],"int32");t.typedArrayFromHeap(h).set(d);let f=t.makeOutput([p],"string"),m=t.dataIdMap.get(f.dataId);m.stringBytes=u;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(c),[h,f,g]}var LNe={kernelName:Bf,backendName:"wasm",kernelFunc:PNe};function zNe(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=t.readSync(a.dataId),o=z2(i,s),l=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var BNe={kernelName:Wf,backendName:"wasm",kernelFunc:zNe},WNe=rn(Mu),_B;function UNe(e){_B=e.wasm.cwrap(Ru,null,["number","number","number","number"])}function VNe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,d=i,{transposed:u,axes:c,originalAxes:p,inputWasTransposed:h}=co(i,a,t),f=c;if(h){let v=t.dataIdMap.get(u.dataId).id;v!==o&&(d=u,l=v,f=E.getInnerMostAxes(f.length,d.shape.length))}E.assertAxesAreInnerMostDims("sum",f,d.shape.length);let[m,g]=E.computeOutAndReduceShapes(d.shape,f),y=k.sizeFromShape(g),b=t.makeOutput(m,d.dtype);if(k.sizeFromShape(d.shape)!==0){let v=t.dataIdMap.get(b.dataId).id;_B(l,y,at[b.dtype],v)}if(h&&t.disposeData(u.dataId),s){let v=E.expandShapeToKeepDim(b.shape,p);b.shape=v}return b}var jNe={kernelName:Ru,backendName:"wasm",setupFunc:UNe,kernelFunc:VNe},HNe=et(Ou),GNe=et(Pu),$B;function qNe(e){$B=e.wasm.cwrap(Yc,null,["number","number","number","number","number","number","array","number","number","number"])}function KNe(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=n,o=t.makeOutput(a.shape,a.dtype);if(k.sizeFromShape(a.shape)===0)return o;let{sliceRank:l,numUpdates:d,sliceSize:u,strides:c,outputSize:p}=cv.calculateShapes(i,s,a.shape),h=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(c).buffer),y=t.dataIdMap.get(o.dataId).id;return $B(h,f,at[i.dtype],l,d,u,g,p,y,m),o}var XNe={kernelName:Yc,backendName:"wasm",setupFunc:qNe,kernelFunc:KNe},AB;function QNe(e){AB=e.wasm.cwrap(to,null,["number","array","number","array","number","number"])}function JNe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let p=0;p<o.length;p++)o[p]=a.shape[p]*i[p];let l=new Uint8Array(new Int32Array(a.shape).buffer),d=new Uint8Array(new Int32Array(o).buffer),u=n.makeOutput(o,a.dtype),c=n.dataIdMap.get(u.dataId).id;return AB(s,l,a.shape.length,d,o.length,at[u.dtype],c),u}var ZNe={kernelName:to,backendName:"wasm",setupFunc:QNe,kernelFunc:JNe},RB;function YNe(e){RB=e.wasm.cwrap(lp,null,["number","array","number","number","number","bool","number","number"])}var eCe=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:s}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let d=t.makeOutput(l,r.dtype),u=t.dataIdMap.get(d.dataId).id,c=t.makeOutput(l,"int32"),p=t.dataIdMap.get(c.dataId).id;return RB(i,o,r.shape.length,at[r.dtype],a,s,u,p),[d,c]},tCe={kernelName:lp,backendName:"wasm",setupFunc:YNe,kernelFunc:eCe},FB;function nCe(e){FB=e.wasm.cwrap(up,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function rCe(e){let{backend:t,inputs:n,attrs:r}=e,{image:a,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:d}=r,[u,c,p,h]=a.shape,[f,m]=d??[c,p],g=[u,f,m,h],y=new Uint8Array(new Int32Array(k.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(k.computeStrides(g)).buffer),v=t.makeOutput(g,a.dtype),x=t.dataIdMap.get(v.dataId).id,w=t.dataIdMap.get(a.dataId).id,I=t.dataIdMap.get(s.dataId).id,N=i==="nearest"?1:2,T;switch(o){case"constant":T=1;break;case"reflect":T=2;break;case"wrap":T=3;break;case"nearest":T=4;break;default:T=1;break}return FB(w,I,s.shape[0]>1,u,f,m,h,p,c,y,a.shape.length-1,b,g.length-1,N,T,l,x),v}var aCe={kernelName:up,backendName:"wasm",setupFunc:nCe,kernelFunc:rCe};function sCe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=W2(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}var iCe={kernelName:Uf,backendName:"wasm",kernelFunc:sCe};function oCe(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),d=0;for(let h=0;h<o;h++)h!==s&&(l[d++]=a.shape[h]);let u=new Array(i),c=new Array(o).fill(0),p=a.shape.slice();p[s]=1;for(let h=0;h<u.length;h++)c[s]=h,u[h]=ml({inputs:{x:a},attrs:{begin:c,size:p},backend:n});return u.map(({dataId:h,dtype:f})=>({dataId:h,dtype:f,shape:l}))}var lCe={kernelName:dp,backendName:"wasm",kernelFunc:oCe};function uCe(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var dCe={kernelName:cp,backendName:"wasm",kernelFunc:uCe},cCe=[n1e,r1e,a1e,s1e,i1e,u1e,y1e,x1e,w1e,k1e,S1e,I1e,N1e,C1e,T1e,$1e,z1e,F1e,O1e,V1e,X1e,Z1e,Y1e,tke,nke,rke,ike,oke,dke,hke,gke,vke,kke,Ske,Ike,Tke,$ke,Fke,Oke,zke,Uke,Hke,Kke,Jke,eSe,tSe,aSe,iSe,oSe,lSe,uSe,dSe,cSe,fSe,mSe,gSe,vSe,kSe,NSe,ESe,ASe,FSe,MSe,d1e,OSe,PSe,LSe,WSe,VSe,HSe,KSe,QSe,XSe,ZSe,YSe,tIe,rIe,iIe,uIe,pIe,hIe,gIe,vIe,kIe,NIe,EIe,AIe,DIe,MIe,LIe,VIe,jIe,HIe,GIe,XIe,ZIe,t2e,r2e,i2e,l2e,d2e,lB,h2e,g2e,v2e,w2e,k2e,S2e,I2e,N2e,B1e,E2e,A2e,D2e,P2e,B2e,V2e,j2e,H2e,K2e,J2e,eNe,tNe,aNe,sNe,iNe,oNe,q1e,BIe,lNe,dNe,hNe,gNe,bNe,xNe,SNe,NNe,CNe,TNe,ENe,ANe,DNe,ONe,LNe,BNe,WNe,jNe,HNe,GNe,XNe,ZNe,tCe,aCe,f1e,iCe,lCe,dCe];for(let e of cCe)jf(e);var l1=K();l1.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});l1.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(l1.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var p_=Zi(G6()),pCe=Zi(q6()),h_=Zi(K6()),f_=p_.default||p_,hCe=h_.default||h_,DB=class extends wf{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(MB),u1=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Sb(this,ua())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=k.now();return e(),{kernelMs:k.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if(r==="string"){let d=t;this.dataIdMap.set(e,{id:s,stringBytes:d,shape:n,dtype:r,memoryOffset:null,refCount:a});return}let i=k.sizeFromShape(n),o=i*k.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(a==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||k.sizeFromShape(s);let o=k.bytesPerElement(a),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return gCe(l.buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(n==null)a=this.write(r??null,e,t);else{let s=this.dataIdNextNumber++;a={id:s},this.dataIdMap.set(a,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=k.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=k.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function fCe(e){return(t,n)=>(k.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(a=>{WebAssembly.instantiate(a,t).then(s=>{n(s.instance,s.module)})})}),{})}function m_(e,t,n){if(qy!=null)return qy;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),Ih!=null&&Ih[r]!=null?Ih[r]:n+r}async function mCe(){let[e,t]=await Promise.all([K().getAsync("WASM_HAS_SIMD_SUPPORT"),K().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let a={};a.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let d=pCe.wasmWorkerContents.replace(/\n/g,"\\n"),u=new Blob([d],{type:"application/javascript"});return URL.createObjectURL(u)}return o.endsWith(".wasm")?m_(e,t,ph??l):l+o},lN&&(a.instantiateWasm=fCe(m_(e,t,ph??"")));let s=!1;a.onAbort=()=>{s||Nh||(Nh=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&qy==null?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+f_.toString()],{type:"text/javascript"}),i=f_(a)):i=hCe(a),i.then(o=>{s=!0,Nh=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(r)})}function gCe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var yCe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],qy=null,ph=null,Ih={},Nh=!1,lN=!1;function bCe(e,t=!1){if(nF("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Nh)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");qy=e,lN=t}function vCe(e,t=!1){if(Nh)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")ph=e;else{Ih=e;let n=yCe.filter(r=>Ih[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}lN=t}var MB=-1,u1=-1;function xCe(e){MB=e}function wCe(){if(u1===-1)throw new Error("WASM backend not initialized.");return u1}var kCe="4.22.0",SCe=2;Wb("wasm",async()=>{let{wasm:e}=await mCe();return new DB(e)},SCe);var g_="4.22.0",ICe="4.22.0",NCe="4.22.0",CCe="4.22.0",TCe="4.22.0",ECe={tfjs:g_,"tfjs-core":g_,"tfjs-converter":ICe,"tfjs-backend-cpu":NCe,"tfjs-backend-webgl":CCe,"tfjs-backend-wasm":TCe},_Ce={};gk(_Ce,{AnchorPosition:()=>JB,DrawBox:()=>e4,DrawBoxOptions:()=>YB,DrawFaceLandmarks:()=>y4,DrawFaceLandmarksOptions:()=>g4,DrawTextField:()=>mN,DrawTextFieldOptions:()=>fN,drawContour:()=>ri,drawDetections:()=>UCe,drawFaceExpressions:()=>tTe,drawFaceLandmarks:()=>rTe});function ri(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:a},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(r,a)}),n){let r=t[t.length-1],a=t[0];if(!r||!a)return;e.moveTo(r.x,r.y),e.lineTo(a.x,a.y)}e.stroke()}var $Ce={};gk($Ce,{computeReshapedDimensions:()=>zB,getCenterPoint:()=>dN,isDimensions:()=>c1,isEven:()=>d1,isFloat:()=>LB,isTensor:()=>Fp,isTensor1D:()=>ACe,isTensor2D:()=>PB,isTensor3D:()=>Sm,isTensor4D:()=>Fs,isValidNumber:()=>Vo,isValidProbablitiy:()=>RCe,range:()=>nc,round:()=>uN});var $d=class OB{constructor(t,n){if(!Vo(t)||!Vo(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new OB(1/this.width,1/this.height)}};function Fp(e,t){return e instanceof Pe&&e.shape.length===t}function ACe(e){return Fp(e,1)}function PB(e){return Fp(e,2)}function Sm(e){return Fp(e,3)}function Fs(e){return Fp(e,4)}function LB(e){return e%1!==0}function d1(e){return e%2===0}function uN(e,t=2){let n=10**t;return Math.floor(e*n)/n}function c1(e){return e&&e.width&&e.height}function zB({width:e,height:t},n){let r=n/Math.max(t,e);return new $d(Math.round(e*r),Math.round(t*r))}function dN(e){return e.reduce((t,n)=>t.add(n),new ht(0,0)).div(new ht(e.length,e.length))}function nc(e,t,n){return Array(e).fill(0).map((r,a)=>t+a*n)}function Vo(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function RCe(e){return Vo(e)&&e>=0&&e<=1}var ht=class No{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new No(this.x+t.x,this.y+t.y)}sub(t){return new No(this.x-t.x,this.y-t.y)}mul(t){return new No(this.x*t.x,this.y*t.y)}div(t){return new No(this.x/t.x,this.y/t.y)}abs(){return new No(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new No(Math.floor(this.x),Math.floor(this.y))}},gl=class Na{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(Vo)}static assertIsValidBox(t,n,r=!1){if(!Na.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},a=[r.left,r.top,r.right,r.bottom].every(Vo),s=[r.x,r.y,r.width,r.height].every(Vo);if(!s&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,d]=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];Na.assertIsValidBox({x:i,y:o,width:l,height:d},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=d}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new ht(this.left,this.top)}get topRight(){return new ht(this.right,this.top)}get bottomLeft(){return new ht(this.left,this.bottom)}get bottomRight(){return new ht(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new Na({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new Na({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,s=Math.abs(r-a);return r<a&&(t-=s/2,r+=s),a<r&&(n-=s/2,a+=s),new Na({x:t,y:n,width:r,height:a})}rescale(t){let n=c1(t)?t.width:t,r=c1(t)?t.height:t;return new Na({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new Na({x:r,y:a,width:s,height:i})}clipAtImageBorders(t,n){let{x:r,y:a,right:s,bottom:i}=this,o=Math.max(r,0),l=Math.max(a,0),d=s-o,u=i-l,c=Math.min(d,t-o),p=Math.min(u,n-l);return new Na({x:o,y:l,width:c,height:p}).floor()}shift(t,n){let{width:r,height:a}=this,s=this.x+t,i=this.y+n;return new Na({x:s,y:i,width:r,height:a})}padAtBorders(t,n){let r=this.width+1,a=this.height+1,s=1,i=1,o=r,l=a,d=this.left,u=this.top,c=this.right,p=this.bottom;return c>n&&(o=-c+n+r,c=n),p>t&&(l=-p+t+a,p=t),d<1&&(l=2-d,d=1),u<1&&(l=2-u,u=1),{dy:i,edy:l,dx:s,edx:o,y:u,ey:p,x:d,ex:c,w:r,h:a}}calibrate(t){return new Na({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},BB=class extends gl{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},WB=class UB{constructor(t,n,r,a,s){this._imageDims=new $d(s.width,s.height),this._score=t,this._classScore=n,this._className=r,this._box=new gl(a).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new gl(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new UB(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},Ba=class VB extends WB{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:a,imageDims:s}=super.forSize(t,n);return new VB(r,a,s)}};function FCe(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),a=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=r*a;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function DCe(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,l)=>l<o?l:o,1/0),a=n.reduce((o,l)=>l<o?l:o,1/0),s=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new BB(r,a,s,i)}function MCe(e,t,n,r=!0){let a=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;a.length>0;){let i=a.pop();s.push(i);let o=a,l=[];for(let d=0;d<o.length;d++){let u=o[d],c=e[i],p=e[u];l.push(FCe(c,p,r))}a=a.filter((d,u)=>l[u]<=n)}return s}function Im(e,t){return j(()=>{let[n,r,a]=t,s=Dr([...e.shape.slice(0,3),1],n,"float32"),i=Dr([...e.shape.slice(0,3),1],r,"float32"),o=Dr([...e.shape.slice(0,3),1],a,"float32"),l=gt([s,i,o],3);return me(e,l)})}function OCe(e,t=!1){return j(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=c=>{let p=e.shape.slice();return p[i]=c,Dr(p,0,"float32")},l=o(s),d=a-l.shape[i],u=[t&&d?o(d):null,e,l].filter(c=>!!c).map(c=>ue(c,"float32"));return gt(u,i)})}function Zx(e){return 1/(1+Math.exp(-e))}var jB=class extends gl{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},PCe=.5,LCe=.43,zCe=.45,Ky=class{constructor(e,t,n=new ht(0,0)){let{width:r,height:a}=t;this._imgDims=new $d(r,a),this._shift=n,this._positions=e.map(s=>s.mul(new ht(r,a)).add(n))}get shift(){return new ht(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new ht(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new ht(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let a=e instanceof Ba?e.box.floor():new gl(e);return this.shiftBy(a.x,a.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=u=>r.sub(u).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/zCe),o=dN(e),l=Math.floor(Math.max(0,o.x-PCe*i)),d=Math.floor(Math.max(0,o.y-LCe*i));return new jB(l,d,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+d))}alignMinBbox(e){let t=DCe(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},HB=class extends Ky{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(dN)}};function Xy(e){return e.detection instanceof Ba}function GB(e,t){return{...e,detection:t}}function qB(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function cN(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function KB(e){let t="";if(!e&&cN())try{e=I6("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,a)=>{e.readFile(n,(s,i)=>s?a(s):r(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function XB(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},a=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=KB();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:a,createVideoElement:s,fetch:i,...o}}function QB(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var pn;function BCe(){if(!pn)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return pn}function p1(e){pn=e}function pN(){return QB()?p1(qB()):cN()?p1(XB()):null}function WCe(e){if(pn||pN(),!pn)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=pn.Canvas,Image:n=pn.Image}=e;pn.Canvas=t,pn.Image=n,pn.createCanvasElement=e.createCanvasElement||(()=>new t),pn.createImageElement=e.createImageElement||(()=>new n),pn.ImageData=e.ImageData||pn.ImageData,pn.Video=e.Video||pn.Video,pn.fetch=e.fetch||pn.fetch,pn.readFile=e.readFile||pn.readFile}var gr={getEnv:BCe,setEnv:p1,initialize:pN,createBrowserEnv:qB,createFileSystem:KB,createNodejsEnv:XB,monkeyPatch:WCe,isBrowser:QB,isNodejs:cN};pN();function hN(e){return!gr.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Gi(e){let{Canvas:t,CanvasRenderingContext2D:n}=gr.getEnv();if(e instanceof n)return e;let r=hN(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}var JB=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(JB||{}),fN=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},mN=class ZB{constructor(t,n,r={}){this.text=typeof t=="string"?[t]:t instanceof ZB?t.text:t,this.anchor=n,this.options=new fN(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,a)=>r<a?a:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,a=r==="BOTTOM_RIGHT"||r==="TOP_RIGHT",s=r==="BOTTOM_LEFT"||r==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),l=a?this.anchor.x-i:this.anchor.x,d=s?this.anchor.y-o:this.anchor.y;if(n){let{width:u,height:c}=n,p=Math.max(Math.min(l,u-i),0),h=Math.max(Math.min(d,c-o),0);return{x:p,y:h}}return{x:l,y:d}}draw(t){let n=hN(t),r=Gi(n),{backgroundColor:a,fontColor:s,fontSize:i,fontStyle:o,padding:l}=this.options;r.font=`${i}px ${o}`;let d=this.measureWidth(r),u=this.measureHeight();r.fillStyle=a;let c=this.getUpperLeft(r,n);r.fillRect(c.x,c.y,d,u),r.fillStyle=s,this.text.forEach((p,h)=>{let f=l+c.x,m=l+c.y+(h+1)*i;r.fillText(p,f,m)})}},YB=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new fN({...s,...a})}},e4=class{constructor(e,t={}){this.box=new gl(e),this.options=new YB(t)}draw(e){let t=Gi(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new mN([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function UCe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof Ba?n.score:Xy(n)?n.detection.score:void 0,a=n instanceof Ba?n.box:Xy(n)?n.detection.box:new gl(n),s=r?`${uN(r)}`:void 0;new e4(a,{label:s}).draw(e)})}function t4(e){let{Image:t,Video:n}=gr.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function VCe(e){return new Promise((t,n)=>{if(e instanceof gr.getEnv().Canvas||t4(e)){t(null);return}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),n(s))}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),t(s))}e.addEventListener("load",a),e.addEventListener("error",r)})}function n4(e){let{Image:t,Video:n}=gr.getEnv();return e instanceof t?new $d(e.naturalWidth,e.naturalHeight):e instanceof n?new $d(e.videoWidth,e.videoHeight):new $d(e.width,e.height)}function Qy({width:e,height:t}){let{createCanvasElement:n}=gr.getEnv(),r=n();return r.width=e,r.height=t,r}function r4(e,t){let{ImageData:n}=gr.getEnv();if(!(e instanceof n)&&!t4(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=n4(e),s=Qy({width:r,height:a});return e instanceof n?Gi(s).putImageData(e,0,0):Gi(s).drawImage(e,0,0,r,a),s}async function jCe(e,t){let n=t||gr.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(Fs(e)?1:0),i=j(()=>e.as3D(r,a,s).toInt());return await um.toPixels(i,n),i.dispose(),n}function y_(e){let{Image:t,Canvas:n,Video:r}=gr.getEnv();return e instanceof t||e instanceof n||e instanceof r}function HCe(e,t,n=!1){let{Image:r,Canvas:a}=gr.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return Qy({width:1,height:1});let s=n4(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,d=Qy({width:t,height:t}),u=e instanceof a?e:r4(e),c=Math.abs(o-l)/2,p=n&&o<l?c:0,h=n&&l<o?c:0;return u.width>0&&u.height>0&&Gi(d).drawImage(u,p,h,o,l),d}var Jy=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(Sm(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if(Fs(n)){let s=n.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let a=n instanceof gr.getEnv().Canvas?n:r4(n);this._canvases[r]=a,this._inputDimensions[r]=[a.height,a.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return nc(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return zB({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,j(()=>{let n=nc(this.batchSize,0,1).map(r=>{let a=this.getInput(r);if(a instanceof Pe){let s=Fs(a)?a:yn(a);return s=OCe(s,t),(s.shape[1]!==e||s.shape[2]!==e)&&(s=qr.resizeBilinear(s,[e,e],!1,!1)),s.as3D(e,e,3)}if(a instanceof gr.getEnv().Canvas)return um.fromPixels(HCe(a,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${a}`)});return en(n.map(r=>ue(r,"float32"))).as4D(this.batchSize,e,e,3)})}};async function Yn(e){if(e instanceof Jy)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=a=>Array.isArray(e)?` at input index ${a}:`:"",r=t.map(hN);return r.forEach((a,s)=>{if(!y_(a)&&!Sm(a)&&!Fs(a))throw typeof t[s]=="string"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(Fs(a)){let i=a.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(r.map(a=>y_(a)&&VCe(a))),new Jy(r,Array.isArray(e))}async function gN(e,t){let{Canvas:n}=gr.getEnv(),r=e;if(!(e instanceof n)){let s=await Yn(e);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=s.getInput(0);r=i instanceof n?i:await jCe(i)}let a=Gi(r);return t.map(s=>s instanceof Ba?s.forSize(r.width,r.height).box.floor():s).map(s=>s.clipAtImageBorders(r.width,r.height)).map(({x:s,y:i,width:o,height:l})=>{let d=Qy({width:o,height:l});return o>0&&l>0&&Gi(d).putImageData(a.getImageData(s,i,o,l),0,0),d})}async function yN(e,t){if(!Sm(e)&&!Fs(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(Fs(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return j(()=>{let[n,r,a]=e.shape.slice(Fs(e)?1:0);return t.map(s=>s instanceof Ba?s.forSize(r,n).box:s).map(s=>s.clipAtImageBorders(r,n)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:i,width:o,height:l})=>vp(e.as3D(n,r,a),[i,s,0],[l,o,a]))})}async function GCe(e,t){let{fetch:n}=gr.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function qCe(e){return(await GCe(e)).json()}function a4(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let a=e.split("/").filter(o=>o),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${s}`:`${i}/${s}`}}async function KCe(e,t){let{manifestUri:n,modelBaseUri:r}=a4(e,t),a=await qCe(n);return $n.loadWeights(a,r)}var ho=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof el)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof el))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=Xn(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await KCe(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=gr.getEnv(),{manifestUri:n,modelBaseUri:r}=a4(e,this.getDefaultModelName()),a=l=>Promise.all(l.map(d=>t(d).then(u=>typeof u=="string"?Buffer.from(u):u.buffer))),s=$n.weightsLoaderFactory(a),i=JSON.parse((await t(n)).toString()),o=await s(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((a,s)=>{if(!a.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${e}`);return{obj:a.nextObj,objProp:s,nextObj:a.nextObj[s]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof Pe))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function Qr(e,t,n){return j(()=>{let r=bp(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=te(r,t.bias),r})}function Yx(e,t,n=!1){return j(()=>{let r=ut(n?te(Jn(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Qr(e,t.conv0,[2,2])),a=Qr(r,t.conv1,[1,1]),s=ut(te(r,a)),i=Qr(s,t.conv2,[1,1]);return ut(te(r,te(a,i)))})}function xg(e,t,n=!1,r=!0){return j(()=>{let a=ut(n?te(Jn(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):Qr(e,t.conv0,r?[2,2]:[1,1])),s=Qr(a,t.conv1,[1,1]),i=ut(te(a,s)),o=Qr(i,t.conv2,[1,1]),l=ut(te(a,te(s,o))),d=Qr(l,t.conv3,[1,1]);return ut(te(a,te(s,te(o,d))))})}function Ch(e,t,n="same",r=!1){return j(()=>{let a=te(Jn(e,t.filters,[1,1],n),t.bias);return r?ut(a):a})}function fo(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function bN(e,t){return(n,r,a,s)=>{let i=zi(e(n*r*a*a),[a,a,n,r]),o=ot(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function s4(e,t){return(n,r,a)=>{let s=os(e(n*r),[n,r]),i=ot(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var i4=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function vN(e,t){return(n,r,a)=>{let s=zi(e(9*n),[3,3,n,1]),i=zi(e(n*r),[1,1,n,r]),o=ot(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new i4(s,i,o)}}function xN(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new i4(n,r,a)}}function Xu(e,t){return(n,r,a)=>{let s=e[n];if(!Fp(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function mo(e){let t=e;function n(a){let s=t.slice(0,a);return t=t.slice(a),s}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function o4(e,t){let n=bN(e,t),r=vN(e,t);function a(i,o,l,d=!1){let u=d?n(i,o,3,`${l}/conv0`):r(i,o,`${l}/conv0`),c=r(o,o,`${l}/conv1`),p=r(o,o,`${l}/conv2`);return{conv0:u,conv1:c,conv2:p}}function s(i,o,l,d=!1){let{conv0:u,conv1:c,conv2:p}=a(i,o,l,d),h=r(o,o,`${l}/conv3`);return{conv0:u,conv1:c,conv2:p,conv3:h}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:s}}function XCe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=mo(e),{extractDenseBlock4Params:a}=o4(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function l4(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function u4(e,t){let n=Xu(e,t),r=l4(n),a=xN(n);function s(o,l=!1){let d=l?r(`${o}/conv0`):a(`${o}/conv0`),u=a(`${o}/conv1`),c=a(`${o}/conv2`);return{conv0:d,conv1:u,conv2:c}}function i(o,l=!1){let d=l?r(`${o}/conv0`):a(`${o}/conv0`),u=a(`${o}/conv1`),c=a(`${o}/conv2`),p=a(`${o}/conv3`);return{conv0:d,conv1:u,conv2:c,conv3:p}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function QCe(e){let t=[],{extractDenseBlock4Params:n}=u4(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return fo(e,t),{params:r,paramMappings:t}}var d4=class extends ho{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return j(()=>{let n=ue(e.toBatchTensor(112,!0),"float32"),r=Im(n,[122.782,117.001,104.298]).div(255),a=xg(r,t.dense0,!0);return a=xg(a,t.dense1),a=xg(a,t.dense2),a=xg(a,t.dense3),a=Vs(a,[7,7],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await Yn(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return QCe(e)}extractParams(e){return XCe(e)}};function h1(e,t){return j(()=>te(We(e,t.weights),t.bias))}function JCe(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=mo(e),i=s4(a,r)(t,n,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}function ZCe(e){let t=[],n=Xu(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:r("fc")};return fo(e,t),{params:a,paramMappings:t}}function c4(e){let t={},n={};return Object.keys(e).forEach(r=>{let a=r.startsWith("fc")?n:t;a[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var p4=class extends ho{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return j(()=>{let n=e instanceof Jy?this.faceFeatureExtractor.forwardInput(e):e;return h1(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return JCe(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=c4(e);return this.faceFeatureExtractor.loadFromWeightMap(t),ZCe(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},b_=["neutral","happy","sad","angry","fearful","disgusted","surprised"],wN=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);b_.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return b_.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},YCe=class extends p4{constructor(e=new d4){super("FaceExpressionNet",e)}forwardInput(e){return j(()=>io(this.runNet(e)))}async forward(e){return this.forwardInput(await Yn(e))}async predictExpressions(e){let t=await Yn(e),n=await this.forwardInput(t),r=await Promise.all(Ut(n).map(async s=>{let i=s.dataSync();return s.dispose(),i}));n.dispose();let a=r.map(s=>new wN(s));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function eTe(e){return e.expressions instanceof wN}function h4(e,t){return{...e,expressions:t}}function tTe(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(a=>{let s=a instanceof wN?a:eTe(a)?a.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=s.asSortedArray().filter(l=>l.probability>n),o=Xy(a)?a.detection.box.bottomLeft:r||new ht(0,0);new mN(i.map(l=>`${l.expression} (${uN(l.probability)})`),o).draw(e)})}function f4(e){return Xy(e)&&e.landmarks instanceof Ky&&e.unshiftedLandmarks instanceof Ky&&e.alignedRect instanceof Ba}function nTe(e){let t=l=>l*180/Math.PI,n=(l,d)=>Math.sqrt((l.x-d.x)**2+(l.y-d.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},a=(l,d,u)=>{let c=Math.floor(l.x-d.x),p=Math.floor(d.x-u.x);return c-p},s=(l,d)=>{let u=Math.hypot(d.x-l.x,d.y-l.y),c=d.y-l.y,p=Math.asin(c/u),h=t(p),f=Math.floor(90-h),m=d.x-l.x<0?-1:1;return f*m},i=(l,d,u)=>{let c=n(l,u),p=new ht((l.x+u.x)/2,(l.y+u.y)/2),h=n(d,p),f=Math.atan(h/c),m=Math.floor(t(f)),g=p.y-d.y<0?-1:1;return m*g};if(!e||!e.positions||e.positions.length!==68)return r;let o=e.positions;return r.roll=s(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=a(o[14],o[33],o[2]),r}function m4(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new Ba(e.detection.score,a.rescale(s.reverse()),s),o=nTe(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var g4=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},y4=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new g4(t)}draw(e){let t=Gi(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof HB&&(t.strokeStyle=s,t.lineWidth=a,ri(t,this.faceLandmarks.getJawOutline()),ri(t,this.faceLandmarks.getLeftEyeBrow()),ri(t,this.faceLandmarks.getRightEyeBrow()),ri(t,this.faceLandmarks.getNose()),ri(t,this.faceLandmarks.getLeftEye(),!0),ri(t,this.faceLandmarks.getRightEye(),!0),ri(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let l=d=>{t.beginPath(),t.arc(d.x,d.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function rTe(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof Ky?n:f4(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new y4(r).draw(e)})}function aTe(e,t){let n=bN(e,t),r=vN(e,t);function a(i,o,l){let d=r(i,o,`${l}/separable_conv0`),u=r(o,o,`${l}/separable_conv1`),c=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:d,separable_conv1:u,expansion_conv:c}}function s(i,o){let l=r(i,i,`${o}/separable_conv0`),d=r(i,i,`${o}/separable_conv1`),u=r(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:d,separable_conv2:u}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:a,extractMainBlockParams:s}}function sTe(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=mo(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=aTe(r,n),d=s(3,32,3,"entry_flow/conv_in"),u=o(32,64,"entry_flow/reduction_block_0"),c=o(64,128,"entry_flow/reduction_block_1"),p={conv_in:d,reduction_block_0:u,reduction_block_1:c},h={};nc(t,0,1).forEach(y=>{h[`main_block_${y}`]=l(128,`middle_flow/main_block_${y}`)});let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:p,middle_flow:h,exit_flow:g}}}function iTe(e,t){let n=Xu(e,t),r=l4(n),a=xN(n);function s(o){let l=a(`${o}/separable_conv0`),d=a(`${o}/separable_conv1`),u=r(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:d,expansion_conv:u}}function i(o){let l=a(`${o}/separable_conv0`),d=a(`${o}/separable_conv1`),u=a(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:d,separable_conv2:u}}return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}}function oTe(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=iTe(e,n),o=r("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),d=s("entry_flow/reduction_block_1"),u={conv_in:o,reduction_block_0:l,reduction_block_1:d},c={};nc(t,0,1).forEach(m=>{c[`main_block_${m}`]=i(`middle_flow/main_block_${m}`)});let p=s("exit_flow/reduction_block"),h=a("exit_flow/separable_conv"),f={reduction_block:p,separable_conv:h};return fo(e,n),{params:{entry_flow:u,middle_flow:c,exit_flow:f},paramMappings:n}}function b4(e,t,n){return te(Jn(e,t.filters,n,"same"),t.bias)}function e0(e,t,n=!0){let r=n?ut(e):e;return r=Qr(r,t.separable_conv0,[1,1]),r=Qr(ut(r),t.separable_conv1,[1,1]),r=hn(r,[3,3],[2,2],"same"),r=te(r,b4(e,t.expansion_conv,[2,2])),r}function lTe(e,t){let n=Qr(ut(e),t.separable_conv0,[1,1]);return n=Qr(ut(n),t.separable_conv1,[1,1]),n=Qr(ut(n),t.separable_conv2,[1,1]),n=te(n,e),n}var uTe=class extends ho{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return j(()=>{let n=ue(e.toBatchTensor(112,!0),"float32"),r=Im(n,[122.782,117.001,104.298]).div(255),a=ut(b4(r,t.entry_flow.conv_in,[2,2]));return a=e0(a,t.entry_flow.reduction_block_0,!1),a=e0(a,t.entry_flow.reduction_block_1),nc(this._numMainBlocks,0,1).forEach(s=>{a=lTe(a,t.middle_flow[`main_block_${s}`])}),a=e0(a,t.exit_flow.reduction_block),a=ut(Qr(a,t.exit_flow.separable_conv,[1,1])),a})}async forward(e){return this.forwardInput(await Yn(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return oTe(e,this._numMainBlocks)}extractParams(e){return sTe(e,this._numMainBlocks)}};function dTe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=mo(e),a=s4(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function cTe(e){let t=[],n=Xu(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return fo(e,t),{params:a,paramMappings:t}}var pTe=(e=>(e.FEMALE="female",e.MALE="male",e))(pTe||{}),hTe=class extends ho{constructor(e=new uTe(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return j(()=>{let n=e instanceof Jy?this.faceFeatureExtractor.forwardInput(e):e,r=Vs(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),a=h1(r,t.fc.age).as1D(),s=h1(r,t.fc.gender);return{age:a,gender:s}})}forwardInput(e){return j(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:io(n)}})}async forward(e){return this.forwardInput(await Yn(e))}async predictAgeAndGender(e){let t=await Yn(e),n=await this.forwardInput(t),r=Ut(n.age),a=Ut(n.gender),s=r.map((o,l)=>({ageTensor:o,genderTensor:a[l]})),i=await Promise.all(s.map(async({ageTensor:o,genderTensor:l})=>{let d=o.dataSync()[0],u=l.dataSync()[0],c=u>.5,p=c?"male":"female",h=c?u:1-u;return o.dispose(),l.dispose(),{age:d,gender:p,genderProbability:h}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return dTe(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=c4(e);return this.faceFeatureExtractor.loadFromWeightMap(t),cTe(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},v4=class extends p4{postProcess(e,t,n){let r=n.map(({width:s,height:i})=>{let o=t/Math.max(i,s);return{width:s*o,height:i*o}}),a=r.length;return j(()=>{let s=(d,u)=>en([Dr([68],d,"float32"),Dr([68],u,"float32")],1).as2D(1,136).as1D(),i=(d,u)=>{let{width:c,height:p}=r[d];return u(c,p)?Math.abs(c-p)/2:0},o=d=>i(d,(u,c)=>u<c),l=d=>i(d,(u,c)=>c<u);return e.mul(Dr([a,136],t,"float32")).sub(en(Array.from(Array(a),(d,u)=>s(o(u),l(u))))).div(en(Array.from(Array(a),(d,u)=>s(r[u].width,r[u].height))))})}forwardInput(e){return j(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(e){return this.forwardInput(await Yn(e))}async detectLandmarks(e){let t=await Yn(e),n=j(()=>Ut(this.forwardInput(t))),r=await Promise.all(n.map(async(a,s)=>{let i=Array.from(a.dataSync()),o=i.filter((d,u)=>d1(u)),l=i.filter((d,u)=>!d1(u));return new HB(Array(68).fill(0).map((d,u)=>new ht(o[u],l[u])),{height:t.getInputHeight(s),width:t.getInputWidth(s)})}));return n.forEach(a=>a.dispose()),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},fTe=class extends v4{constructor(e=new d4){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function mTe(e){let t=[],{extractDenseBlock3Params:n}=u4(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return fo(e,t),{params:r,paramMappings:t}}function gTe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=mo(e),{extractDenseBlock3Params:a}=o4(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var yTe=class extends ho{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return j(()=>{let n=ue(e.toBatchTensor(112,!0),"float32"),r=Im(n,[122.782,117.001,104.298]).div(255),a=Yx(r,t.dense0,!0);return a=Yx(a,t.dense1),a=Yx(a,t.dense2),a=Vs(a,[14,14],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await Yn(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return mTe(e)}extractParams(e){return gTe(e)}},bTe=class extends v4{constructor(e=new yTe){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function vTe(e,t){return te(W(e,t.weights),t.biases)}function kN(e,t,n,r,a="same"){let{filters:s,bias:i}=t.conv,o=Jn(e,s,n,a);return o=te(o,i),o=vTe(o,t.scale),r?ut(o):o}function xTe(e,t){return kN(e,t,[1,1],!0)}function x4(e,t){return kN(e,t,[1,1],!1)}function w4(e,t){return kN(e,t,[2,2],!0,"valid")}function wTe(e,t){function n(o,l,d){let u=e(o),c=u.length/(l*d*d);if(LB(c))throw new Error(`depth has to be an integer: ${c}, weights.length: ${u.length}, numFilters: ${l}, filterSize: ${d}`);return j(()=>Ue(zi(u,[l,c,d,d]),[2,3,1,0]))}function r(o,l,d,u){let c=n(o,l,d),p=ot(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/bias`}),{filters:c,bias:p}}function a(o,l){let d=ot(e(o)),u=ot(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:d,biases:u}}function s(o,l,d,u){let c=r(o,l,d,`${u}/conv`),p=a(l,`${u}/scale`);return{conv:c,scale:p}}function i(o,l,d,u,c=!1){let p=s((c?.5:1)*o,l,d,`${u}/conv1`),h=s(o,l,d,`${u}/conv2`);return{conv1:p,conv2:h}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function kTe(e){let{extractWeights:t,getRemainingWeights:n}=mo(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=wTe(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),d=s(9216,32,3,"conv32_3"),u=s(36864,64,3,"conv64_down",!0),c=s(36864,64,3,"conv64_1"),p=s(36864,64,3,"conv64_2"),h=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),v=s(589824,256,3,"conv256_2"),x=s(589824,256,3,"conv256_down_out"),w=j(()=>Ue(os(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:d,conv64_down:u,conv64_1:c,conv64_2:p,conv64_3:h,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:v,conv256_down_out:x,fc:w},paramMappings:r}}function STe(e,t){let n=Xu(e,t);function r(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function a(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),d=r(i);return{conv:{filters:o,bias:l},scale:d}}function s(i){return{conv1:a(`${i}/conv1`),conv2:a(`${i}/conv2`)}}return{extractConvLayerParams:a,extractResidualLayerParams:s}}function ITe(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=STe(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),d=r("conv64_1"),u=r("conv64_2"),c=r("conv64_3"),p=r("conv128_down"),h=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:v}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!PB(v))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${v}`);let x={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:d,conv64_2:u,conv64_3:c,conv128_down:p,conv128_1:h,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:v};return fo(e,t),{params:x,paramMappings:t}}function qa(e,t){let n=xTe(e,t.conv1);return n=x4(n,t.conv2),n=te(n,e),n=ut(n),n}function wg(e,t){let n=w4(e,t.conv1);n=x4(n,t.conv2);let r=Vs(e,2,2,"valid"),a=Dt(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=Dt(i);n=gt([n,o],1);let l=[...n.shape];l[2]=1;let d=Dt(l);n=gt([n,d],2)}return r=s?gt([r,a],3):r,n=te(r,n),n=ut(n),n}var NTe=class extends ho{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return j(()=>{let n=ue(e.toBatchTensor(150,!0),"float32"),r=Im(n,[122.782,117.001,104.298]).div(255),a=w4(r,t.conv32_down);a=hn(a,3,2,"valid"),a=qa(a,t.conv32_1),a=qa(a,t.conv32_2),a=qa(a,t.conv32_3),a=wg(a,t.conv64_down),a=qa(a,t.conv64_1),a=qa(a,t.conv64_2),a=qa(a,t.conv64_3),a=wg(a,t.conv128_down),a=qa(a,t.conv128_1),a=qa(a,t.conv128_2),a=wg(a,t.conv256_down),a=qa(a,t.conv256_1),a=qa(a,t.conv256_2),a=wg(a,t.conv256_down_out);let s=a.mean([1,2]);return We(s,t.fc)})}async forward(e){return this.forwardInput(await Yn(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(s=>s<=0))return new Float32Array(128);let n=await Yn(e),r=j(()=>Ut(this.forwardInput(n))),a=await Promise.all(r.map(s=>s.data()));return r.forEach(s=>s.dispose()),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return ITe(e)}extractParams(e){return kTe(e)}};function k4(e,t){return{...e,descriptor:t}}function S4(e,t){return{...e,age:t}}function I4(e,t,n){return{...e,gender:t,genderProbability:n}}function CTe(e,t){function n(l,d){let u=zi(e(9*l),[3,3,l,1]),c=ot(e(l)),p=ot(e(l)),h=ot(e(l)),f=ot(e(l));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/batch_norm_scale`},{paramPath:`${d}/batch_norm_offset`},{paramPath:`${d}/batch_norm_mean`},{paramPath:`${d}/batch_norm_variance`}),{filters:u,batch_norm_scale:c,batch_norm_offset:p,batch_norm_mean:h,batch_norm_variance:f}}function r(l,d,u,c,p){let h=zi(e(l*d*u*u),[u,u,l,d]),f=ot(e(d));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/${p?"batch_norm_offset":"bias"}`}),{filters:h,bias:f}}function a(l,d,u,c){let{filters:p,bias:h}=r(l,d,u,c,!0);return{filters:p,batch_norm_offset:h}}function s(l,d,u){let c=n(l,`${u}/depthwise_conv`),p=a(l,d,1,`${u}/pointwise_conv`);return{depthwise_conv:c,pointwise_conv:p}}function i(){let l=a(3,32,3,"mobilenetv1/conv_0"),d=s(32,64,"mobilenetv1/conv_1"),u=s(64,128,"mobilenetv1/conv_2"),c=s(128,128,"mobilenetv1/conv_3"),p=s(128,256,"mobilenetv1/conv_4"),h=s(256,256,"mobilenetv1/conv_5"),f=s(256,512,"mobilenetv1/conv_6"),m=s(512,512,"mobilenetv1/conv_7"),g=s(512,512,"mobilenetv1/conv_8"),y=s(512,512,"mobilenetv1/conv_9"),b=s(512,512,"mobilenetv1/conv_10"),v=s(512,512,"mobilenetv1/conv_11"),x=s(512,1024,"mobilenetv1/conv_12"),w=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:d,conv_2:u,conv_3:c,conv_4:p,conv_5:h,conv_6:f,conv_7:m,conv_8:g,conv_9:y,conv_10:b,conv_11:v,conv_12:x,conv_13:w}}function o(){let l=a(1024,256,1,"prediction_layer/conv_0"),d=a(256,512,3,"prediction_layer/conv_1"),u=a(512,128,1,"prediction_layer/conv_2"),c=a(128,256,3,"prediction_layer/conv_3"),p=a(256,128,1,"prediction_layer/conv_4"),h=a(128,256,3,"prediction_layer/conv_5"),f=a(256,64,1,"prediction_layer/conv_6"),m=a(64,128,3,"prediction_layer/conv_7"),g=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),y=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),b=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),v=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),x=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),w=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),I=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),N=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),T=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),A=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),R=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),F=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:d,conv_2:u,conv_3:c,conv_4:p,conv_5:h,conv_6:f,conv_7:m,box_predictor_0:{box_encoding_predictor:g,class_predictor:y},box_predictor_1:{box_encoding_predictor:b,class_predictor:v},box_predictor_2:{box_encoding_predictor:x,class_predictor:w},box_predictor_3:{box_encoding_predictor:I,class_predictor:N},box_predictor_4:{box_encoding_predictor:T,class_predictor:A},box_predictor_5:{box_encoding_predictor:R,class_predictor:F}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function TTe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=mo(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=CTe(n,t),i=a(),o=s(),l={extra_dim:dv(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function ETe(e,t){let n=Xu(e,t);function r(d,u,c){let p=n(`${d}/Conv2d_${u}_pointwise/weights`,4,`${c}/filters`),h=n(`${d}/Conv2d_${u}_pointwise/convolution_bn_offset`,1,`${c}/batch_norm_offset`);return{filters:p,batch_norm_offset:h}}function a(d){let u=`mobilenetv1/conv_${d}`,c=`MobilenetV1/Conv2d_${d}_depthwise`,p=`${u}/depthwise_conv`,h=`${u}/pointwise_conv`,f=n(`${c}/depthwise_weights`,4,`${p}/filters`),m=n(`${c}/BatchNorm/gamma`,1,`${p}/batch_norm_scale`),g=n(`${c}/BatchNorm/beta`,1,`${p}/batch_norm_offset`),y=n(`${c}/BatchNorm/moving_mean`,1,`${p}/batch_norm_mean`),b=n(`${c}/BatchNorm/moving_variance`,1,`${p}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:m,batch_norm_offset:g,batch_norm_mean:y,batch_norm_variance:b},pointwise_conv:r("MobilenetV1",d,h)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}}function i(d,u){let c=n(`${d}/weights`,4,`${u}/filters`),p=n(`${d}/biases`,1,`${u}/bias`);return{filters:c,bias:p}}function o(d){let u=i(`Prediction/BoxPredictor_${d}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${d}/box_encoding_predictor`),c=i(`Prediction/BoxPredictor_${d}/ClassPredictor`,`prediction_layer/box_predictor_${d}/class_predictor`);return{box_encoding_predictor:u,class_predictor:c}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function _Te(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=ETe(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Sm(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return fo(e,t),{params:s,paramMappings:t}}function Ja(e,t,n){return j(()=>{let r=Jn(e,t.filters,n,"same");return r=te(r,t.batch_norm_offset),On(r,0,6)})}var $Te=.0010000000474974513;function ATe(e,t,n){return j(()=>{let r=zu(e,t.filters,n,"same");return r=Lu(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,$Te),On(r,0,6)})}function RTe(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function FTe(e,t){return j(()=>{let n,r=Ja(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((a,s)=>{let i=s+1,o=RTe(i);r=ATe(r,a.depthwise_conv,o),r=Ja(r,a.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function DTe(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),d=Math.min(r[n][1],r[n][3]),u=Math.max(r[n][0],r[n][2]),c=Math.max(r[n][1],r[n][3]),p=(i-a)*(o-s),h=(u-l)*(c-d);if(p<=0||h<=0)return 0;let f=Math.max(a,l),m=Math.max(s,d),g=Math.min(i,u),y=Math.min(o,c),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(p+h-b)}function MTe(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map((u,c)=>({score:u,boxIndex:c})).filter(u=>u.score>a).sort((u,c)=>c.score-u.score),l=u=>u<=r?1:0,d=[];return o.forEach(u=>{if(d.length>=i)return;let c=u.score;for(let p=d.length-1;p>=0;--p){let h=DTe(e,u.boxIndex,d[p]);if(h!==0&&(u.score*=l(h),u.score<=a))break}c===u.score&&d.push(u.boxIndex)}),d}function OTe(e){let t=Ut(Ue(e,[1,0])),n=[me(t[2],t[0]),me(t[3],t[1])],r=[te(t[0],be(n[0],2)),te(t[1],be(n[1],2))];return{sizes:n,centers:r}}function PTe(e,t){let{sizes:n,centers:r}=OTe(e),a=Ut(Ue(t,[1,0])),s=be(W(Pn(be(a[2],5)),n[0]),2),i=te(W(be(a[0],10),n[0]),r[0]),o=be(W(Pn(be(a[3],5)),n[1]),2),l=te(W(be(a[1],10),n[1]),r[1]);return Ue(en([me(i,s),me(l,o),te(i,s),te(l,o)]),[1,0])}function LTe(e,t,n){return j(()=>{let r=e.shape[0],a=PTe(V(Er(n.extra_dim,[r,1,1]),[-1,4]),V(e,[-1,4]));a=V(a,[r,a.shape[0]/r,4]);let s=ma(Xe(t,[0,0,1],[-1,-1,-1])),i=Xe(s,[0,0,0],[-1,-1,1]);i=V(i,[r,i.shape[1]]);let o=Ut(a),l=Ut(i);return{boxes:o,scores:l}})}function nd(e,t){return j(()=>{let n=e.shape[0],r=V(Ch(e,t.box_encoding_predictor),[n,-1,1,4]),a=V(Ch(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:a}})}function zTe(e,t,n){return j(()=>{let r=Ja(e,n.conv_0,[1,1]),a=Ja(r,n.conv_1,[2,2]),s=Ja(a,n.conv_2,[1,1]),i=Ja(s,n.conv_3,[2,2]),o=Ja(i,n.conv_4,[1,1]),l=Ja(o,n.conv_5,[2,2]),d=Ja(l,n.conv_6,[1,1]),u=Ja(d,n.conv_7,[2,2]),c=nd(t,n.box_predictor_0),p=nd(e,n.box_predictor_1),h=nd(a,n.box_predictor_2),f=nd(i,n.box_predictor_3),m=nd(l,n.box_predictor_4),g=nd(u,n.box_predictor_5),y=gt([c.boxPredictionEncoding,p.boxPredictionEncoding,h.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),b=gt([c.classPrediction,p.classPrediction,h.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:b}})}var Dp=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},BTe=class extends ho{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return j(()=>{let n=ue(e.toBatchTensor(512,!1),"float32"),r=me(be(n,127.5),1),a=FTe(r,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=zTe(a.out,a.conv11,t.prediction_layer);return LTe(s,i,t.output_layer)})}async forward(e){return this.forwardInput(await Yn(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new Dp(t),a=await Yn(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let d=Array.from(l.dataSync()),u=MTe(o,d,n,.5,r),c=a.getReshapedInputDimensions(0),p=a.inputSize,h=p/c.width,f=p/c.height,m=o.arraySync(),g=u.map(y=>{let[b,v]=[Math.max(0,m[y][0]),Math.min(1,m[y][2])].map(I=>I*f),[x,w]=[Math.max(0,m[y][1]),Math.min(1,m[y][3])].map(I=>I*h);return new Ba(d[y],new jB(x,b,w-x,v-b),{height:a.getInputHeight(0),width:a.getInputWidth(0)})});return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return _Te(e)}extractParams(e){return TTe(e)}},WTe=.4,UTe=[new ht(.738768,.874946),new ht(2.42204,2.65704),new ht(4.30971,7.04493),new ht(10.246,4.59428),new ht(12.6868,11.8741)],VTe=[new ht(1.603231,2.094468),new ht(6.041143,7.080126),new ht(2.882459,3.518061),new ht(4.266906,5.178857),new ht(9.041765,10.66308)],jTe=[117.001,114.697,97.404],HTe="tiny_yolov2_model",GTe="tiny_yolov2_separable_conv_model",kg=e=>typeof e=="number";function qTe(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!kg(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>kg(t.x)&&kg(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(kg)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function SN(e){return j(()=>{let t=W(e,Ce(.10000000149011612));return te(ut(me(e,t)),t)})}function Ys(e,t){return j(()=>{let n=Ua(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Jn(n,t.conv.filters,[1,1],"valid"),n=me(n,t.bn.sub),n=W(n,t.bn.truediv),n=te(n,t.conv.bias),SN(n)})}function ei(e,t){return j(()=>{let n=Ua(e,[[0,0],[1,1],[1,1],[0,0]]);return n=bp(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=te(n,t.bias),SN(n)})}function KTe(e,t){let n=bN(e,t);function r(i,o){let l=ot(e(i)),d=ot(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:d}}function a(i,o,l){let d=n(i,o,3,`${l}/conv`),u=r(o,`${l}/bn`);return{conv:d,bn:u}}let s=vN(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}}function XTe(e,t,n,r){let{extractWeights:a,getRemainingWeights:s}=mo(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:d}=KTe(a,i),u;if(t.withSeparableConvs){let[c,p,h,f,m,g,y,b,v]=r,x=t.isFirstLayerConv2d?o(c,p,3,"conv0"):d(c,p,"conv0"),w=d(p,h,"conv1"),I=d(h,f,"conv2"),N=d(f,m,"conv3"),T=d(m,g,"conv4"),A=d(g,y,"conv5"),R=b?d(y,b,"conv6"):void 0,F=v?d(b,v,"conv7"):void 0,C=o(v||b||y,5*n,1,"conv8");u={conv0:x,conv1:w,conv2:I,conv3:N,conv4:T,conv5:A,conv6:R,conv7:F,conv8:C}}else{let[c,p,h,f,m,g,y,b,v]=r,x=l(c,p,"conv0"),w=l(p,h,"conv1"),I=l(h,f,"conv2"),N=l(f,m,"conv3"),T=l(m,g,"conv4"),A=l(g,y,"conv5"),R=l(y,b,"conv6"),F=l(b,v,"conv7"),C=o(v,5*n,1,"conv8");u={conv0:x,conv1:w,conv2:I,conv3:N,conv4:T,conv5:A,conv6:R,conv7:F,conv8:C}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:u,paramMappings:i}}function QTe(e,t){let n=Xu(e,t);function r(o){let l=n(`${o}/sub`,1),d=n(`${o}/truediv`,1);return{sub:l,truediv:d}}function a(o){let l=n(`${o}/filters`,4),d=n(`${o}/bias`,1);return{filters:l,bias:d}}function s(o){let l=a(`${o}/conv`),d=r(`${o}/bn`);return{conv:l,bn:d}}let i=xN(n);return{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function JTe(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}=QTe(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?r("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:r("conv8")}}else i={conv0:a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:a("conv6"),conv7:a("conv7"),conv8:r("conv8")};return fo(e,n),{params:i,paramMappings:n}}var IN=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},N4=class C4 extends ho{constructor(t){super("TinyYolov2"),qTe(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let r=Ys(t,n.conv0);return r=hn(r,[2,2],[2,2],"same"),r=Ys(r,n.conv1),r=hn(r,[2,2],[2,2],"same"),r=Ys(r,n.conv2),r=hn(r,[2,2],[2,2],"same"),r=Ys(r,n.conv3),r=hn(r,[2,2],[2,2],"same"),r=Ys(r,n.conv4),r=hn(r,[2,2],[2,2],"same"),r=Ys(r,n.conv5),r=hn(r,[2,2],[1,1],"same"),r=Ys(r,n.conv6),r=Ys(r,n.conv7),Ch(r,n.conv8,"valid",!1)}runMobilenet(t,n){let r=this.config.isFirstLayerConv2d?SN(Ch(t,n.conv0,"valid",!1)):ei(t,n.conv0);return r=hn(r,[2,2],[2,2],"same"),r=ei(r,n.conv1),r=hn(r,[2,2],[2,2],"same"),r=ei(r,n.conv2),r=hn(r,[2,2],[2,2],"same"),r=ei(r,n.conv3),r=hn(r,[2,2],[2,2],"same"),r=ei(r,n.conv4),r=hn(r,[2,2],[2,2],"same"),r=ei(r,n.conv5),r=hn(r,[2,2],[1,1],"same"),r=n.conv6?ei(r,n.conv6):r,r=n.conv7?ei(r,n.conv7):r,Ch(r,n.conv8,"valid",!1)}forwardInput(t,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return j(()=>{let a=ue(t.toBatchTensor(n,!1),"float32");return a=this.config.meanRgb?Im(a,this.config.meanRgb):a,a=a.div(255),this.config.withSeparableConvs?this.runMobilenet(a,r):this.runTinyYolov2(a,r)})}async forward(t,n){return this.forwardInput(await Yn(t),n)}async detect(t,n={}){let{inputSize:r,scoreThreshold:a}=new IN(n),s=await Yn(t),i=await this.forwardInput(s,r),o=j(()=>Ut(i)[0].expandDims()),l={width:s.getInputWidth(0),height:s.getInputHeight(0)},d=await this.extractBoxes(o,s.getReshapedInputDimensions(0),a);i.dispose(),o.dispose();let u=d.map(f=>f.box),c=d.map(f=>f.score),p=d.map(f=>f.classScore),h=d.map(f=>this.config.classes[f.label]);return MCe(u.map(f=>f.rescale(r)),c,this.config.iouThreshold,!0).map(f=>new WB(c[f],p[f],h[f],u[f],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return JTe(t,this.config)}extractParams(t){let n=this.config.filterSizes||C4.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return XTe(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,r){let{width:a,height:s}=n,i=Math.max(a,s),o=i/a,l=i/s,d=t.shape[1],u=this.config.anchors.length,[c,p,h]=j(()=>{let y=t.reshape([d,d,u,this.boxEncodingSize]),b=y.slice([0,0,0,0],[d,d,u,4]),v=y.slice([0,0,0,4],[d,d,u,1]),x=this.withClassScores?io(y.slice([0,0,0,5],[d,d,u,this.config.classes.length]),3):Ce(0);return[b,v,x]}),f=[],m=await p.array(),g=await c.array();for(let y=0;y<d;y++)for(let b=0;b<d;b++)for(let v=0;v<u;v++){let x=Zx(m[y][b][v][0]);if(!r||x>r){let w=(b+Zx(g[y][b][v][0]))/d*o,I=(y+Zx(g[y][b][v][1]))/d*l,N=Math.exp(g[y][b][v][2])*this.config.anchors[v].x/d*o,T=Math.exp(g[y][b][v][3])*this.config.anchors[v].y/d*l,A=w-N/2,R=I-T/2,F={row:y,col:b,anchor:v},{classScore:C,label:M}=this.withClassScores?await this.extractPredictedClass(h,F):{classScore:1,label:0};f.push({box:new BB(A,R,A+N,R+T),score:x,classScore:x*C,label:M,...F})}}return c.dispose(),p.dispose(),h.dispose(),f}async extractPredictedClass(t,n){let{row:r,col:a,anchor:s}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[r][a][s][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};N4.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var T4=N4,ZTe=class extends T4{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:WTe,classes:["face"],...e?{anchors:VTe,meanRgb:jTe}:{anchors:UTe,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new Ba(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?GTe:HTe}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},YTe=class extends IN{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Nm=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Qv(e,t,n,r,a=({alignedRect:s})=>s){let s=e.map(l=>f4(l)?a(l):l.detection),i=r||(t instanceof Pe?await yN(t,s):await gN(t,s)),o=await n(i);return i.forEach(l=>l instanceof Pe&&l.dispose()),o}async function NN(e,t,n,r,a){return Qv([e],t,async s=>n(s[0]),r,a)}var eEe=.4,tEe=[new ht(1.603231,2.094468),new ht(6.041143,7.080126),new ht(2.882459,3.518061),new ht(4.266906,5.178857),new ht(9.041765,10.66308)],nEe=[117.001,114.697,97.404],rEe=class extends T4{constructor(){let e={withSeparableConvs:!0,iouThreshold:eEe,classes:["face"],anchors:tEe,meanRgb:nEe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new Ba(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Mr={ssdMobilenetv1:new BTe,tinyFaceDetector:new rEe,tinyYolov2:new ZTe,faceLandmark68Net:new fTe,faceLandmark68TinyNet:new bTe,faceRecognitionNet:new NTe,faceExpressionNet:new YCe,ageGenderNet:new hTe},E4=class extends Nm{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},CN=class extends E4{async run(){let e=await this.parentTask,t=await Qv(e,this.input,async n=>Promise.all(n.map(r=>Mr.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return e.map((n,r)=>h4(n,t[r]))}withAgeAndGender(){return new $N(this,this.input)}},TN=class extends E4{async run(){let e=await this.parentTask;if(!e)return;let t=await NN(e,this.input,n=>Mr.faceExpressionNet.predictExpressions(n),this.extractedFaces);return h4(e,t)}withAgeAndGender(){return new AN(this,this.input)}},EN=class extends CN{withAgeAndGender(){return new RN(this,this.input)}withFaceDescriptors(){return new DN(this,this.input)}},_N=class extends TN{withAgeAndGender(){return new FN(this,this.input)}withFaceDescriptor(){return new MN(this,this.input)}},_4=class extends Nm{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},$N=class extends _4{async run(){let e=await this.parentTask,t=await Qv(e,this.input,async n=>Promise.all(n.map(r=>Mr.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return e.map((n,r)=>{let{age:a,gender:s,genderProbability:i}=t[r];return S4(I4(n,s,i),a)})}withFaceExpressions(){return new CN(this,this.input)}},AN=class extends _4{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await NN(e,this.input,a=>Mr.ageGenderNet.predictAgeAndGender(a),this.extractedFaces);return S4(I4(e,n,r),t)}withFaceExpressions(){return new TN(this,this.input)}},RN=class extends $N{withFaceExpressions(){return new EN(this,this.input)}withFaceDescriptors(){return new DN(this,this.input)}},FN=class extends AN{withFaceExpressions(){return new _N(this,this.input)}withFaceDescriptor(){return new MN(this,this.input)}},$4=class extends Nm{constructor(e,t){super(),this.parentTask=e,this.input=t}},DN=class extends $4{async run(){let e=await this.parentTask;return(await Qv(e,this.input,t=>Promise.all(t.map(n=>Mr.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>k4(e[n],t))}withFaceExpressions(){return new EN(this,this.input)}withAgeAndGender(){return new RN(this,this.input)}},MN=class extends $4{async run(){let e=await this.parentTask;if(!e)return;let t=await NN(e,this.input,n=>Mr.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return k4(e,t)}withFaceExpressions(){return new _N(this,this.input)}withAgeAndGender(){return new FN(this,this.input)}},A4=class extends Nm{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Mr.faceLandmark68TinyNet:Mr.faceLandmark68Net}},aEe=class extends A4{async run(){let e=await this.parentTask,t=e.map(a=>a.detection),n=this.input instanceof Pe?await yN(this.input,t):await gN(this.input,t),r=await Promise.all(n.map(a=>this.landmarkNet.detectLandmarks(a)));return n.forEach(a=>a instanceof Pe&&a.dispose()),e.filter((a,s)=>r[s]).map((a,s)=>m4(a,r[s]))}withFaceExpressions(){return new EN(this,this.input)}withAgeAndGender(){return new RN(this,this.input)}withFaceDescriptors(){return new DN(this,this.input)}},sEe=class extends A4{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof Pe?await yN(this.input,[t]):await gN(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(a=>a instanceof Pe&&a.dispose()),m4(e,r)}withFaceExpressions(){return new _N(this,this.input)}withAgeAndGender(){return new FN(this,this.input)}withFaceDescriptor(){return new MN(this,this.input)}},R4=class extends Nm{constructor(e,t=new Dp){super(),this.input=e,this.options=t}},iEe=class extends R4{async run(){let{input:e,options:t}=this,n;if(t instanceof YTe)n=Mr.tinyFaceDetector.locateFaces(e,t);else if(t instanceof Dp)n=Mr.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof IN)n=Mr.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>GB({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new aEe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new CN(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new $N(this.runAndExtendWithFaceDetections(),this.input)}},oEe=class extends R4{async run(){let e=await new iEe(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?GB({},t):void 0)})}withFaceLandmarks(e=!1){return new sEe(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new TN(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new AN(this.runAndExtendWithFaceDetection(),this.input)}};function F4(e,t=new Dp){return new oEe(e,t)}const t0="/models";let v_=!1;async function Jv(){if(!v_)try{await Promise.all([Mr.ssdMobilenetv1.loadFromUri(t0),Mr.faceLandmark68Net.loadFromUri(t0),Mr.faceRecognitionNet.loadFromUri(t0)]),v_=!0,console.log("[face-api] Модели загружены успешно")}catch(e){throw console.error("[face-api] Ошибка загрузки моделей:",e),new Error("Не удалось загрузить модели распознавания лиц")}}async function D4(e){await Jv();const t=await lEe(e);try{const n=await F4(t,new Dp({minConfidence:.5})).withFaceLandmarks().withFaceDescriptor();if(!n||!n.descriptor)throw new Error("Лицо не обнаружено на изображении");return Array.from(n.descriptor)}catch(n){throw console.error("[face-api] Ошибка вычисления дескриптора:",n),n}}async function M4(e){await Jv();const t=await uEe(e);try{const n=await F4(t,new Dp({minConfidence:.5})).withFaceLandmarks().withFaceDescriptor();if(!n||!n.descriptor)throw new Error("Лицо не обнаружено на изображении");return Array.from(n.descriptor)}catch(n){throw console.error("[face-api] Ошибка вычисления дескриптора:",n),n}}function lEe(e){return new Promise((t,n)=>{const r=new FileReader;r.onload=a=>{const s=new Image;s.onload=()=>t(s),s.onerror=()=>n(new Error("Не удалось загрузить изображение")),s.src=a.target.result},r.onerror=()=>n(new Error("Не удалось прочитать файл")),r.readAsDataURL(e)})}function uEe(e){return new Promise((t,n)=>{const r=new Image;r.onload=()=>t(r),r.onerror=()=>n(new Error("Не удалось загрузить изображение")),r.src=e})}const dEe=.9;function cEe({open:e,onSuccess:t,type:n="CHECK_IN"}){const r=Y.useRef(null),a=Y.useRef(null),[s,i]=Y.useState(""),[o,l]=Y.useState(!1),[d,u]=Y.useState(0),[c,p]=Y.useState(!1),[h,f]=Y.useState(!1),[m,g]=Y.useState(null),[y,b]=Y.useState(!1);Y.useEffect(()=>{if(!e)return;let I=!1;async function N(){try{if(console.log("[AttendanceModal] Starting initialization..."),i("Запуск камеры..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new Error("getUserMedia не поддерживается в этом браузере");console.log("[AttendanceModal] Requesting camera access...");const T=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user"}});if(console.log("[AttendanceModal] Camera access granted"),I){T.getTracks().forEach(A=>A.stop());return}a.current=T,r.current&&(r.current.srcObject=T),console.log("[AttendanceModal] Loading liveness module..."),i("Загрузка модуля проверки..."),await wb(),console.log("[AttendanceModal] Liveness module loaded"),I||(p(!0),i("Готово к отметке"))}catch(T){console.error("[AttendanceModal] Initialization error:",T),console.error("[AttendanceModal] Error name:",T.name),console.error("[AttendanceModal] Error message:",T.message);let A="Не удалось получить доступ к камере";T.name==="NotAllowedError"||T.name==="PermissionDeniedError"?A="Доступ к камере запрещен. Пожалуйста, разрешите доступ к камере в настройках браузера.":T.name==="NotFoundError"||T.name==="DevicesNotFoundError"?A="Камера не найдена. Убедитесь, что устройство имеет камеру.":T.name==="NotReadableError"||T.name==="TrackStartError"?A="Камера уже используется другим приложением.":T.message&&(A=`Ошибка: ${T.message}`),i(A)}}return N(),()=>{I=!0,p(!1),a.current&&(a.current.getTracks().forEach(T=>T.stop()),a.current=null)}},[e]),Y.useEffect(()=>{e||(i(""),u(0),f(!1),g(null))},[e]),Y.useEffect(()=>{if(!h||!m)return;console.log("[Desktop] Starting token status polling...");const I=setInterval(async()=>{try{console.log("[Desktop] Checking token status...");const N=await Kn.get("/auth/mobile-token-status",{params:{token:m}});console.log("[Desktop] Token status:",N.data.status),N.data.status==="completed"&&(console.log("[Desktop] Mobile attendance completed!"),clearInterval(I),f(!1),N.data.attendanceData&&(t==null||t(N.data.attendanceData)))}catch(N){console.error("[Desktop] Error checking token status:",N)}},2e3);return()=>{console.log("[Desktop] Stopping token status polling"),clearInterval(I)}},[h,m,t]),Y.useEffect(()=>{if(d<=0)return;const I=setInterval(()=>{u(N=>N-1)},1e3);return()=>clearInterval(I)},[d]);const v=()=>{const I=r.current;if(!I)throw new Error("Видео недоступно");const N=document.createElement("canvas");return N.width=I.videoWidth,N.height=I.videoHeight,N.getContext("2d").drawImage(I,0,0,N.width,N.height),N.toDataURL("image/jpeg",.92)},x=async()=>{b(!0);try{const I=await Kn.post("/auth/mobile-token",{type:n});g(I.data.token),f(!0)}catch(I){console.error("Failed to generate QR token:",I),i("Не удалось сгенерировать QR-код")}finally{b(!1)}},w=async()=>{var I,N;if(!(o||d>0||!c)){u(3),i("Приготовьтесь, снимок через 3 секунды"),l(!0),await new Promise(T=>setTimeout(T,3500));try{i("Проверка изображения...");const T=v(),A=await mk(T);if(A<dEe){i("Обнаружена подделка. Попробуйте снова."),l(!1);return}i("Вычисление дескриптора лица...");const R=await M4(T);i("Сравнение с эталонными снимками...");const F=await Kn.post("/attendance/mark",{descriptor:R,livenessScore:A,type:n});i(n==="CHECK_OUT"?"Уход зарегистрирован. До встречи!":"Отметка успешно сохранена. Приятной работы!"),l(!1),t==null||t(F.data)}catch(T){console.error(T);const A=((N=(I=T.response)==null?void 0:I.data)==null?void 0:N.message)||T.message||"Не удалось сохранить отметку";i(A),l(!1)}}};return e?$.jsxs("div",{className:"modal-backdrop",children:[$.jsxs("div",{className:"modal-content",style:{width:"min(760px, 100%)",display:"grid",gap:"1.75rem"},children:[$.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"flex-start"},children:[$.jsxs("div",{children:[$.jsx("h2",{style:{margin:0,color:"var(--text-primary)",fontSize:"1.75rem"},children:n==="CHECK_OUT"?"Подтверждение ухода":"Проверка присутствия"}),$.jsx("p",{style:{margin:"0.5rem 0 0",color:"var(--text-secondary)",fontSize:"0.95rem"},children:n==="CHECK_OUT"?"Подтвердите ваш уход. Проверим подлинность и зарегистрируем время ухода.":"Проверим, что перед камерой находится реальный человек, и сравним лицо с эталонным профилем."})]}),$.jsx("div",{style:{width:"68px",height:"68px",borderRadius:"50%",border:`3px solid ${d>0?"var(--accent-primary)":"var(--border-medium)"}`,display:"grid",placeItems:"center",fontWeight:700,fontSize:"1.5rem",color:d>0?"var(--accent-primary)":"var(--text-tertiary)",transition:"all 0.3s ease",background:d>0?"rgba(59, 130, 246, 0.05)":"transparent"},children:d>0?d:c?"✓":"..."})]}),$.jsxs("div",{style:{position:"relative",borderRadius:"var(--radius-lg)",overflow:"hidden",border:"2px solid var(--border-light)",background:"#000",boxShadow:"var(--shadow-lg)"},children:[$.jsx("video",{ref:r,autoPlay:!0,playsInline:!0,muted:!0,style:{width:"100%",display:"block",minHeight:"400px"}}),!c&&$.jsx("div",{style:{position:"absolute",inset:0,display:"grid",placeItems:"center",background:"rgba(0, 0, 0, 0.5)",color:"#fff",fontSize:"1.1rem"},children:"Инициализация..."})]}),$.jsxs("div",{style:{display:"grid",gap:"1rem"},children:[$.jsx("div",{style:{padding:"1rem 1.25rem",borderRadius:"var(--radius-md)",background:o?"rgba(59, 130, 246, 0.1)":c?"rgba(16, 185, 129, 0.1)":"rgba(148, 163, 184, 0.1)",color:o?"var(--accent-primary)":c?"var(--accent-success)":"var(--text-secondary)",fontSize:"0.95rem",fontWeight:500,textAlign:"center"},children:s||"Подготовка..."}),$.jsx("button",{type:"button",className:"primary-button",onClick:w,disabled:o||!c||d>0,style:{width:"100%",padding:"1rem"},children:$.jsx("span",{children:o?"Проверяем...":d>0?`Снимок через ${d}...`:"Отметиться"})}),$.jsx("button",{type:"button",className:"secondary-button",onClick:x,disabled:y||o,style:{width:"100%",padding:"1rem"},children:$.jsx("span",{children:y?"Генерация QR-кода...":"📱 Отметиться через телефон"})})]})]}),h&&m&&$.jsx("div",{className:"modal-backdrop",style:{zIndex:1001},onClick:()=>f(!1),children:$.jsxs("div",{className:"modal-content",style:{maxWidth:"500px",textAlign:"center",padding:"2rem"},onClick:I=>I.stopPropagation(),children:[$.jsx("h3",{style:{margin:"0 0 1rem",color:"var(--text-primary)"},children:"Отсканируйте QR-код"}),$.jsx("p",{style:{margin:"0 0 1rem",color:"var(--text-secondary)",fontSize:"0.95rem"},children:"Откройте камеру на телефоне и отсканируйте код для отметки через мобильное устройство"}),$.jsxs("div",{style:{padding:"0.75rem 1rem",background:"rgba(59, 130, 246, 0.1)",borderRadius:"var(--radius-md)",color:"#3b82f6",fontSize:"0.9rem",fontWeight:500,marginBottom:"1.5rem",display:"flex",alignItems:"center",gap:"0.5rem",justifyContent:"center"},children:[$.jsx("span",{style:{fontSize:"1.2rem"},children:"📱"}),"Ожидание отметки с телефона..."]}),$.jsx("div",{style:{display:"inline-block",padding:"1.5rem",background:"#fff",borderRadius:"var(--radius-lg)",boxShadow:"0 4px 12px rgba(0, 0, 0, 0.1)"},children:$.jsx(NR,{value:`https://192.168.1.239:5173/mobile-checkin?token=${m}`,size:256,level:"H",includeMargin:!1})}),$.jsx("p",{style:{margin:"1.5rem 0 0",color:"var(--text-tertiary)",fontSize:"0.85rem"},children:"QR-код действителен 5 минут"}),$.jsx("button",{type:"button",className:"secondary-button",onClick:()=>f(!1),style:{marginTop:"1.5rem",width:"100%"},children:"Закрыть"})]})})]}):null}function pEe({data:e}){if(!e||e.length===0)return $.jsx("div",{style:{textAlign:"center",padding:"3rem",color:"var(--text-tertiary)",background:"var(--bg-tertiary)",borderRadius:"var(--radius-md)"},children:"Нет данных для отображения"});const t=Math.max(...e.map(n=>n.count),1);return $.jsxs("div",{style:{display:"grid",gap:"1.5rem"},children:[$.jsx("div",{style:{display:"grid",gridTemplateColumns:`repeat(${Math.min(e.length,7)}, 1fr)`,gap:"1rem",alignItems:"end",minHeight:"200px",padding:"1rem",background:"var(--bg-tertiary)",borderRadius:"var(--radius-md)",border:"1px solid var(--border-light)"},children:e.slice(0,7).map((n,r)=>{const a=n.count/t*100;return $.jsxs("div",{style:{display:"flex",flexDirection:"column",gap:"0.5rem",alignItems:"center"},children:[$.jsx("div",{style:{position:"relative",width:"100%",height:"160px",display:"flex",flexDirection:"column",justifyContent:"flex-end"},children:$.jsx("div",{style:{height:`${a}%`,background:"linear-gradient(180deg, #3b82f6 0%, #8b5cf6 100%)",borderRadius:"var(--radius-md)",transition:"all 0.3s ease",display:"flex",alignItems:"center",justifyContent:"center",color:"#fff",fontWeight:700,fontSize:"1.1rem",boxShadow:"0 4px 12px rgba(59, 130, 246, 0.3)",minHeight:"30px"},children:n.count})}),$.jsx("div",{style:{fontSize:"0.75rem",color:"var(--text-secondary)",textAlign:"center",fontWeight:500},children:n.date})]},r)})}),$.jsxs("div",{style:{display:"grid",gridTemplateColumns:"repeat(auto-fit, minmax(200px, 1fr))",gap:"1rem"},children:[$.jsxs("div",{style:{padding:"1rem",background:"var(--bg-tertiary)",borderRadius:"var(--radius-md)",border:"1px solid var(--border-light)"},children:[$.jsx("div",{style:{fontSize:"0.85rem",color:"var(--text-secondary)",marginBottom:"0.25rem"},children:"Всего отметок"}),$.jsx("div",{style:{fontSize:"1.5rem",fontWeight:700,color:"var(--accent-primary)"},children:e.reduce((n,r)=>n+r.count,0)})]}),$.jsxs("div",{style:{padding:"1rem",background:"var(--bg-tertiary)",borderRadius:"var(--radius-md)",border:"1px solid var(--border-light)"},children:[$.jsx("div",{style:{fontSize:"0.85rem",color:"var(--text-secondary)",marginBottom:"0.25rem"},children:"Средняя подлинность"}),$.jsxs("div",{style:{fontSize:"1.5rem",fontWeight:700,color:(()=>{const n=e.reduce((r,a)=>r+(a.avgConfidence||0),0)/e.length*100;return n>=95?"var(--accent-success)":n>=85?"var(--accent-primary)":n>=70?"var(--accent-warning)":"var(--accent-error)"})()},children:[(e.reduce((n,r)=>n+(r.avgConfidence||0),0)/e.length*100).toFixed(0),"%"]})]})]})]})}function hEe(){const{user:e,logout:t}=xb(),[n,r]=Y.useState([]),[a,s]=Y.useState({todayCount:0,weekCount:0,monthCount:0,avgConfidence:0,chartData:[]}),[i,o]=Y.useState(!1),[l,d]=Y.useState("CHECK_IN"),[u,c]=Y.useState(""),[p,h]=Y.useState(!0),[f,m]=Y.useState(!1),[g,y]=Y.useState(!1),[b,v]=Y.useState(!0),x=N=>{if(!N||N.length===0)return!1;const T=new Date;T.setHours(0,0,0,0);const A=N[0],R=new Date(A.createdAt);return R.setHours(0,0,0,0),R.getTime()===T.getTime()},w=async(N=!0)=>{console.log("Loading attendance data...",{isInitialLoad:b,autoOpenModal:N}),b?h(!0):m(!0);try{const[T,A]=await Promise.all([Kn.get("/attendance/history"),Kn.get("/attendance/stats")]),R=T.data.records||[];console.log(`Loaded ${R.length} attendance records`),R.length>0&&console.log("Most recent record:",R[0]),r(R);const F=A.data||{todayCount:0,weekCount:0,monthCount:0,avgConfidence:0,chartData:[]};console.log("Loaded stats:",F),s(F);const C=x(R);console.log("Checked in today:",C),y(C),N&&b&&!C&&o(!0),b&&v(!1)}catch(T){console.error("Failed to load data:",T),s({todayCount:0,weekCount:0,monthCount:0,avgConfidence:0,chartData:[]}),N&&b&&o(!0),b&&v(!1)}finally{h(!1),m(!1)}};Y.useEffect(()=>{w()},[]);const I=async N=>{console.log("Attendance marked successfully:",N),o(!1),N.type==="CHECK_OUT"?(c(`Уход подтвержден. Подлинность: ${(N.livenessScore*100).toFixed(1)}%. Выход из системы...`),setTimeout(async()=>{console.log("Logging out after checkout..."),await t()},2e3)):(c(`Приход отмечен. Подлинность: ${(N.livenessScore*100).toFixed(1)}%`),y(!0),setTimeout(()=>{console.log("Reloading attendance data..."),w(!1)},1e3))};return $.jsxs("div",{style:{maxWidth:"1100px",margin:"0 auto",display:"grid",gap:"2.5rem"},children:[$.jsx(cEe,{open:i,onSuccess:I,type:l}),$.jsxs("div",{className:"card fade-in",style:{display:"grid",gap:"1.5rem"},children:[$.jsxs("div",{children:[$.jsxs("h2",{style:{margin:0,color:"var(--text-primary)",fontSize:"1.75rem"},children:["Здравствуйте, ",e.fullName||e.email,"!"]}),$.jsx("p",{style:{margin:"0.5rem 0 0",color:"var(--text-secondary)"},children:g?"Вы уже отметились сегодня. Приятного рабочего дня!":"Отметьтесь через камеру для подтверждения посещения."})]}),g&&!u&&$.jsxs("div",{style:{padding:"1rem 1.25rem",borderRadius:"var(--radius-md)",background:"rgba(16, 185, 129, 0.1)",color:"#059669",fontSize:"0.95rem",fontWeight:500,display:"flex",alignItems:"center",gap:"0.75rem"},children:[$.jsx("span",{style:{fontSize:"1.5rem"},children:"✓"}),$.jsx("span",{children:"Вы уже отметились сегодня"})]}),u&&$.jsx("div",{style:{padding:"1rem 1.25rem",borderRadius:"var(--radius-md)",background:"rgba(16, 185, 129, 0.1)",color:"#059669",fontSize:"0.95rem",fontWeight:500},children:u}),g&&$.jsx("div",{style:{padding:"1rem 1.25rem",borderRadius:"var(--radius-md)",background:"rgba(59, 130, 246, 0.05)",color:"var(--text-secondary)",fontSize:"0.9rem",border:"1px solid rgba(59, 130, 246, 0.2)"},children:"💡 Вы можете отметиться повторно, но это будет вторая отметка за сегодня. Обычно достаточно одной отметки в день."}),$.jsxs("div",{style:{display:"flex",gap:"1rem"},children:[$.jsx("button",{type:"button",className:g?"secondary-button":"primary-button",onClick:()=>{d("CHECK_IN"),o(!0)},disabled:i,children:$.jsx("span",{children:g?"↻ Отметить приход повторно":"→ Отметить приход"})}),$.jsx("button",{type:"button",className:"secondary-button",onClick:()=>{d("CHECK_OUT"),o(!0)},disabled:i,style:{background:"linear-gradient(135deg, #dc2626 0%, #ef4444 100%)",color:"#fff",border:"none"},children:$.jsx("span",{children:"← Подтвердить уход"})})]})]}),!p&&$.jsxs("div",{className:"fade-in",style:{display:"grid",gap:"1.5rem"},children:[$.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center"},children:[$.jsx("h3",{style:{margin:0,color:"var(--text-primary)",fontSize:"1.4rem"},children:"Ваша статистика"}),f&&$.jsx("span",{style:{color:"var(--text-tertiary)",fontSize:"0.9rem"},children:"Обновление..."})]}),$.jsxs("div",{style:{display:"grid",gridTemplateColumns:"repeat(auto-fit, minmax(240px, 1fr))",gap:"1.25rem"},children:[$.jsxs("div",{className:"stat-card",children:[$.jsx("div",{style:{color:"var(--text-secondary)",fontSize:"0.9rem",marginBottom:"0.5rem"},children:"Сегодня"}),$.jsx("div",{style:{fontSize:"2.5rem",fontWeight:700,color:"var(--accent-primary)"},children:a.todayCount}),$.jsx("div",{style:{color:"var(--text-tertiary)",fontSize:"0.85rem",marginTop:"0.25rem"},children:"отметок"})]}),$.jsxs("div",{className:"stat-card",children:[$.jsx("div",{style:{color:"var(--text-secondary)",fontSize:"0.9rem",marginBottom:"0.5rem"},children:"За неделю"}),$.jsx("div",{style:{fontSize:"2.5rem",fontWeight:700,color:"var(--accent-secondary)"},children:a.weekCount}),$.jsx("div",{style:{color:"var(--text-tertiary)",fontSize:"0.85rem",marginTop:"0.25rem"},children:"отметок"})]}),$.jsxs("div",{className:"stat-card",children:[$.jsx("div",{style:{color:"var(--text-secondary)",fontSize:"0.9rem",marginBottom:"0.5rem"},children:"За месяц"}),$.jsx("div",{style:{fontSize:"2.5rem",fontWeight:700,color:"var(--accent-success)"},children:a.monthCount}),$.jsx("div",{style:{color:"var(--text-tertiary)",fontSize:"0.85rem",marginTop:"0.25rem"},children:"отметок"})]}),$.jsxs("div",{className:"stat-card",children:[$.jsx("div",{style:{color:"var(--text-secondary)",fontSize:"0.9rem",marginBottom:"0.5rem"},children:"Средняя подлинность"}),$.jsxs("div",{style:{fontSize:"2.5rem",fontWeight:700,color:(()=>{const N=a.avgConfidence*100;return N>=95?"var(--accent-success)":N>=85?"var(--accent-primary)":N>=70?"var(--accent-warning)":"var(--accent-error)"})()},children:[(a.avgConfidence*100).toFixed(0),"%"]}),$.jsx("div",{style:{color:"var(--text-tertiary)",fontSize:"0.85rem",marginTop:"0.25rem"},children:"достоверности"})]})]})]}),!p&&a.chartData&&a.chartData.length>0&&$.jsxs("div",{className:"card fade-in",style:{display:"grid",gap:"1.5rem"},children:[$.jsxs("div",{children:[$.jsx("h3",{style:{margin:0,color:"var(--text-primary)",fontSize:"1.4rem"},children:"График посещаемости"}),$.jsx("p",{style:{margin:"0.5rem 0 0",color:"var(--text-secondary)",fontSize:"0.95rem"},children:"Последние 7 дней активности"})]}),$.jsx(pEe,{data:a.chartData})]}),$.jsxs("div",{className:"card fade-in",style:{display:"grid",gap:"1.5rem"},children:[$.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"flex-start"},children:[$.jsxs("div",{children:[$.jsx("h3",{style:{margin:0,color:"var(--text-primary)",fontSize:"1.4rem"},children:"История отметок"}),$.jsx("p",{style:{margin:"0.5rem 0 0",color:"var(--text-secondary)",fontSize:"0.95rem"},children:"Последние 50 записей посещений"})]}),f&&$.jsx("span",{style:{color:"var(--text-tertiary)",fontSize:"0.9rem",padding:"0.5rem"},children:"Обновление..."})]}),p?$.jsx("div",{style:{textAlign:"center",padding:"3rem",color:"var(--text-tertiary)"},children:"Загрузка..."}):n.length===0?$.jsx("div",{style:{textAlign:"center",padding:"3rem",color:"var(--text-tertiary)",background:"var(--bg-tertiary)",borderRadius:"var(--radius-md)"},children:"Пока нет отметок. Пройдите проверку чтобы создать первую запись."}):$.jsx("div",{style:{display:"grid",gap:"0.75rem"},children:n.map(N=>$.jsxs("div",{className:"card-compact",style:{display:"flex",justifyContent:"space-between",alignItems:"center",gap:"1rem"},children:[$.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"0.75rem"},children:[$.jsx("span",{className:"badge",style:{background:N.type==="CHECK_OUT"?"linear-gradient(135deg, #dc2626 0%, #ef4444 100%)":"linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%)",color:"#fff",fontWeight:600},children:N.type==="CHECK_OUT"?"← Уход":"→ Приход"}),$.jsxs("span",{className:`badge ${N.livenessScore>.9?"badge-success":N.livenessScore>.7?"badge-warning":"badge-error"}`,children:[(N.livenessScore*100).toFixed(1),"% подлинность"]})]}),$.jsx("span",{style:{color:"var(--text-secondary)",fontSize:"0.95rem"},children:new Date(N.createdAt).toLocaleString("ru-RU",{year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"})})]},N.id))})]})]})}const x_={fullName:"",email:"",password:""};function fEe({open:e,onClose:t,onSuccess:n}){const[r,a]=Y.useState(x_),[s,i]=Y.useState(!1),[o,l]=Y.useState(""),[d,u]=Y.useState(null),[c,p]=Y.useState(""),h=Y.useRef(null),f=b=>{const{name:v,value:x}=b.target;a(w=>({...w,[v]:x}))},m=()=>{a(x_),u(null),p(""),l(""),h.current&&(h.current.value="")},g=async b=>{var v,x;if(b.preventDefault(),!s){if(!d){l("Пожалуйста, добавьте фотографию сотрудника");return}i(!0),l("");try{await Jv();const w=await D4(d);await n({...r,descriptor:w}),m(),t()}catch(w){const I=((x=(v=w.response)==null?void 0:v.data)==null?void 0:x.message)||w.message||"Не удалось сохранить сотрудника. Попробуйте позже.";l(I)}finally{i(!1)}}},y=b=>{b.target===b.currentTarget&&!s&&(m(),t())};return e?$.jsx("div",{className:"modal-backdrop",onClick:y,children:$.jsxs("div",{className:"modal-content",style:{width:"min(540px, 100%)"},children:[$.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:"1.5rem"},children:[$.jsx("h2",{style:{margin:0,color:"var(--text-primary)",fontSize:"1.5rem"},children:"Добавить сотрудника"}),$.jsx("button",{type:"button",onClick:()=>{s||(m(),t())},disabled:s,style:{background:"none",border:"none",fontSize:"1.5rem",color:"var(--text-tertiary)",cursor:"pointer",padding:"0.25rem",lineHeight:1},children:"×"})]}),$.jsxs("form",{onSubmit:g,style:{display:"grid",gap:"1.25rem"},children:[$.jsxs("div",{children:[$.jsx("label",{style:{display:"block",marginBottom:"0.5rem",fontSize:"0.9rem",fontWeight:500,color:"var(--text-secondary)"},children:"ФИО"}),$.jsx("input",{type:"text",name:"fullName",value:r.fullName,onChange:f,required:!0,placeholder:"Фамилия Имя",style:{width:"100%"},autoFocus:!0})]}),$.jsxs("div",{children:[$.jsx("label",{style:{display:"block",marginBottom:"0.5rem",fontSize:"0.9rem",fontWeight:500,color:"var(--text-secondary)"},children:"Email"}),$.jsx("input",{type:"email",name:"email",value:r.email,onChange:f,required:!0,placeholder:"example@company.com",style:{width:"100%"}})]}),$.jsxs("div",{children:[$.jsx("label",{style:{display:"block",marginBottom:"0.5rem",fontSize:"0.9rem",fontWeight:500,color:"var(--text-secondary)"},children:"Пароль"}),$.jsx("input",{type:"password",name:"password",value:r.password,onChange:f,required:!0,minLength:6,placeholder:"Минимум 6 символов",style:{width:"100%"}})]}),$.jsxs("div",{children:[$.jsx("label",{style:{display:"block",marginBottom:"0.5rem",fontSize:"0.9rem",fontWeight:500,color:"var(--text-secondary)"},children:"Фотография сотрудника"}),$.jsxs("label",{className:"secondary-button",style:{display:"inline-flex",alignItems:"center",justifyContent:"center",cursor:"pointer",minHeight:"2.75rem"},children:[$.jsx("span",{children:c||"Выберите изображение"}),$.jsx("input",{ref:h,type:"file",accept:"image/*",style:{display:"none"},onChange:b=>{var x;const v=(x=b.target.files)==null?void 0:x[0];v?(u(v),p(v.name)):(u(null),p(""))},disabled:s})]}),$.jsx("p",{style:{margin:"0.5rem 0 0",color:"var(--text-tertiary)",fontSize:"0.8rem"},children:"Выберите четкое фото лица в хорошем освещении."})]}),o&&$.jsx("div",{style:{padding:"1rem",borderRadius:"var(--radius-md)",background:"rgba(239, 68, 68, 0.1)",color:"#dc2626",fontSize:"0.9rem"},children:o}),$.jsxs("div",{style:{display:"flex",gap:"1rem",marginTop:"0.5rem"},children:[$.jsx("button",{type:"submit",className:"primary-button",disabled:s,style:{flex:1},children:$.jsx("span",{children:s?"Создание...":"Добавить сотрудника"})}),$.jsx("button",{type:"button",className:"secondary-button",onClick:()=>{s||(m(),t())},disabled:s,children:"Отмена"})]})]})]})}):null}function mEe(){const[e,t]=Y.useState([]),[n,r]=Y.useState(!0),[a,s]=Y.useState(""),[i,o]=Y.useState(Date.now()),l=async c=>{r(!0);try{const p=c?{date:c}:{},h=await Kn.get("/admin/attendance/all",{params:p});t(h.data.attendances||[])}catch(p){console.error("Failed to load attendances:",p),t([])}finally{r(!1)}};Y.useEffect(()=>{l(a)},[a,i]);const d=()=>{o(Date.now())},u=c=>{s(c.target.value)};return $.jsxs("div",{className:"card fade-in",style:{display:"grid",gap:"1.5rem"},children:[$.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center"},children:[$.jsxs("div",{children:[$.jsx("h3",{style:{margin:0,color:"var(--text-primary)",fontSize:"1.5rem"},children:"Отметки сотрудников"}),$.jsx("p",{style:{margin:"0.5rem 0 0",color:"var(--text-secondary)",fontSize:"0.95rem"},children:"Полная история посещений с фильтрацией"})]}),$.jsxs("div",{style:{display:"flex",gap:"1rem",alignItems:"center"},children:[$.jsxs("label",{style:{display:"flex",alignItems:"center",gap:"0.5rem",color:"var(--text-secondary)",fontSize:"0.95rem"},children:[$.jsx("span",{children:"Дата:"}),$.jsx("input",{type:"date",value:a,onChange:u,style:{maxWidth:"180px"}})]}),a&&$.jsx("button",{type:"button",className:"secondary-button",onClick:()=>s(""),style:{padding:"0.5rem 1rem"},children:"Сбросить"}),$.jsx("button",{type:"button",className:"secondary-button",onClick:d,style:{padding:"0.5rem 1rem"},title:"Обновить данные",children:"↻ Обновить"})]})]}),n?$.jsx("div",{style:{textAlign:"center",padding:"3rem",color:"var(--text-tertiary)"},children:"Загрузка..."}):e.length===0?$.jsx("div",{style:{textAlign:"center",padding:"3rem",color:"var(--text-tertiary)",background:"var(--bg-tertiary)",borderRadius:"var(--radius-md)"},children:"Нет отметок за выбранный период"}):$.jsx("div",{style:{overflowX:"auto"},children:$.jsxs("table",{children:[$.jsx("thead",{children:$.jsxs("tr",{children:[$.jsx("th",{children:"Сотрудник"}),$.jsx("th",{children:"Email"}),$.jsx("th",{children:"Тип"}),$.jsx("th",{children:"Подлинность"}),$.jsx("th",{children:"Время отметки"})]})}),$.jsx("tbody",{children:e.map(c=>$.jsxs("tr",{children:[$.jsx("td",{style:{fontWeight:600},children:c.userName}),$.jsx("td",{style:{color:"var(--text-secondary)"},children:c.userEmail}),$.jsx("td",{children:$.jsx("span",{className:"badge",style:{background:c.type==="CHECK_OUT"?"linear-gradient(135deg, #dc2626 0%, #ef4444 100%)":"linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%)",color:"#fff",fontWeight:600,fontSize:"0.85rem"},children:c.type==="CHECK_OUT"?"Уход":"Приход"})}),$.jsx("td",{children:$.jsxs("span",{className:`badge ${c.livenessScore>.9?"badge-success":c.livenessScore>.7?"badge-warning":"badge-error"}`,children:[(c.livenessScore*100).toFixed(1),"%"]})}),$.jsx("td",{style:{color:"var(--text-secondary)"},children:new Date(c.createdAt).toLocaleString("ru-RU",{year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"})})]},c.id))})]})}),e.length>0&&$.jsx("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",padding:"1rem",background:"var(--bg-tertiary)",borderRadius:"var(--radius-md)",fontSize:"0.9rem",color:"var(--text-secondary)"},children:$.jsxs("span",{children:["Всего записей: ",$.jsx("strong",{children:e.length})]})})]})}function gEe({progress:e,label:t}){return $.jsxs("div",{style:{display:"grid",gap:"0.75rem"},children:[t&&$.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",color:"var(--text-secondary)",fontSize:"0.9rem"},children:[$.jsx("span",{children:t}),$.jsxs("span",{style:{fontWeight:600,color:"var(--accent-primary)"},children:[Math.round(e),"%"]})]}),$.jsx("div",{className:"progress-container",children:$.jsx("div",{className:"progress-bar",style:{width:`${e}%`},role:"progressbar","aria-valuenow":e,"aria-valuemin":"0","aria-valuemax":"100"})})]})}function yEe(){const[e,t]=Y.useState([]),[n,r]=Y.useState(!0),[a,s]=Y.useState(""),[i,o]=Y.useState(""),[l,d]=Y.useState(!1),[u,c]=Y.useState({}),p=async()=>{r(!0);try{const g=await Kn.get("/admin/users");t(g.data.users)}catch(g){console.error(g)}finally{r(!1)}};Y.useEffect(()=>{p()},[]);const h=async g=>{const y=await Kn.post("/admin/users",g);return s("Сотрудник создан и фотография сохранена"),p(),y.data},f=async(g,y)=>{var b,v,x;if(y){c(w=>({...w,[g]:0})),s(""),o("");try{c(T=>({...T,[g]:10})),await Jv(),c(T=>({...T,[g]:33}));const w=await D4(y);c(T=>({...T,[g]:66}));const I=await Kn.post(`/admin/users/${g}/photo`,{descriptor:w},{headers:{"Content-Type":"application/json"}}),N=!!((b=I==null?void 0:I.data)!=null&&b.replaced);c(T=>({...T,[g]:100})),setTimeout(()=>{c(T=>{const A={...T};return delete A[g],A}),s(N?"Фотография обновлена":"Фотография успешно загружена"),p()},500)}catch(w){const I=((x=(v=w.response)==null?void 0:v.data)==null?void 0:x.message)||w.message||"Ошибка при загрузке изображения";o(I),c(N=>{const T={...N};return delete T[g],T})}}},m=async g=>{var y,b;if(window.confirm("Удалить сотрудника вместе с его данными?"))try{await Kn.delete(`/admin/users/${g}`),s("Сотрудник удалён"),t(v=>v.filter(x=>x.id!==g))}catch(v){const x=((b=(y=v.response)==null?void 0:y.data)==null?void 0:b.message)||"Ошибка при удалении сотрудника";o(x)}};return $.jsxs("div",{style:{display:"grid",gap:"2.5rem",maxWidth:"1400px",margin:"0 auto"},children:[$.jsx(fEe,{open:l,onClose:()=>d(!1),onSuccess:h}),$.jsxs("div",{className:"card fade-in",style:{display:"grid",gap:"1.5rem"},children:[$.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center"},children:[$.jsxs("div",{children:[$.jsx("h2",{style:{margin:0,color:"var(--text-primary)",fontSize:"1.75rem"},children:"Управление сотрудниками"}),$.jsx("p",{style:{margin:"0.5rem 0 0",color:"var(--text-secondary)"},children:"Добавляйте сотрудников, загружайте фотографии и контролируйте наличие дескриптора у каждого сотрудника."})]}),$.jsx("button",{type:"button",className:"primary-button",onClick:()=>d(!0),children:$.jsx("span",{children:"+ Добавить сотрудника"})})]}),a&&$.jsx("div",{style:{padding:"1rem 1.25rem",borderRadius:"var(--radius-md)",background:"rgba(16, 185, 129, 0.1)",color:"#059669",fontSize:"0.95rem",fontWeight:500},children:a}),i&&$.jsx("div",{style:{padding:"1rem 1.25rem",borderRadius:"var(--radius-md)",background:"rgba(239, 68, 68, 0.1)",color:"#dc2626",fontSize:"0.95rem",fontWeight:500},children:i})]}),$.jsxs("div",{className:"card fade-in",children:[$.jsxs("h3",{style:{margin:"0 0 1.5rem",color:"var(--text-primary)",fontSize:"1.4rem"},children:["Сотрудники (",e.length,")"]}),n?$.jsx("div",{style:{textAlign:"center",padding:"3rem",color:"var(--text-tertiary)"},children:"Загрузка..."}):e.length===0?$.jsx("div",{style:{textAlign:"center",padding:"3rem",color:"var(--text-tertiary)",background:"var(--bg-tertiary)",borderRadius:"var(--radius-md)"},children:"Сотрудников пока нет. Нажмите «Добавить сотрудника», чтобы создать нового."}):$.jsx("div",{style:{display:"grid",gap:"1rem"},children:e.map(g=>$.jsxs("div",{className:"card-compact",style:{display:"grid",gap:"1rem"},children:[$.jsxs("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center"},children:[$.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"1rem"},children:[$.jsxs("div",{children:[$.jsx("div",{style:{fontWeight:600,color:"var(--text-primary)",fontSize:"1.05rem"},children:g.fullName||"Без имени"}),$.jsx("div",{style:{color:"var(--text-secondary)",fontSize:"0.9rem",marginTop:"0.25rem"},children:g.email})]}),g.descriptorCount>0?$.jsx("div",{style:{display:"flex",alignItems:"center",justifyContent:"center",width:"32px",height:"32px",background:"rgba(16, 185, 129, 0.15)",borderRadius:"50%",color:"#059669",fontSize:"1.1rem",fontWeight:600},title:"Фото загружено",children:"✓"}):$.jsx("div",{style:{display:"flex",alignItems:"center",justifyContent:"center",width:"32px",height:"32px",background:"rgba(239, 68, 68, 0.15)",borderRadius:"50%",color:"#dc2626",fontSize:"1.1rem",fontWeight:600},title:"Фото не загружено",children:"✗"})]}),$.jsxs("div",{style:{display:"flex",gap:"0.75rem"},children:[$.jsxs("label",{className:"secondary-button",style:{cursor:"pointer"},children:[g.descriptorCount>0?"Обновить фото":"Загрузить фото",$.jsx("input",{type:"file",accept:"image/*",style:{display:"none"},onChange:y=>{var v;const b=(v=y.target.files)==null?void 0:v[0];y.target.value="",f(g.id,b)},disabled:u[g.id]!==void 0})]}),$.jsx("button",{type:"button",className:"secondary-button",onClick:()=>m(g.id),children:"Удалить"})]})]}),u[g.id]!==void 0&&$.jsx(gEe,{progress:u[g.id],label:"Загрузка изображения"})]},g.id))})]}),$.jsx(mEe,{})]})}const bEe=["https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js","https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js","https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js","https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"];function vEe(e){return new Promise((t,n)=>{if(document.querySelector(`script[src="${e}"]`)){t();return}const r=document.createElement("script");r.src=e,r.async=!0,r.onload=()=>t(),r.onerror=()=>n(new Error(`Не удалось загрузить ${e}`)),document.body.appendChild(r)})}function xEe(){const e=Y.useRef(null),t=Y.useRef(null),n=Y.useRef(null),r=Y.useRef(null),a=Y.useRef(!1),s=Y.useRef(null),i=Y.useRef(null),[o,l]=Y.useState("Подготовка демо..."),[d,u]=Y.useState(null),[c,p]=Y.useState(!1);Y.useEffect(()=>{let g=!0;async function y(){try{if(l("Загрузка модулей..."),await Promise.all([...bEe.map(vEe),wb()]),!g)return;l("Запуск камеры...");const b=await navigator.mediaDevices.getUserMedia({video:!0});if(!g){b.getTracks().forEach(x=>x.stop());return}n.current=b,e.current&&(e.current.srcObject=b),await new Promise(x=>{if(!e.current){x();return}e.current.onloadedmetadata=()=>x()});const v=new window.FaceMesh({locateFile:x=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${x}`});v.setOptions({maxNumFaces:5,refineLandmarks:!0,minDetectionConfidence:.5,minTrackingConfidence:.5}),v.onResults(x=>{kEe(x,t.current,i.current)}),r.current=v,l("Готово. Нажмите «Начать проверку»."),p(!0)}catch(b){console.error(b),l(b.message||"Не удалось инициализировать демо")}}return y(),()=>{g=!1,a.current=!1,cancelAnimationFrame(s.current),r.current=null,n.current&&(n.current.getTracks().forEach(b=>b.stop()),n.current=null)}},[]);const h=async()=>{if(!a.current)return;const g=r.current,y=e.current;if(!g||!y)return;await g.send({image:y});const b=wEe(y),v=await mk(b);u(v),i.current=v,l(v>.9?`Реальное лицо (${v.toFixed(2)})`:`Фейк (${v.toFixed(2)})`),s.current=requestAnimationFrame(h)},f=()=>{c&&(a.current||(a.current=!0,l("Запущено сканирование..."),s.current=requestAnimationFrame(h)))},m=()=>{a.current=!1,cancelAnimationFrame(s.current),l("Сканирование остановлено.")};return $.jsx("div",{style:{maxWidth:"960px",margin:"0 auto",display:"grid",gap:"1.5rem"},children:$.jsxs("section",{style:{background:"#fff",borderRadius:"16px",padding:"2rem",border:"1px solid rgba(229, 231, 235, 0.9)",display:"grid",gap:"1.25rem",boxShadow:"0 20px 60px rgba(15, 23, 42, 0.05)"},children:[$.jsxs("div",{children:[$.jsx("h2",{style:{margin:0,color:"#111827"},children:"Live Demo"}),$.jsx("p",{style:{margin:"0.4rem 0 0",color:"#6b7280"},children:"Поток веб-камеры, обработка FaceMesh и WebAssembly-модуль ливнес-проверки."})]}),$.jsxs("div",{style:{display:"flex",gap:"1rem"},children:[$.jsx("button",{type:"button",className:"primary-button",onClick:f,disabled:!c,children:"Начать проверку"}),$.jsx("button",{type:"button",className:"secondary-button",onClick:m,children:"Остановить"})]}),$.jsx("div",{style:{color:d>.9?"#047857":"#b91c1c",fontWeight:500},children:o}),$.jsxs("div",{style:{position:"relative",borderRadius:"16px",overflow:"hidden",border:"1px solid rgba(209, 213, 219, 0.6)",background:"#000"},children:[$.jsx("video",{ref:e,autoPlay:!0,playsInline:!0,muted:!0,style:{width:"100%"}}),$.jsx("canvas",{ref:t,style:{position:"absolute",inset:0,width:"100%",height:"100%"}})]})]})})}function wEe(e){const t=document.createElement("canvas");return t.width=e.videoWidth,t.height=e.videoHeight,t.getContext("2d").drawImage(e,0,0,t.width,t.height),t.toDataURL("image/jpeg",.92)}function kEe(e,t,n){if(!t||!e)return;const r=t.getContext("2d");if(r.clearRect(0,0,t.width,t.height),!e.multiFaceLandmarks)return;t.width=e.image.width,t.height=e.image.height;const a=n??0,s=a>.9,i="#10b981",o="#ef4444";e.multiFaceLandmarks.forEach((l,d)=>{const u=s?i:o,c=SEe(l,t.width,t.height);r.beginPath(),r.strokeStyle=u,r.lineWidth=3,r.rect(c.x,c.y,c.size,c.size),r.stroke(),r.fillStyle=u,r.font="bold 16px Inter, sans-serif",r.textAlign="left";const p=s?"Реальное лицо":"Фейк";r.fillText(p,c.x+8,c.y+22);const h=`${a.toFixed(2)}`;r.font="12px Inter, sans-serif",r.fillStyle=u,r.fillText(h,c.x+8,c.y+38)})}function SEe(e,t,n){const r=[10,151,9,8,107,55,65,52,53,46,172,136,150,149,176,148,152,377,400,378,379,365,397,288,361,323,454,356,389,251,284,332,297,338];let a=1/0,s=1/0,i=-1/0,o=-1/0;r.forEach(f=>{const m=e[f],g=m.x*t,y=m.y*n;a=Math.min(a,g),i=Math.max(i,g),s=Math.min(s,y),o=Math.max(o,y)});const l=30;a=Math.max(0,a-l),s=Math.max(0,s-l),i=Math.min(t,i+l),o=Math.min(n,o+l);const d=i-a,u=o-s,c=Math.max(d,u),p=a+d/2,h=s+u/2;return{x:p-c/2,y:h-c/2,size:c}}const IEe=.9;function NEe({type:e="CHECK_IN",onSuccess:t,onError:n}){const r=Y.useRef(null),a=Y.useRef(null),[s,i]=Y.useState(""),[o,l]=Y.useState(!1),[d,u]=Y.useState(0),[c,p]=Y.useState(!1);Y.useEffect(()=>{let m=!1;async function g(){try{if(console.log("[MobileCamera] Starting initialization..."),i("Запуск камеры..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new Error("getUserMedia не поддерживается в этом браузере");console.log("[MobileCamera] Requesting camera access...");const y=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user",width:{ideal:1280},height:{ideal:720}}});if(console.log("[MobileCamera] Camera access granted"),m){y.getTracks().forEach(b=>b.stop());return}a.current=y,r.current&&(r.current.srcObject=y),console.log("[MobileCamera] Loading liveness module..."),i("Загрузка модуля проверки..."),await wb(),console.log("[MobileCamera] Liveness module loaded"),m||(p(!0),i("Готово! Нажмите кнопку для отметки"))}catch(y){console.error("[MobileCamera] Initialization error:",y);let b="Не удалось получить доступ к камере";y.name==="NotAllowedError"||y.name==="PermissionDeniedError"?b="Доступ к камере запрещен. Пожалуйста, разрешите доступ к камере в настройках браузера.":y.name==="NotFoundError"||y.name==="DevicesNotFoundError"?b="Камера не найдена. Убедитесь, что устройство имеет камеру.":y.name==="NotReadableError"||y.name==="TrackStartError"?b="Камера уже используется другим приложением.":y.message&&(b=`Ошибка: ${y.message}`),i(b),n==null||n(b)}}return g(),()=>{m=!0,p(!1),a.current&&(a.current.getTracks().forEach(y=>y.stop()),a.current=null)}},[n]),Y.useEffect(()=>{if(d<=0)return;const m=setInterval(()=>{u(g=>g-1)},1e3);return()=>clearInterval(m)},[d]);const h=()=>{const m=r.current;if(!m)throw new Error("Видео недоступно");const g=document.createElement("canvas");return g.width=m.videoWidth,g.height=m.videoHeight,g.getContext("2d").drawImage(m,0,0,g.width,g.height),g.toDataURL("image/jpeg",.92)},f=async()=>{var m,g;if(!(o||d>0||!c)){u(3),i("Приготовьтесь! Снимок через 3 секунды"),l(!0),await new Promise(y=>setTimeout(y,3500));try{i("Проверка изображения...");const y=h(),b=await mk(y);if(b<IEe){i("Обнаружена подделка. Попробуйте снова."),l(!1);return}i("Вычисление дескриптора лица...");const v=await M4(y);i("Сравнение с эталонными снимками...");const x=await Kn.post("/attendance/mark",{descriptor:v,livenessScore:b,type:e});i(e==="CHECK_OUT"?"Уход зарегистрирован. До встречи!":"Отметка успешно сохранена. Приятной работы!"),l(!1),t==null||t(x.data)}catch(y){console.error(y);const b=((g=(m=y.response)==null?void 0:m.data)==null?void 0:g.message)||y.message||"Не удалось сохранить отметку";i(b),l(!1),n==null||n(b)}}};return $.jsxs("div",{style:{position:"fixed",inset:0,background:"#000",display:"flex",flexDirection:"column",zIndex:9999},children:[$.jsxs("div",{style:{flex:1,position:"relative",overflow:"hidden",background:"#000"},children:[$.jsx("video",{ref:r,autoPlay:!0,playsInline:!0,muted:!0,style:{width:"100%",height:"100%",objectFit:"cover"}}),c&&$.jsx("div",{style:{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",width:"280px",height:"350px",border:`3px solid ${d>0?"#3b82f6":"rgba(255, 255, 255, 0.5)"}`,borderRadius:"50% 50% 50% 50% / 60% 60% 40% 40%",boxShadow:d>0?"0 0 0 9999px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(59, 130, 246, 0.5)":"0 0 0 9999px rgba(0, 0, 0, 0.3)",transition:"all 0.3s ease",pointerEvents:"none"},children:d>0&&$.jsxs($.Fragment,{children:[$.jsx("div",{style:{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",width:"100px",height:"100px",borderRadius:"50%",background:"rgba(0, 0, 0, 0.4)",backdropFilter:"blur(4px)",zIndex:9}}),$.jsx("div",{style:{position:"absolute",top:"50%",left:"50%",transform:"translate(-50%, -50%)",width:"80px",height:"80px",borderRadius:"50%",background:"#3b82f6",display:"flex",alignItems:"center",justifyContent:"center",fontSize:"2.5rem",fontWeight:700,color:"#fff",boxShadow:"0 4px 20px rgba(59, 130, 246, 0.6)",zIndex:10},children:d})]})}),!c&&$.jsx("div",{style:{position:"absolute",inset:0,display:"flex",alignItems:"center",justifyContent:"center",background:"rgba(0, 0, 0, 0.7)",color:"#fff",fontSize:"1.2rem",padding:"2rem",textAlign:"center"},children:$.jsxs("div",{children:[$.jsx("div",{style:{fontSize:"3rem",marginBottom:"1rem",animation:"pulse 2s ease-in-out infinite"},children:"⏳"}),"Инициализация камеры..."]})})]}),$.jsxs("div",{style:{background:"linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 100%)",padding:"1.5rem",display:"flex",flexDirection:"column",gap:"1rem",borderTop:"1px solid rgba(255, 255, 255, 0.1)"},children:[$.jsx("div",{style:{padding:"1rem",borderRadius:"12px",background:o?"rgba(59, 130, 246, 0.2)":c?"rgba(16, 185, 129, 0.2)":"rgba(148, 163, 184, 0.2)",color:o?"#60a5fa":c?"#34d399":"#cbd5e1",fontSize:"1rem",fontWeight:600,textAlign:"center",border:`2px solid ${o?"#3b82f6":c?"#10b981":"rgba(148, 163, 184, 0.3)"}`,minHeight:"60px",display:"flex",alignItems:"center",justifyContent:"center"},children:s||"Подготовка..."}),$.jsxs("button",{type:"button",onClick:f,disabled:o||!c||d>0,style:{width:"100%",padding:"1.25rem",fontSize:"1.25rem",fontWeight:700,borderRadius:"12px",border:"none",background:o||!c||d>0?"rgba(100, 116, 139, 0.5)":"linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%)",color:"#fff",cursor:o||!c||d>0?"not-allowed":"pointer",boxShadow:o||!c||d>0?"none":"0 4px 12px rgba(59, 130, 246, 0.4)",transition:"all 0.2s ease",display:"flex",alignItems:"center",justifyContent:"center",gap:"0.75rem",opacity:o||!c||d>0?.5:1},children:[$.jsx("span",{style:{fontSize:"1.5rem"},children:"📸"}),o?"Проверяем...":d>0?`Снимок через ${d}...`:"Отметиться"]}),$.jsx("p",{style:{margin:0,textAlign:"center",color:"rgba(255, 255, 255, 0.6)",fontSize:"0.85rem",lineHeight:"1.4"},children:"Расположите лицо в центре овала и нажмите кнопку"})]})]})}const n0="https://192.168.1.239:5000/api";function CEe(){const[e]=Mj(),t=gf(),[n,r]=Y.useState(null),[a,s]=Y.useState("CHECK_IN"),[i,o]=Y.useState(!0),[l,d]=Y.useState(""),[u,c]=Y.useState(""),[p,h]=Y.useState(!1);Y.useEffect(()=>{const y=e.get("token");if(console.log("[Mobile] Token from URL:",y),console.log("[Mobile] API Base URL:",n0),!y){d("Неверная ссылка. QR-код недействителен."),o(!1);return}const b=`${n0}/auth/mobile-verify?token=${y}`;console.log("[Mobile] Verifying token at:",b),Wt.get(b).then(v=>{console.log("[Mobile] Token verification success:",v.data),r(v.data.user),s(v.data.type||"CHECK_IN");const x=v.data.token;sessionStorage.setItem("mobile_jwt",x),o(!1)}).catch(v=>{var w,I,N,T;console.error("[Mobile] Token verification error:",v),console.error("[Mobile] Error response:",(w=v.response)==null?void 0:w.data),console.error("[Mobile] Error status:",(I=v.response)==null?void 0:I.status);const x=((T=(N=v.response)==null?void 0:N.data)==null?void 0:T.message)||"Ошибка валидации токена. Пожалуйста, отсканируйте QR-код заново.";d(x),o(!1)})},[e]);const f=async y=>{console.log("[Mobile] Attendance success:",y),c(`Отметка успешно подтверждена! Подлинность: ${(y.livenessScore*100).toFixed(1)}%`),h(!1),d("");const b=e.get("token");if(b)try{console.log("[Mobile] Notifying desktop about completion..."),await Wt.post(`${n0}/auth/mobile-token-complete`,{token:b,attendanceData:y}),console.log("[Mobile] Desktop notified successfully")}catch(v){console.error("[Mobile] Failed to notify desktop:",v)}},m=y=>{console.error("[Mobile] Attendance error:",y),d(y),h(!1)},g=()=>{console.log("[Mobile] Opening camera..."),d(""),h(!0)};return i?$.jsx("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,display:"flex",alignItems:"center",justifyContent:"center",background:"linear-gradient(135deg, #667eea 0%, #764ba2 100%)",padding:"1.5rem"},children:$.jsx("div",{style:{background:"#fff",borderRadius:"16px",padding:"1.5rem",textAlign:"center",color:"var(--text-secondary)",maxWidth:"400px",width:"100%",boxShadow:"0 20px 60px rgba(0, 0, 0, 0.3)"},children:"Загрузка..."})}):l&&!n?$.jsx("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,display:"flex",alignItems:"center",justifyContent:"center",background:"linear-gradient(135deg, #667eea 0%, #764ba2 100%)",padding:"1.5rem"},children:$.jsxs("div",{style:{background:"#fff",borderRadius:"16px",padding:"1.5rem",textAlign:"center",maxWidth:"400px",width:"100%",boxShadow:"0 20px 60px rgba(0, 0, 0, 0.3)"},children:[$.jsx("div",{style:{fontSize:"3rem",marginBottom:"1rem"},children:"⚠️"}),$.jsx("h2",{style:{color:"var(--text-primary)",marginBottom:"1rem"},children:"Ошибка"}),$.jsx("p",{style:{color:"var(--text-secondary)",marginBottom:"1.5rem"},children:l}),$.jsx("button",{className:"primary-button",onClick:()=>t("/"),children:"На главную"})]})}):p&&n?$.jsx(NEe,{type:a,onSuccess:f,onError:m}):u?$.jsx("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,background:"linear-gradient(135deg, #10b981 0%, #059669 100%)",padding:"1.5rem",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center"},children:$.jsxs("div",{style:{background:"#fff",borderRadius:"20px",padding:"2rem",maxWidth:"400px",width:"100%",boxShadow:"0 20px 60px rgba(0, 0, 0, 0.3)",textAlign:"center"},children:[$.jsx("div",{style:{fontSize:"5rem",marginBottom:"1.5rem",animation:"bounce 1s ease-in-out"},children:"✅"}),$.jsx("h1",{style:{fontSize:"2rem",fontWeight:700,color:"#10b981",marginBottom:"1rem"},children:"Успешно!"}),$.jsx("p",{style:{color:"var(--text-secondary)",fontSize:"1.1rem",marginBottom:"2rem",lineHeight:"1.6"},children:u}),$.jsxs("div",{style:{padding:"1.25rem",background:"rgba(16, 185, 129, 0.1)",borderRadius:"12px",marginBottom:"2rem"},children:[$.jsx("div",{style:{fontSize:"0.9rem",color:"var(--text-secondary)",marginBottom:"0.5rem"},children:(n==null?void 0:n.fullName)||(n==null?void 0:n.email)}),$.jsx("div",{style:{fontSize:"1.1rem",fontWeight:600,color:"var(--text-primary)"},children:a==="CHECK_IN"?"👋 Приход зарегистрирован":"👋 Уход зарегистрирован"})]}),$.jsx("p",{style:{color:"var(--text-tertiary)",fontSize:"0.9rem"},children:a==="CHECK_IN"?"Приятной работы!":"До встречи!"})]})}):$.jsx("div",{style:{position:"fixed",top:0,left:0,right:0,bottom:0,background:"linear-gradient(135deg, #667eea 0%, #764ba2 100%)",padding:"1.5rem",display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center"},children:$.jsxs("div",{style:{background:"#fff",borderRadius:"20px",padding:"2rem",maxWidth:"400px",width:"100%",boxShadow:"0 20px 60px rgba(0, 0, 0, 0.3)"},children:[$.jsxs("div",{style:{textAlign:"center",marginBottom:"1.5rem"},children:[$.jsx("div",{style:{fontSize:"4rem",marginBottom:"1rem"},children:"👋"}),$.jsx("h1",{style:{fontSize:"2rem",fontWeight:700,color:"var(--text-primary)",marginBottom:"0.75rem"},children:a==="CHECK_IN"?"Отметка прихода":"Отметка ухода"}),$.jsx("p",{style:{color:"var(--text-secondary)",fontSize:"1.05rem",fontWeight:500},children:(n==null?void 0:n.fullName)||(n==null?void 0:n.email)})]}),l&&n&&$.jsxs("div",{style:{padding:"1.25rem",borderRadius:"12px",background:"rgba(239, 68, 68, 0.1)",color:"#dc2626",marginBottom:"2rem",textAlign:"center",fontWeight:500,fontSize:"0.95rem",border:"2px solid rgba(239, 68, 68, 0.2)"},children:["⚠️ ",l]}),$.jsxs("div",{style:{padding:"1.25rem",background:a==="CHECK_IN"?"rgba(59, 130, 246, 0.08)":"rgba(139, 92, 246, 0.08)",borderRadius:"16px",border:`2px solid ${a==="CHECK_IN"?"rgba(59, 130, 246, 0.2)":"rgba(139, 92, 246, 0.2)"}`,marginBottom:"1.5rem"},children:[$.jsx("div",{style:{fontSize:"0.9rem",color:"var(--text-secondary)",marginBottom:"0.75rem",textAlign:"center"},children:"Для подтверждения отметки:"}),$.jsxs("ul",{style:{listStyle:"none",padding:0,margin:0,display:"flex",flexDirection:"column",gap:"0.75rem"},children:[$.jsxs("li",{style:{display:"flex",alignItems:"center",gap:"0.75rem",color:"var(--text-secondary)",fontSize:"0.95rem"},children:[$.jsx("span",{style:{fontSize:"1.5rem"},children:"📸"}),"Разрешите доступ к камере"]}),$.jsxs("li",{style:{display:"flex",alignItems:"center",gap:"0.75rem",color:"var(--text-secondary)",fontSize:"0.95rem"},children:[$.jsx("span",{style:{fontSize:"1.5rem"},children:"👤"}),"Расположите лицо в центре экрана"]}),$.jsxs("li",{style:{display:"flex",alignItems:"center",gap:"0.75rem",color:"var(--text-secondary)",fontSize:"0.95rem"},children:[$.jsx("span",{style:{fontSize:"1.5rem"},children:"✨"}),"Проверка подлинности произойдет автоматически"]})]})]}),$.jsxs("button",{className:"primary-button",onClick:g,style:{width:"100%",padding:"1.25rem",fontSize:"1.2rem",fontWeight:700,display:"flex",alignItems:"center",justifyContent:"center",gap:"0.75rem"},children:[$.jsx("span",{style:{fontSize:"1.5rem"},children:"📸"}),"Открыть камеру"]})]})})}function TEe(){const{user:e,logout:t,loading:n}=xb(),r=hs(),a=[{to:"/",label:"Главная",icon:"🏠"},...e&&e.role==="ADMIN"?[{to:"/admin",label:"Управление",icon:"⚙️"},{to:"/live-demo",label:"Live Demo",icon:"📹"}]:[],...e&&e.role==="EMPLOYEE"?[{to:"/dashboard",label:"Мой кабинет",icon:"👤"}]:[]],s=i=>r.pathname===i;return $.jsx("header",{className:"top-bar",children:$.jsxs("div",{className:"top-bar-inner",children:[$.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"2rem"},children:[$.jsx(Ax,{to:"/",style:{fontWeight:700,fontSize:"1.25rem",background:"linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%)",WebkitBackgroundClip:"text",WebkitTextFillColor:"transparent",backgroundClip:"text"},children:"Attendance Monitor"}),$.jsx("nav",{className:"top-nav",children:a.map(i=>$.jsxs(Ax,{to:i.to,style:{color:s(i.to)?"var(--accent-primary)":"var(--text-secondary)",fontWeight:s(i.to)?600:500,position:"relative",display:"flex",alignItems:"center",gap:"0.5rem"},children:[i.label,s(i.to)&&$.jsx("div",{style:{position:"absolute",bottom:"-0.5rem",left:0,right:0,height:"3px",background:"linear-gradient(90deg, #3b82f6 0%, #8b5cf6 100%)",borderRadius:"3px"}})]},i.to))})]}),$.jsx("div",{style:{display:"flex",gap:"1rem",alignItems:"center"},children:n?$.jsx("div",{style:{color:"var(--text-tertiary)",fontSize:"0.9rem",padding:"0.5rem 1rem"},children:"Загрузка..."}):e?$.jsxs($.Fragment,{children:[$.jsxs("div",{style:{display:"flex",alignItems:"center",gap:"0.75rem",padding:"0.5rem 1rem",background:"var(--bg-tertiary)",borderRadius:"var(--radius-full)",border:"1px solid var(--border-light)"},children:[$.jsx("div",{style:{width:"32px",height:"32px",borderRadius:"50%",background:"linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%)",display:"grid",placeItems:"center",color:"#fff",fontWeight:600,fontSize:"0.9rem"},children:(e.fullName||e.email).charAt(0).toUpperCase()}),$.jsx("span",{style:{color:"var(--text-primary)",fontWeight:500,fontSize:"0.95rem"},children:e.fullName||e.email})]}),$.jsx("button",{type:"button",className:"secondary-button",onClick:t,children:"Выйти"})]}):$.jsx(Ax,{className:"primary-button",to:"/login",children:"Войти"})})]})})}function EEe(){const t=hs().pathname==="/mobile-checkin";return $.jsxs("div",{className:"app-shell",children:[!t&&$.jsx(TEe,{}),$.jsx("main",{className:"main-content",children:$.jsxs(Sj,{children:[$.jsx(ko,{path:"/",element:$.jsx(p6,{})}),$.jsx(ko,{path:"/login",element:$.jsx(h6,{})}),$.jsx(ko,{path:"/mobile-checkin",element:$.jsx(c6,{children:$.jsx(CEe,{})})}),$.jsx(ko,{path:"/dashboard",element:$.jsx(Mx,{allow:["EMPLOYEE"],children:$.jsx(hEe,{})})}),$.jsx(ko,{path:"/admin",element:$.jsx(Mx,{allow:["ADMIN"],children:$.jsx(yEe,{})})}),$.jsx(ko,{path:"/live-demo",element:$.jsx(Mx,{allow:["ADMIN"],children:$.jsx(xEe,{})})})]})})]})}r0.createRoot(document.getElementById("root")).render($.jsx(Kt.StrictMode,{children:$.jsx(Aj,{children:$.jsx(d6,{children:$.jsx(EEe,{})})})}));
